/**
 * @public
 *
 * 숫자 형 컬럼 셀의 값을 바(bar)로 표시하는 렌더러
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'bar';
 *
 * // object type
 * column.renderer = {
 *      "type": "bar",
 *      "minimum": 0,
 *      "maximum": 100,
 *      "minWidth": 150,
 *      "showLabel": true,
 *      "origin": "left"
 * }
 * ```
 */
export declare interface BarCellRenderer extends CellRenderer {
    /**
     * 왼쪽에서 시작하는 바의 스타일 명
     *
     * @defaultValue `'rg-bar-renderer-bar'`
     */
    barStyle?: string;
    /**
     * 오른쪽에서 시작하는 바의 스타일 명
     *
     * @defaultValue `'rg-bar-renderer-bar-right'`
     */
    rightBarStyle?: string;
    /**
     * 위쪽에서 시작하는 바의 스타일 명
     *
     * @defaultValue `'rg-bar-renderer-bar-top'`
     */
    topBarStyle?: string;
    /**
     * 아래쪽에서 시작하는 바의 스타일 명
     *
     * @defaultValue `'rg-bar-renderer-bar-bottom'`
     */
    bottomBarStyle?: string;
    /**
     * 최소값
     */
    minimum?: number;
    /**
     * 최대값
     */
    maximum?: number;
    /**
     * Label 을 표시할 것인지의 여부
     */
    showLabel?: boolean;
    /**
     * 바의 시작 위치
     *
     * @defaultValue {@link BarOrigin.LEFT}
     */
    origin?: BarOrigin;
    /**
     * 절대값 기준으로 렌더링 할지의 여부
     */
    absoluteValue?: boolean;
}

/**
 * {@link BarCellRenderer} 의 바의 위치
 *
 * @example
 * ```js
 * column.renderer = {
 *      "type": "bar",
 *      "origin":"right"
 * }
 * ```
 */
export declare enum BarOrigin {
    /**
     * 기본값
     */
    DEFAULT = "default",
    /**
     * 왼쪽
     */
    LEFT = "left",
    /**
     * 오른쪽
     */
    RIGHT = "right",
    /**
     * 위쪽
     */
    TOP = "top",
    /**
     * 아래쪽
     */
    BOTTOM = "bottom"
}

/**
 * @public
 *
 * {@link DataColumn.equalBlank}가 `true`일때 셀의 위치
 */
declare enum BlankState {
    /**
     * equalBlank가 적용되지 않음.
     */
    NONE = "none",
    /**
     * 첫번째 셀
     */
    HEAD = "head",
    /**
     * 중간에 위치한 셀
     */
    BODY = "body",
    /**
     * 마지막에 위치한 셀
     */
    TAIL = "tail"
}

/**
 * boolean 필드 변환시 수행 될 콜백함수 형식
 *
 * @remarks
 * {@link DataOutputOptions.booleanCallback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `ds` - DataProvider 컨트롤
 *
 * `row` - 아이템의 인덱스
 *
 * `field` - 필드명
 *
 * `value` - 값
 *
 * [반환값] - 출력할 값
 *
 * @example
 * ```js
 * const f = function(ds, row, field, value) {
 *      return !!value;
 * }
 * ```
 */
export declare type BooleanOutputCallback = (ds: DataProviderBase, row: number, field: string, value: any) => boolean | any;

/**
 * @public
 * BootStrap DatePicker 를 이용한 편집기
 *
 * @remarks
 *
 * 번들 이후 다음과 같이 파일을 적용해야 정상적으로 작동한다.
 *
 * {@link TextCellEditor} 를 상속 한다.
 *
 * [상위 클래스]
 *
 * {@link CellEditor} - {@link TextCellEditor}
 *
 * @example
 *
 * ```js
 * // string type
 * column.editor = "btdate"
 *
 * // object type
 * column.editor = { type: "btdate", maxLength: 6, textReadOnly: true }
 * ```
 *
 * ```html
 * <script type="text/javascript" src="/lib/bootstrap/bootstrap-datepicker.js"></script>
 * <script type="text/javascript" src="/lib/bootstrap/bootstrap-datepicker.ko.min.js"></script>
 * <link rel="stylesheet" type="text/css" href="/lib/css/bootstrap-datepicker.css">
 * ```
 */
export declare interface BTDateCellEditor extends TextCellEditor {

    /**
     * BootStrap DatePicker의 옵션
     *
     * @remarks
     * {@link https://uxsolutions.github.io/bootstrap-datepicker/ | 참조}
     */
    btOptions: any;
    /**
     * 키보드를 이용한 입력 금지 여부
     */
    textReadOnly: boolean;

    /**
     * 입력 가능한 최소 날짜
     *
     * @remarks
     * 키보드로 minDate 보다 이전 날짜가 입력되면, minDate 로 변경된다.
     *
     * @defaultValue `new Date(1970, 0, 1)`
     */
    minDate: string | Date;
    /**
     * 입력 가능한 최대 날짜
     *
     * @remarks
     * 키보드로 maxDate 보다 이후 날짜가 입력되면, maxDate 로 변경된다.
     *
     * @defaultValue `new Date(2100, 11, 31)`
     */
    maxDate: string | Date;
    /**
     * 그리드 DOM 내부에 포함시킬 것인지의 여부
     *
     * @defaultValue `false`
     */
    viewGridInside: boolean;
    /**
     * 달력 선택 상자의 위치
     *
     * @defaultValue {@link DropDownPosition.BUTTON}
     */
    dropDownPosition: DropDownPosition;
    /**
     * 셀을 클릭했을 때 목록을 펼칠지의 여부
     *
     * @defaultValue `false`
     */
    dropDownWhenClick: boolean;
    /**
     * 선택 시 commit 여부
     *
     * @defaultValue `false`
     */
    commitOnSelect: boolean;
}

/**
 * @public
 *
 * 버튼을 표시하는 렌더러
 *
 * @remarks
 * 자동 높이에서 `TOP_EDGE`, `BOTTOM_EDGE` 를 사용할 수 없다.
 *
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'button';
 *
 * // object type
 * column.renderer = {
 *      "type": "button",
 *      "hideWhenEmpty": false
 * }
 * ```
 */
export declare interface ButtonCellRenderer extends CellRenderer {
    /**
     * 표시 되는 버튼의 스타일 클래스 명
     *
     * @defaultValue `'rg-button-renderer-button'`
     */
    buttonStyle?: string;
    /**
     * 빈 값일 때 버튼을 표시할지의 여부
     *
     * @remarks
     * `true` 시 `undefined`, `null`, `''`, `NaN` 일 경우 버튼을 표시하지 않는다.
     *
     * @defaultValue `true`
     */
    hideWhenEmpty?: boolean;
    /**
     * spaceKey를 입력했을때 button.click 실행여부
     *
     * @remarks
     * true이면 스페이스바를 입력했을때 button.click이 실행된다.
     * {@link GridBase.onCellItemClicked}가 있는 경우 해당 이벤트가 호출된후 결과값이 false이면 기본동작을 실행하지 않는다
     *
     * @defaultValue `true`
     */
    spaceKey?: boolean;
    /**
     * enter를 입력했을때 button.click 실행여부
     *
     * @remarks
     * true이면 enterKey를 입력했을때 입력했을때 button.click이 실행된다.
     * {@link GridBase.onCellItemClicked}가 있는 경우 해당 이벤트가 호출된후 결과값이 false이면 기본동작을 실행하지 않는다
     *
     * @defaultValue `true`
     */
    enterKey?: boolean;
}

/**
 * @public
 *
 * 컬럼에 버튼이 설정된 경우, 데이터 셀에 컬럼 버튼과 편집 버튼을 표시하는 방법
 *
 * @remarks
 * ValueColumn의 {@link ValueColumn.buttonVisibility | buttonVisibility} 속성과 {@link ValueColumn.editButtonVisibility| editButtonVisibility} 속성에 사용된다.
 *
 * @example
 * ```js
 * // 컬럼 버튼
 * column.buttonVisibility = false;
 *
 * // 편집기의 버튼
 * column.editButtonVisibility = false;
 * ```
 */
export declare enum ButtonVisibility {
    /**
     * 항상 표시
     */
    ALWAYS = "always",
    /**
     * 마우스가 셀 위에 있거나, 셀을 선택한 상태에서만 표시
     */
    DEFAULT = "default",
    /**
     * 셀을 선택한 상태에서 표시
     */
    VISIBLE = "visible",
    /**
     * 표시하지 않음
     */
    HIDDEN = "hidden",
    /**
     * 행이 선택된 상태에서 표시
     */
    ROWFOCUSED = "rowfocused"
}

/**
 * @public
 * column.button이 `action` 또는 `popup`인 경우 visible을 지정한 콜백
 *
 * [매개변수]
 *
 * `grid` - gridView
 *
 * `index` - 셀의 CellIndex
 *
 * [반환값] - boolean `false`를 return하면 버튼을 표시하지 않는다.
 */
declare type ButtonVisibleCallback = (grid: GridBase, index: CellIndex, focused: boolean, mouseEntered: boolean) => boolean;

/**
 * 자동 필터링 시 사용자 지정 분류를 위한 콜백 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `column` - 자동 필터링이 걸려있는 컬럼
 *
 * `values` - 전체 값들
 *
 * [반환값] - 카데고리 분류 모델의 배열 형태
 *
 * @example
 *
 * ```js
 * const f = function(column, values) {
 *      const emptyText = '빈 아이템'
 *      if (!values) {
 *          return null;
 *      }
 *      const valids = values.filter(function (el) { return el != undefined && el != null; });
 *      const min = Math.min.apply(null, valids);
 *      const vlen = values.length;
 *      let unit;
 *      if (vlen > 15) {
 *          const groupCount = Math.min(Math.round(vlen / 5)), 10);
 *          unit = Math.round(vlen / groupCount);
 *      } else {
 *          unit = 1;
 *      }
 *      let categories = [];
 *      let gvals = [];
 *      let gindex = 0;
 *      let gmin = min;
 *      let isEmpty = false;
 *      for (let i = 0; i < vlen; i++) {
 *          const v = values[i];
 *          if (v === undefined || v === null) {
 *              isEmpty = true;
 *              continue;
 *          }
 *          if (i == gindex + unit || i === vlen - 1) {
 *              categories.push({ text: gmin + ' ~ ' + v, values: gvals });
 *              gvals = [v];
 *              gindex = i;
 *              gmin = v;
 *          } else {
 *              gvals.push(v);
 *          }
 *      }
 *      if (isEmpty) {
 *          categories.push({ text: emptyText, empty: true });
 *      }
 *      return categories;
 * }
 * ```
 *
 */
export declare type CategoryCallback = (column: DataColumn, values: any[]) => FilterCategory[];

/**
 * @public
 *
 * 데이터 셀의 우측에 표시할 버튼 종류
 *
 * @remarks
 * {@link ValueColumn.button} 에서 사용된다.
 *
 * @example
 * ```js
 * column.button = 'popup';
 * ```
 */
export declare enum CellButton {
    /**
     * 버튼 없음
     */
    NONE = "none",
    /**
     * 실행 버튼 (클릭 시 {@link GridBase.onCellButtonClicked | onCellButtonClicked} 콜백 호출)
     */
    ACTION = "action",
    /**
     * 팝업 메뉴 버튼
     *
     * @remarks
     * 컬럼에 {@link ValueColumn.popupMenu | popupMenu } 속성값이 있고, 컬럼의 popupMenu 값과 {@link GridBase.addPopupMenu | addPopupMenu} 호출 시 name 값과 일치 해야 한다.
     *
     * 팝업 메뉴의 메뉴 항목 클릭 시 {@link GridBase.onMenuItemClicked | onMenuItemClicked} 콜백이 호출된다.
     */
    POPUP = "popup"
}

/**
 * @public
 * 셀 편집기들의 기반이 되는 모델
 *
 * @remarks
 * 셀 편집기 별로 지정할 수 있는 속성이 있으며, DataColumn 에 지정하지 않을 시 {@link LineCellEditor} 가 기본으로 설정된다.
 *
 * 또, 오브젝트 형태일 때의 `type` 속성을 {@link ValueColumn.editor | column.editor} 에 문자열 형태로 지정 가능하다.
 *
 * [목록]
 *
 * {@link LineCellEditor}: 한 줄 입력 편집기
 *
 * {@link PasswordCellEditor}: 암호 입력 편집기
 *
 * {@link MultiLineCellEditor}: 여러 줄 입력 편집기
 *
 * {@link NumberCellEditor}: 숫자 입력 편집기
 *
 * {@link DateCellEditor}: 날짜 편집기
 *
 * {@link BTDateCellEditor}: 부트스트랩 날짜 편집기
 *
 * {@link DropDownCellEditor}: 드롭 다운 편집기
 *
 * {@link SearchCellEditor}: 검색 기능이 추가 된 드롭 다운 편집기
 *
 * {@link MultiCheckCellEditor}: 여러 항목이 선택 가능한 드롭 다운 편집기
 *
 * @warning CellEditor 로 직접 설정하거나 호출할 수 없다.
 *
 * @example
 *
 * ```js
 * // string type
 * column.editor = "line"
 *
 * // object type
 * column.editor = { type: "line", maxLength: 1}
 * ```
 */
export declare interface CellEditor {
    /**
     * 셀 편집기 종류
     *
     * @remarks
     *
     * {@link LineCellEditor}: "line" 또는 "text"
     *
     * {@link PasswordCellEditor}: "password"
     *
     * {@link MultiLineCellEditor}: "multiline"
     *
     * {@link NumberCellEditor}: "number"
     *
     * {@link DateCellEditor}: "date"
     *
     * {@link BTDateCellEditor}: "btdate"
     *
     * {@link DropDownCellEditor}: "dropdown" 또는 "list"
     *
     * {@link SearchCellEditor}: "search"
     *
     * {@link MultiCheckCellEditor}: "checklist"
     */
    type?: string;
    /**
     * 셀의 값을 제거하거나 편집후 공백일때 저장되는 값
     */
    emptyValue?: any;
    /**
     * 편집기의 입력되는 문자의 대소문자 구분 형태
     *
     * @remarks
     * 편집기에 입력되는 문자를 자동으로 대소문자로 변경한다.
     * {@link TextInputCase.DEFAULT} 로 지정하면 컬럼의 textInputCase에 지정한 값을 따르게 된다.
     */
    textCase?: TextInputCase;
    /**
     * 날짜 형식의 값일 때 표시되는 편집기의 서식
     *
     * @remarks
     * 데이터 필드가 날짜 타입일 때 작동
     */
    datetimeFormat?: string;
    /**
     * 편집기에서 현재 날짜를 입력하도록 하는 문자
     *
     * @remarks
     * 데이터 필드가 날짜 타입이거나, 텍스트 타입이지만 날짜 편집기일 때 동작한다.
     *
     */
    todayChar?: string;

    /**
     * Boolean 값일 때 표시되는 편집기의 서식
     *
     * @remarks
     * 데이터 필드가 boolean 타입일 때 동작한다.
     */
    booleanFormat?: string;
    /**
     * 데이터 셀의 값 수정 가능 여부
     *
     * @remarks
     * `true` 일 때
     *
     * @defaultValue `false`
     */
    readOnly?: boolean;
}

/**
 * @public
 *
 * 셀의 위치정보 모델
 *
 * @remarks
 * {@link GridBase.onCurrentChanging | onCurrentChanging} 등 {@link GridBase} 의 여러 콜백 및 셀 위치 관련 method 들에서 주로 사용된다.
 *
 * 필요한 정보만 사용하면 된다.
 *
 * @example
 * ```js
 * gridView.setCurrent({ itemIndex: 1, column: '행정구역별' });
 * ```
 */
export declare interface CellIndex {
    /**
     * 그리드 상에서의 순서
     */
    itemIndex?: number;
    /**
     * 컬럼 이름
     */
    column?: string | GridColumn;
    /**
     * 고유의 행 번호
     */
    dataRow?: number;
    /**
     * 필드 순서
     */
    fieldIndex?: number;
    /**
     * 필드명
     */
    fieldName?: string;
}

/**
 * @public
 * 컬럼 레이아웃 정보 모델
 *
 * @remarks
 * {@link GridBase.getLayoutByColumn} 에서 해당 모델을 반환할 수 있다.
 *
 * {@link GridBase.setColumnLayout} 로 설정될 때에는 특정 속성만 사용 가능하다.
 *
 * {@link GridColumn.layout} 의 속성으로 설정 가능하다.
 *
 * {@link CellLayoutItem} 을 상속한다.
 *
 * [상위 클래스]
 *
 * {@link CellLayoutItem}
 *
 *
 * @example
 * ```js
 * // 반환값일 경우
 * {
 *      mergeRule: undefined,
 *      breakMergeOnEmpty: false,
 *      equalBlank: undefined,
 *      equalBlankExpression: undefined,
 *      cellSpan: 1,
 *      headerSpan: undefined,
 *      summarySpan: undefined,
 *      footerSpan: undefined,
 *      dataSpan: undefined,
 *      spanCallback: undefined,
 *      visible: true,
 *      vindex: 1,
 *      width: 100,
 *      fillWidth: NaN,
 *      cellWidth: 250
 * }
 *
 * // method 로 설정할 경우
 * {
 *      column: 'Country'
 *      cellSpan: 3,
 *      width: 100,
 * }
 *
 * {
 *      column: 'Country'
 *      headerSpan: 2,
 *      summarySpan: 2,
 *      footerSpan: 2,
 *      dataSpan: 4,
 * }
 *
 * // 컬럼에 설정할 경우
 * column.layout.spanCallback = function (grid, layout, itemIndex) {
 *     var value = grid.getValue(itemIndex, layout.column.name);
 *     if (value) {
 *         return value[0] === "B" ? 2 : value[0] === "F" ? 3 : 1;
 *     }
 * ```
 */
export declare interface CellLayoutColumnItem extends CellLayoutItem {
    /**
     * 컬럼 머지할 때의 규칙
     *
     * @remarks
     * `undefined` 이면(기본값) 컬럼의 mergeRule 로 병합한다.
     * `null` 이면 컬럼의 mergeRule 을 무시한다.
     * `{criteria: string}`은 이전버전과 호환성을 위해서 사용한다.
     */
    mergeRule?: string | {
        criteria: string;
    };
    /**
     * 빈 셀일 때 머지 중단 여부
     */
    breakMergeOnEmpty?: boolean;
    /**
     * 같은 컬럼의 이전 행의 셀과 값이 동일할때 셀의 묶음 여부
     *
     * @defaultValue `undefined`
     */
    equalBlank?: boolean;
    /**
     * {@link CellLayoutColumnItem.equalBlank | equalBlank } 가 `true`인 경우 같은 값으로 처리할 수식
     *
     * @defaultValue `undefined`
     */
    equalBlankExpression?: string;
    /**
     * 컬럼명
     *
     */
    column: string | ValueColumn;
    /**
     * 기본 셀 스팬 개수
     *
     * @remarks
     * 다른 스팬이 지정이 되지 않을 때, 해당 값을 따른다.
     *
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    cellSpan?: number;
    /**
     * 헤더 스팬 개수
     *
     * @remarks
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    headerSpan?: number;
    /**
     * summary 스팬 개수
     *
     * @remarks
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    summarySpans?: number[];
    /**
     * 푸터 스팬 개수
     *
     * @remarks
     * summary가 하나인 경우 summarySpan 으로 지정한다.
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    footerSpans?: number[];
    /**
     * 그룹 푸터 스팬 개수
     *
     * @remarks
     * footer가 하나인 경우 footerSpan으로 지정한다.
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    groupFooterSpans?: number[];
    /**
     * 셀 스팬 개수
     *
     * @remarks
     * groupFooter가 하나인 경우 groupFooterSpan으로 지정한다.
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    dataSpan?: number;
    /**
     * 사용자 지정 스팬을 위한 콜백
     *
     * @eventProperty
     * @example
     * ```js
     * let layout = column.layout
     * layout.spanCallback = function (grid, layout, itemIndex) {
     *     var value = grid.getValue(itemIndex, layout.column.dataIndex);
     *     if (value) {
     *         return value[0] === "B" ? 3 : value[0] === "F" ? 2 : 1;
     *     }
     *     return 1;
     * };
     * ```
     */
    spanCallback?: CellSpanCallback;
    /**
     * 사용자 지정 headerSummary 스팬을 위한 콜백
     *
     * @eventProperty
     */
    summarySpanCallback?: SummaryCellSpanCallback;
    /**
     * 사용자 지정 footer 스팬을 위한 콜백
     *
     * @eventProperty
     */
    footerSpanCallback?: SummaryCellSpanCallback;
    /**
     * 사용자 지정 groupFooter 스팬을 위한 콜백
     *
     * * @eventProperty
     */
    groupFooterSpanCallback?: GroupFooterCellSpanCallback;
    /**
     * 사용자 지정 groupFooter UserSpan을 위한 콜백 groupFooterSpanCallback과는 다르게 block단위로 span할수 있다.
     *
     * * @eventProperty
     */
    groupFooterUserSpanCallback?: GroupFooterUserSpanCallback;
    /**
     * 사용자 지정 footer span
     */
    footerUserSpans?: UserSpan[];
    /**
     * 사용자 지정 headerSummary span
     */
    summaryUserSpans?: UserSpan[];
    /**
     * 사용자 지정 groupFooter span
     */
    groupFooterUserSpans?: UserSpan[];
}

/**
 * @public
 *
 * {@link CellLayoutGroupItem.header}의 설정 정보 모델
 *
 * [상위 클래스]
 * {@link CellLayoutHeader}
 */
export declare interface CellLayoutGroupHeader extends CellLayoutHeader {
    /**
     * 툴팁에 표시될 문자열을 지정.
     *
     * @remarks
     * 지정하지 않으면 text가 표시된다.
     */
    tooltip?: string;
    /**
     * header에 적용되어 표시될 html 템플릿
     *
     * @remarks
     * header에 text가 아닌 html을 표시할때 사용한다.
     *
     * @example
     * ```js
     * var layouts = [
     *   { type: "group"
     *     header: {
     *       template : "<span class='test-style' style='color:red'>HTML 표시 ${key}</span>"
     *     }
     *   }
     * ]
     * ```
     */
    template?: string;
    /**
     * template에 특정 문자열을 교체해서 표시할때 사용
     *
     * @remarks
     * `"${}"`로 둘러싼 문자열을 특정 문자열로 변경할때 사용한다.
     * {@link CellLayoutGroupHeader.template} 참조
     *
     */
    values?: {
        [key: string]: string;
    };
    /**
     *
     * edgeMark 표시여부
     *
     * @remarks
     * Header에 강조 표시를 할때 사용한다.
     * {@link EdgeMark} 참조
     */
    edgeMark?: EdgeMark;
    /**
     * template에 특정 문자열을 교체해서 표시할때 사용
     *
     * @remarks
     * `values`에 없는 문자열인 경우 호출된다.
     */
    templateCallback?: RealizeHeaderCallback;
}

/**
 * @public
 * 그룹 레이아웃 정보 모델
 *
 * @remarks
 * 실제 컬럼이 아닌 화면 상에서 보이는 컬럼 묶음이다.
 *
 * {@link CellLayoutItem} 을 상속한다.
 *
 * [상위 클래스]
 *
 * {@link CellLayoutItem}
 *
 * @example
 * ```js
 * {
 *     name: "companyGroup",
 *     items: [
 *         {
 *             column: "Country",
 *             cellSpan: 3
 *         },
 *         20,20,
 *         {
 *             column: "CompanyName",
 *             cellSpan: 3
 *         },
 *         20,20,
 *     ],
 *     header: true
 * },
 * ```
 */
export declare interface CellLayoutGroupItem extends CellLayoutItem {
    /**
     * 셀 배치 방향
     */
    direction?: ColumnLayoutDirection;
    /**
     * 너비 조정 가능 여부
     */
    resizable?: boolean;
    /**
     * 이동 가능 여부
     */
    movable?: boolean;
    /**
     * 하위 레이아웃의 헤더 숨김 여부
     */
    hideChildHeaders?: boolean;
    /**
     * 하위 레이아웃의 이동여부
     */
    childColumnMovable?: boolean;
    /**
     * 하위 레이아웃 아이템들
     *
     * @remarks
     * 문자열 형태로 입력 시 해당 값을 {@link CellLayoutColumnItem.column | column} 으로 설정한 {@link CellLayoutColumnItem} 을 생성한다.
     *
     * 숫자 형태로 입력시 해당 값을 {@link CellLayoutItem.width | width} 로 설정한 {@link CellLayoutColumnItem} 을 생성한다.
     */
    items?: (LayoutItem | number | string)[];
    /**
     * 헤더의 레이아웃 설정 정보
     *
     * @remarks
     * `string` 또는 `boolean` 으로 {@link CellLayoutHeader.text | text} 또는 {@link CellLayoutHeader.visible | visible} 속성에 부여 가능하다.
     *
     * @example
     *
     * ```js
     *      ...
     *              header: {
     *                  text: 'group1',
     *                  visible: true
     *              },
     *      ...
     *
     *     ...
     *              header: false,
     *      ...
     *
     *     ...
     *              header: 'group3',
     *      ...
     * ```
     */
    header?: CellLayoutGroupHeader | string | boolean;
    /**
     * 하위 레이아웃확장 여부
     *
     * @remarks
     *
     * 하위 레이아웃을 접거나 펼쳐서 일부 레이아웃만 보이도록 한다.
     *
     * @defaultValue `false`
     *
     * @example
     *
     * ```js
     * var layout = [ {
     *      name: "group0",
     *      expandable: true,
     *      expanded: true,
     *      header:{text:"2018년도"}
     *      items:[{column: "합계", groupShowMode: "always"},
     *          {column: "1분기", groupShowMode: "expand"},
     *          {column: "2분기", groupShowMode: "expand"},
     *          {column: "3분기", groupShowMode: "expand"},
     *          {column: "4분기", groupShowMode: "expand"}
     *      ]
     * }, { ....
     * }, { ....
     * }]
     * ```
     */
    expandable?: boolean;
    /**
     * 레이아웃 확장 상태
     *
     * @remarks
     * 레이아웃의 확장상태 `true`이면 하위 레이아웃중 {@link CellLayoutItem.groupShowMode}가 `expand`이거나 `always`인 레이아웃만 표시된다.
     * `false`이면 `collapse`이거나 `always`인 레이아웃이 표시된다.
     */
    expanded?: boolean;
    /**
     * 하위 layout또는 컬럼을 추가한다.
     *
     * @remarks
     * 그리드에 layout이 설정되어있지 않으면 사용할수 없다 {@link GridBase.setColumnLayout}을 이용해서 layout을 설정후 사용한다.
     * 그리드의 root에 추가하기 위해서는 {@link GridBase.addLayout}을 사용한다.
     *
     * @param source - 컬럼명 또는 추가될 layout의 설정
     * @param index - 삽입될 위치 생략하면 마지막에 추가된다.
     *
     * ```js
     * const layout = gridView.layoutByName("group0");
     * layout.addLayout("column");
     * ```
     */
    addLayout?(source: ConfigObject | string, index?: number): CellLayoutItem;
    /**
     * 하위 layout을 제거한다.
     *
     * @remarks
     * 그리드에 layout이 설정되어있지 않으면 사용할수 없다.
     * 그리드 root의 layout을 제거하기 위해서는 {@link GridBase.removeLayout}을 사용한다.
     *
     * @param layout - 제거할 layout의 이름 또는 layout객체
     */
    removeLayout?(layout: LayoutItem | string): void;
}

/**
 * @public
 * 셀 레이아웃 헤더의 설정 정보 모델
 *
 * @remarks
 * `string` 으로 부여시 `text` 에 설정된다.
 *
 * `boolean` 으로 부여시 `visible` 에 설정된다.
 *
 * 따로 `text` 가 설정되지 않은 경우 컬럼 명이 텍스트로 지정된다.
 *
 * @example
 * ```js
 * {
 *      text: 'group1',
 *      visible: true
 * }
 * ```
 */
export declare interface CellLayoutHeader {
    /**
     * 레이아웃 설정 시 보여질 헤더의 텍스트
     */
    text?: string;
    /**
     * 레이아웃 설정 시 적용될 스타일 클래스 명
     */
    styleName?: string;
    /**
     * excel로 export시 적용될 스타일 클래스 명
     */
    exportStyleName?: string;
    /**
     * 표시 여부
     *
     * @remarks
     * 그룹 헤더일 때만 적용 가능
     */
    visible?: boolean;
    /**
     * header 셀의 row count
     *
     * @remarks
     * 여러 level의 그룹이 혼재되어있을때 header의 높이를 일치시키기 위해서 사용한다.
     *
     * 그룹 헤더일 때만 적용 가능
     *
     * @example
     * ```js
     * var layout = [{
     *  name:"group0",
     *  items:[
     *      { name:"group0-1", items:["col1", "col2", "col3"] },
     *      { name:"group0-2", items:["col4", "col5", "col6"] }]
     * }, {
     *  name: "group1",
     *  header: {text:"group1", rows:2},
     *  items: ["col7", "col8"]
     * }]
     * ```
     */
    rows?: number;
    /**
     * 툴팁 표시 여부
     *
     * @remarks
     *
     * @defaultValue `undefined`
     */
    showTooltip?: boolean;
}

/**
 * @public
 * 레이아웃을 설정하기 위한 기반 모델
 *
 * @remarks
 * 하위 모델을 이용하여 {@link GridBase.setColumnLayout} 으로 설정 시, 특정 속성만 사용 가능하다.
 *
 * [하위 클래스]
 *
 * {@link CellLayoutColumnItem}
 *
 * {@link CellLayoutGroupItem}
 *
 * @warning CellLayoutItem 으로 직접 설정할 수 없다.
 */
export declare interface CellLayoutItem {
    /**
     * layout의 type을 지정한다.
     *
     * @remarks
     * {@link CellLayoutType} 참조
     */
    type?: CellLayoutType;
    /**
     * 레이아웃 명
     *
     * @remarks
     * {@link GridBase.setColumnLayout} 로 설정 할 수 있다.
     */
    name?: string;
    /**
     * 표시 여부
     *
     * @remarks
     * {@link GridBase.setColumnLayout} 로 설정 할 수 있다.
     */
    visible?: boolean;
    /**
     * 너비
     *
     * @remarks
     * {@link GridBase.setColumnLayout} 로 설정 할 수 있다.
     */
    width?: number;
    /**
     * 셀 너비
     *
     */
    cellWidth?: number;
    /**
     * {@link GridFitStyle.FILL} 로 설정된 후 사용하는 너비 비율
     */
    fillWidth?: number;
    /**
     * 전체 그룹 혹은 상위 그룹 내에서의 표시 순서
     *
     * @readonly
     */
    vindex?: number;
    /**
     * 상위 레이아웃의 expanded상태에서 따라서 표시하거나 숨긴다.
     *
     * @defaultValue {@link GroupShowMode.ALWAYS | always}
     */
    groupShowMode?: GroupShowMode;
}

/**
 * @public
 * layout의 type을 지정한다.
 *
 * @remarks
 * {@link GridBase.addLayout} 또는 {@link CellLayoutGroupItem.addLayout} 을 이용해서 Layout을 추가할때 layout의 type을 지정한다.
 */
export declare enum CellLayoutType {
    /**
     * groupLayout을 추가할때 사용한다.
     * @remarks
     * `type`이 `group`이거나 `items`가 배열로 설정되면 groupLayout이다.
     */
    GROUP = "group",
    /**
     * 컬럼과 연결된 layout을 생성한다.
     */
    COLUMN = "column",

}

/**
 * @public
 *
 * 셀 잠금 또는 셀 숨김을 설정한다.
 *
 * @remarks
 * DataCell영역에만 적용되고 그외 영역은 적용할수 없다.
 * {@link DataColumn.cellProtectProps} 또는 {@link ColumnStyleObject.cellProtectProps}에서 사용한다.
 * {@link GridExportOptions.sheetProtect}을 이용해서 시트 보호를 설정해야 적용된다.
 */
export declare interface CellProtectProperties {
    /**
     * 잠금
     *
     * @remarks
     * 엑셀 셀의 기본 설정은 잠금이다. 입력가능한 컬럼 또는 셀만 `locked`를 `'0'`으로 설정한다.
     */
    locked?: string;
    /**
     * 수식 숨기기
     *
     * @remarks
     * 셀의 수식을 숨기기 위해서는 `hidden`을 `'1'`로 설정한다.
     */
    hidden?: string;
}

/**
 * @public
 *
 * 셀 렌더러들의 기반 모델
 *
 * @remarks
 * 데이터 셀들의 값을 그리드에 표시하기 위한 장치이다.
 *
 * CellRenderer 의 모든 프로퍼티는 이를 상속한 클래스에서만 호출 / 설정할 수 있다. 아래 목록을 참조할 것.
 *
 * 이전 버전의 셀 렌더러는 기본적으로 컬럼에서 생성되는 스타일 정보를 이용해서 렌더링하지만, 2.0 부터는 css style class 로 적용된다.
 *
 * 각각의 {@link ValueColumn.renderer | 컬럼}에 셀렌더러의 종류와 속성들을 지정한다.
 *
 * 셀 렌더러 별로 지정할 수 있는 속성이 있으며, DataColumn 에 지정하지 않을 시 {@link TextCellRenderer} 가 기본으로 설정된다.
 *
 * 또, 오브젝트 형태일 때 `type` 속성을 {@link ValueColumn.renderer | column.renderer} 에 문자열 형태로 지정 가능하다.
 *
 * [목록]
 *
 * {@link TextCellRenderer}: 기본 텍스트 렌더러
 *
 * {@link BarCellRenderer}: 바 렌더러
 *
 * {@link ImageCellRenderer}: 이미지 렌더러
 *
 * {@link IconCellRenderer}: 아이콘 렌더러
 *
 * {@link CheckCellRenderer}: 체크 셀 렌더러
 *
 * {@link ButtonCellRenderer}: 버튼 렌더러
 *
 * {@link ShapeCellRenderer}: 도형 렌더러
 *
 * {@link LinkCellRenderer}: 링크 셀 렌더러
 *
 * {@link SignalBarCellRenderer}: 시그널 바 렌더러
 *
 * {@link Code39CellRenderer}: 바코드 렌더러
 *
 * {@link Code128CellRenderer}: 바코드 렌더러
 *
 * {@link SeriesTextCellRenderer}: 시리즈 텍스트 렌더러
 *
 * {@link SparkLineRenderer}: 시리즈 스파크 라인 렌더러
 *
 * {@link SparkColumnRenderer}: 시리즈 컬럼 렌더러
 *
 * {@link SparkWinLossRenderer}: 시리즈 윈 로스 렌더러
 *
 * {@link TemplateCellRenderer}: 템플릿 렌더러
 *
 * @warning CellRenderer 로 직접 설정하거나 호출할 수 없다.
 *
 * @example
 * ```js
 * // string type
 * column.renderer = "text"
 *
 * // object type
 * column.renderer = { type: "text", showTooltip: true}
 * ```
 */
export declare interface CellRenderer {
    /**
     * 렌더러의 종류
     *
     * @remarks
     * {@link TextCellRenderer}: `'text'`
     *
     * {@link BarCellRenderer}: `'bar'`
     *
     * {@link ImageCellRenderer}: `'image'`
     *
     * {@link IconCellRenderer}: `'icon'`
     *
     * {@link CheckCellRenderer}: `'check'`
     *
     * {@link ButtonCellRenderer}: `'button'`
     *
     * {@link ShapeCellRenderer}: `'shape'`
     *
     * {@link LinkCellRenderer}: `'link'`
     *
     * {@link SignalBarCellRenderer}: `'signalbar'`
     *
     * {@link Code39CellRenderer}: `'code39'`
     *
     * {@link Code128CellRenderer}: `'code128'`
     *
     * {@link SeriesTextCellRenderer}: `'series'`
     *
     * {@link SparkLineRenderer}: `'sparkline'`
     *
     * {@link SparkColumnRenderer}: `'sparkcolumn'`
     *
     * {@link SparkWinLossRenderer}: `'sparkswinloss'`
     *
     * {@link TemplateCellRenderer}: `'template'`
     */
    type?: string;
    /**
     * 툴팁 표시 여부
     */
    showTooltip?: boolean;
    /**
     * aria-label을 직접 설정할경우 사용하는 콜백
     *
     *
     * @remarks
     * 스크린 리더가 셀의 정보를 읽을때 사용할 문자열을 설정한다.
     *
     * {@link GetAriaLabelCallback} 의 형식을 따른다.
     *
     * [프로퍼티 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `model` - 그리드의 셀
     *
     * @eventProperty
     * @example
     * ```js
     * const f = function(grid, model) {
     *      var s = model.value;
     *      var date = grid.getValue(model.item.index, "date")
     *      s += (date.getTime() > Date.now() - 60*60*24*7*1000) ? " 신규" : "";
     *      return s;
     * }
     *
     * column.renderer = {
     *      type: 'text',
     *      ariaLabelCallback: f
     * }
     * ```
     */
    ariaLabelCallback?: GetAriaLabelCallback;
    /**
     * `true`이면 focus된 셀 또는 focus가 이동할수 있는 셀인 경우에만 click이벤트가 발생하도록 한다.
     *
     * @remarks
     * {@link GridBase.onCurrentChanging} 이벤트에서 false를 return하는 경우 check, link등의 기본동작이 실행되는것을 방지하기위해 사용.
     *
     * @defaultValue `true`
     */
    clickOnlyFocusedCell?: boolean;
}

/**
 * @public
 * 사용자 지정의 cell spanning을 설정하기 위한 콜백
 *
 * @remarks
 * {@link CellLayoutColumnItem} 에서 사용된다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨트롤
 *
 * `layout` - 레이아웃 아이템
 *
 * `itemIndex` - 행의 인덱스
 *
 * @example
 * ```js
 * const f = function (grid, layout, itemIndex) {
 *     var value = grid.getValue(itemIndex, layout.column.dataIndex);
 *     if (value) {
 *         return value[0] === "B" ? 3 : value[0] === "F" ? 2 : 1;
 *     }
 *     return 1;
 * };
 * ```
 */
export declare type CellSpanCallback = (grid: GridBase, layout: CellLayoutColumnItem, itemIndex: number) => number;

/**
 * @public
 * 동적 셀 스타일 변경을 위한 콜백
 *
 * @remarks
 * {@link ColumnStyleObject} 를 반환 할 때는 {@link GridBase.setCellStyleCallback}, {@link ValueColumn.styleCallback} 에서 사용한다.
 *
 * {@link ColumnSummaryStyleObject} 를 반환 할 때는 {@link GridFooter.cellStyleCallback}, {@link HeaderSummary.cellStyleCallback} 에서 사용한다.
 *
 * 문자열 반환 시 스타일 명으로 지정
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `model` - 그리드의 셀
 *
 * [반환값] - 동적 스타일을 부여하기 위한 오브젝트 혹은 스타일 클래스 명
 *
 * @example
 * ```js
 * const f1 = function(grid, model) {
 *      if (model.value > 5) return "rg-data-cell bold-cell";
 *      if (model.value < 0 && model.value > -10) {
 *          return {
 *              styleName: 'custom-negative-cell',
 *              renderer: {
 *                  type: 'bar',
 *                  absoluteValue: true
 *              }
 *          }
 *      }
 * }
 *
 * const f2 = function(grid, model) {
 *      if (model.value > 10) {
 *          return {
 *              styleName: 'custom-summary-cell'
 *          }
 *      }
 * }
 *
 * // 전체 데이터 셀에 적용
 * gridView.setCellStyleCallback(f1);
 *
 * // 컬럼 별 적용
 * let column = gridView.columnByName('Price');
 * column.styleCallback = f1;
 *
 * // 푸터 적용
 * gridView.footer.cellStyleCallback = f2;
 *
 * // header summary 적용
 * gridView.headerSummary.cellStyleCallback = f2;
 * ```
 */
export declare type CellStyleCallback = (grid: GridBase, model: GridCell) => string | ColumnStyleObject | ColumnSummaryStyleObject;

/**
 * {@link CheckBar} 에서 체크 가능 여부를 결정하는 콜백
 *
 * @remarks
 *
 * [매개변수 목록]
 *
 * `dataSource` - DataProvider 컨트롤
 *
 * `item` - 체크의 대상이 되는 아이템 (행 아이템, 헤더 아이템 등)
 *
 * [반환값] - 체크 가능 여부
 *
 * @example
 * ```js
 * const f = function(dataSource, item) {
 *      if (item.value) {
 *          return item.value !== 'doNotCheck';
 *      }
 *      else {
 *          return false;
 *      }
 * }
 * ```
 */
export declare type CheckableCallback = (dataSource: any, item: any) => boolean;

/**
 * 체크바와 관련된 설정 모델
 *
 * @remarks
 * 체크바 영역에서 shift를 누른 상태에서 이전의 행이나 이후의 행을 클릭하면 일괄체크
 *
 * {@link GridBase.setCheckBar} 사용시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setCheckBar({exclusive: true});
 * ```
 */
export declare interface CheckBar {
    /**
     * 너비
     *
     * @defaultValue `20`
     */
    width?: number;
    /**
     * 한 행만 체크 가능한지의 여부
     *
     * @defaultValue `false`
     */
    exclusive?: boolean;
    /**
     * 체크바 헤드에 “v” 표시 여부
     *
     * @remarks
     * 표시 후 체크 시 전체 체크
     *
     * @defaultValue `true`
     */
    showAll?: boolean;
    /**
     * 행 그룹핑시 그룹 헤더 영역에 체크박스 표시 여부
     *
     * @defaultValue `true`
     */
    showGroup?: boolean;
    /**
     * 체크바 헤드를 체크하여 전체선택 시 보이는 행만 체크할 것인지의 여부
     *
     * @defaultValue `true`
     */
    visibleOnly?: boolean;
    /**
     * 체크 가능한 행만 체크할 수 있는지의 여부
     *
     * @remarks
     * checkableExpression 에서 체크 가능 여부를 지정할 수 있다.
     *
     * @defaultValue `true`
     */
    checkableOnly?: boolean;
    /**
     * 체크 가능 여부의 수식
     */
    checkableExpression?: string;
    /**
     * 체크 가능 여부를 결정하는 콜백
     * @eventProperty
     *
     * @remarks
     * `false` 반환 시 체크가 불가능하다.
     *
     * @example
     * ```js
     * const f = function(dataSource, item) {
     *      if (item.value) {
     *          return item.value !== 'doNotCheck';
     *      }
     *      else {
     *          return false;
     *      }
     * }
     *
     * gridView.setCheckBar({checkableCallback: f});
     * ```
     */
    checkableCallback?: CheckableCallback;
    /**
     * 데이터 영역의 전체 item 체크 상태와 체크바의 헤드 연동 여부
     *
     * @remarks
     * 데이터행의 모든 item이 체크되면 Head영역에도 자동으로 체크가 됨
     *
     * @defaultValue `false`
     */
    syncHeadCheck?: boolean;
    /**
     * checkBox의 위치를 지정한다.
     *
     * @remarks
     * headText가 표시될때 checkBox의 위치를 지정한다. checkBar의 너비 또는 {@link GridHeader.height} 높이를 적절히 변경해야 한다.
     *
     * @defaultValue `top`
     */
    checkLocation?: ColumnHeaderItemLocation;
    /**
     * checkBox와 headText의 간격을 지정한다.
     *
     * @defaultValue `5`
     */
    itemGap?: number;
    /**
     * checkBar의 체크상태를 dataField와 연결한다.
     *
     * @defaultValue `null`
     */
    fieldName?: string;
    /**
     * checkBar의 check를 image를 이용해서 표시한다.
     *
     * @defaultValue `false`
     */
    useImages?: boolean;
    /**
     * 체크바, 상태바, 인디케이터 중에서 보여지는 순서 (인덱스)
     *
     * @remarks
     * 숫자가 작을 수록 왼쪽에 배치된다.
     */
    displayOrder?: number;
    /**
     * head 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    headText?: string;
    /**
     * foot 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    footText?: string;
    /**
     * summary 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    sumText?: string;
    /**
     * 팝업 메뉴
     */
    popupMenu?: PopupMenuItem[] | string;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * CheckBox 머지 규칙
     *
     * @remarks
     * 지정된 field에서 동일한 값을 가지는 행들의 CheckBox를 묶어서 보여지도록 한다.
     *
     * ```js
     * gridView.checkBar.mergeRule = "values['fieldName']";
     * gridView.checkBar.mergeRule = "values['field1'] + values['field2']";
     * ```
     */
    mergeRule?: string;
    /**
     * checkBox를 클릭했을때 클릭된 행으로 focus이동여부
     *
     * @defaultValue `false`
     */
    focusMove?: boolean;
    /**
     * 셀의 스타일을 지정하기 위한 콜백
     */
    cellStyleCallback?: RowBarCellStyleCallback;
}

/**
 * @public
 *
 * 값이 참인지 거짓인지를 표시하는 렌더러
 *
 * @remarks
 * 셀의 값을 `true`/`false` 두 가지 상태로 표시하는 렌더러이다.
 *
 * 컬럼에 연결된 필드의 자료형이 `Boolean`이 아니라면, 렌더러의 `trueValues` 에 지정된 값들을 `true`로, `falseValues` 로 지정된 값들을 `false`로 판단한다.
 *
 * 자동 높이에서 `TOP_EDGE`, `BOTTOM_EDGE`를 사용할 수 없다.
 *
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'check';
 *
 * // object type
 * column.renderer = {
 *      "type": "check",
 *      "trueValues": "France,Germany",
 *      "falseValues": "Korea,England"
 * }
 * ```
 */
export declare interface CheckCellRenderer extends CellRenderer {
    /**
     * 렌더링 시 체크 값을 결정하는 콜백
     *
     * @remarks
     * `true` 반환 시 체크 값을 `false`로 간주한다.
     *
     * 지정하지 않은 경우나, `undefined` 반환 시 체크 값을 `true`로 간주한다.
     *
     * `false` 반환시 `threeStates` 가 `true` 일 경우 체크값을 `undefined`로, 아닐 경우 `true` 로 간주한다.
     *
     * `setCheckedCallback` 가 지정되어 있지 않아야 반환값이 체크 값에 영향을 미친다.
     *
     * {@link GetCheckedCallback} 의 형식을 따른다.
     * @eventProperty
     *
     * @example
     * ```js
     * const f = function(grid, itemIndex, column, value) {
     *      if (typeof value === "number") {
     *          return value % 2 === 1;
     *      }
     *      else if (typeof value ==="boolean") {
     *          return value;
     *      }
     *      else {
     *          return Boolean(v);
     *      }
     * }
     *
     * column.renderer = {
     *          "type": "check",
     *          "getCheckedCallback": f
     * }
     * ```
     */
    getCheckedCallback?: GetCheckedCallback;
    /**
     * 편집 시 체크 결과 값을 결정하는 콜백
     *
     * @remarks
     * 편집 시 `getCheckedCallback` 보다 우선하여 체크 값을 지정한다.
     *
     * {@link SetCheckedCallback} 의 형식을 따른다.
     *
     * @eventProperty
     * @example
     * ```js
     * const f = function(grid, itemIndex, column, oldValue, checked) {
     *      if (itemIndex % 2 === 0) {
     *          return checked;
     *      }
     *      else {
     *          return false;
     *      }
     * }
     * column.renderer = {
     *     "type": "check",
     *     "setCheckedCallback": f
     * }
     * ```
     */
    setCheckedCallback?: SetCheckedCallback;
    /**
     * boolean 자료형이 아닌 필드에서 `true` 로 간주할 값들
     *
     * @remarks
     * 콤마(,)로 구분하여 입력한다.
     *
     * @example
     * ```js
     * column.renderer = {
     *     "type": "check",
     *     "trueValues": "France,Germany"
     * }
     * ```
     */
    trueValues?: string;
    /**
     * boolean 자료형이 아닌 필드에서 `false` 로 간주할 값들
     *
     * @remarks
     * 콤마(,)로 구분하여 입력한다.
     *
     * @example
     * ```js
     * column.renderer = {
     *     "type": "check",
     *     "falseValues": "Korea,England"
     * }
     * ```
     */
    falseValues?: string;
    /**
     * boolean 자료형과 `trueValues` 나 `falseValues` 에 속하는 값이 없을 경우 intermediate 상태로 표시 할 것인지의 여부
     *
     * @remarks
     * `threeStates` 가 `true`며, 값이 `trueValues`, `falseValues` 에 포함되지 않는 경우 intermediate 상태로 표시된다.
     *
     * @defaultValue `false`
     */
    strictValue?: boolean;
    /**
     * intermediate 상태를 포함할 건지의 여부
     *
     * @remarks
     * `strictValue` 와 같이 쓰이거나, 값이 `''`, `undefined`, 또는 `null` 이면 intermediate 상태로 간주한다.
     *
     * @defaultValue `false`
     */
    threeStates?: boolean;
    /**
     * 스페이스 바로 체크를 가능하게 할 것인지의 여부
     *
     * @defaultValue `true`
     */
    spaceKey?: boolean;
    /**
     * 체크박스의 위치
     *
     * @defaultValue {@link IconLocation.CENTER}
     */
    checkLocation?: IconLocation;
    /**
     * 체크박스 대신에 이미지를 사용할 것인지의 여부
     *
     * @remarks
     * 각 css 클래스에 이미지를 지정하면 된다.
     *
     * [css 스타일 명 목록]
     *
     * 체크 `true` 스타일 명:  "rg-check-renderer-checked"
     *
     * 체크 `false` 스타일 명:  "rg-check-renderer-unchecked"
     *
     * `intermediate` 스타일 명:  "rg-check-renderer-intermediate"
     *
     * @defaultValue `false`
     */
    useImages?: boolean;
    /**
     * 체크 표시랑 별개로 편집기로 수정 가능한지의 여부
     *
     * @defaultValue `true`
     */
    editable?: boolean;
    /**
     * 선택 시 표시되는 내부 focus 표시 여부
     *
     * @defaultValue `false`
     */
    showInnerFocus?: boolean;
    /**
     * editable이 false인 경우 disabled로 표시할지 여부
     *
     * @defaultValue `false`
     */
    readOnlySetDisabled?: boolean;
}

/**
 * @public
 *
 * 클릭한 아이템의 정보 모델
 *
 * @remarks
 * {@link GridBase.onMenuItemClicked} 이나 {@link GridBase.onCellClicked} 등 클릭 관련 콜백에서 사용하는 아이템의 정보 모델이다.
 *
 * @example
 * ```js
 * gridView.onMenuItemClicked =  function (grid, item, clickData) {
 *      console.log(item.label + "was clicked.");
 *      console.log("cellType is: " + clickData.cellType);
 * };
 * ```
 */
export declare interface ClickData {
    /**
     * 클릭한 셀의 종류
     */
    cellType?: GridCellType;
    /**
     * 클릭한 대상의 서브 타입
     */
    subType?: GridCellType;
    /**
     * 클릭한 대상의 필드
     */
    field?: number;
    /**
     * 클릭한 대상이 위치한 순서
     */
    itemIndex?: number;
    /**
     * 클릭한 셀의 컬럼
     */
    column?: string;
    /**
     * 클릭한 셀의 인덱스
     *
     * @remarks
     * footer, summary 등의 인덱스이다.
     */
    index?: number;
    /**
     * 클릭한 셀의 그룹 레벨
     */
    groupLevel?: number;
}

/**
 * @public
 *
 * Code128 Barcode를 표시하는 렌더러
 *
 * @remarks
 * 셀의 값으로 Code128 바코드를 생성한다.
 *
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'code128';
 *
 * // object type
 * let column.renderer = {
 *      "type": "code128",
 *      "barStyle": "custom-code128-renderer-bar"
 * }
 * ```
 */
export declare interface Code128CellRenderer extends CellRenderer {
    /**
     * 바코드의 바 클래스 스타일 명
     * @defaultValue `'rg-code128-renderer-bar'`
     */
    barStyle?: string;
}

/**
 * @public
 *
 * Code39 Barcode를 표시하는 렌더러
 *
 * @remarks
 * 셀의 값으로 Code39 바코드를 생성한다.
 *
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'code39';
 *
 * // object type
 * let column.renderer = {
 *     "type": "code39",
 *     "barStyle": "custom-code39-renderer-bar"
 * }
 * ```
 */
export declare interface Code39CellRenderer extends CellRenderer {
    /**
     * 바코드의 바 클래스 스타일 명
     * @defaultValue `'rg-code39-renderer-bar'`
     */
    barStyle?: string;
}

/**
 * 컬럼 필터링에 관련된 설정 정보
 *
 * @remarks
 * {@link GridBase.onFilteringChanged} 나 {@link GridBase.getColumnFilter} 같은 필터 관련 메소드에서 사용된다.
 *
 * {@link GridBase.setColumnFilters} 같이 설정을 위한 형식일 때에는, 원하는 정보만 넣으면 된다.
 */
export declare interface ColumnFilter {
    /**
     * 이름
     */
    name: string;
    /**
     * 표현식
     */
    criteria: string;
    /**
     * 필터를 결정하는 콜백
     *
     * @remarks
     * `true`: 필터링 대상일 때, `false`: 필터링 제외 대상일 때
     * @eventProperty
     */
    callback?: FilterCallback;
    /**
     * 필터 선택 상자에 표시되는 문자열
     *
     * @remarks
     * `null`이면 `name`이 표시된다.
     */
    text?: string;
    /**
     * 설명
     */
    description?: string;
    /**
     * 필터활성화 여부
     */
    active?: boolean;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * 태그
     */
    tag?: string;
}

/**
 * {@link ColumnFilter} 의 콜렉션 모델
 */
export declare interface ColumnFilterCollection {
    /**
     * 컬럼에 등록된 필터의 갯수
     * @readonly
     */
    count: number;
    /**
     * 컬럼에 등록 된 활성화된 필터의 갯수
     * @readonly
     */
    activeCount: number;
    /**
     * 컬럼에 등록 된 {@link ColumnFilter | 필터} 배열
     */
    items: ColumnFilter[];
    /**
     * 컬럼에 등록된 필터들의 표시 여부
     */
    isVisible: boolean;
}

/**
 * @public
 * 그리드 푸터 영역에 표시되는 컬럼 푸터에 대한 설정 정보
 *
 * @remarks
 * {@link GridColumn.footer} 에서 사용한다.
 *
 * [상위 클래스]
 *
 * {@link ColumnObject} - {@link ColumnSummary}
 *
 * @example
 * ```js
 * let col = grid.columnByName('col1')
 * col.footer.styleName = 'custom-footer';
 * ```
 */
export declare interface ColumnFooter extends ColumnSummary {
}

/**
 * @public
 * {@link ColumnFooter} 의 컬렉션
 */
export declare interface ColumnFooterCollection {
    /**
     * footer 개수
     * @readonly
     */
    readonly count?: number;
    /**
     * ColumnFooter를 가져온다.
     *
     * @param index - footer의 순번
     */
    get?(index: number): ColumnFooter;
}

/**
 * @public
 * 그리드 헤더 영역에 표시되는 컬럼 헤더에 대한 설정 정보 모델
 *
 * @remarks
 * {@link GridColumn.header} 에서 사용한다.
 *
 * [상위 클래스]
 *
 * {@link ColumnObject}
 *
 * @example
 * ```js
 * let col = grid.columnByName('col1')
 * col.header.checkLocation = 'leftEdge';
 * ```
 */
export declare interface ColumnHeader extends ColumnObject {
    /**
     * 컬럼 헤더에 표시될 문자열
     *
     * @remarks
     * 이 값이 `null` 이면 컬럼에 연결된 데이터필드 이름을 표시한다.
     * 데이터필드가 연결되지 않았다면 컬럼의 이름을 표시한다.
     *
     * @defaultValue null
     */
    text?: string;
    /**
     * 이미지나 체크박스와 셀 경계와의 공백
     */
    itemOffset?: number;
    /**
     * 헤더 문자열과 이미지나 체크박스와의 간격
     */
    itemGap?: number;
    /**
     * 헤더 문자열을 기준으로한 체크박스의 위치
     *
     * @defaultValue {@link ColumnHeaderItemLocation.NONE}
     */
    checkLocation?: ColumnHeaderItemLocation;
    /**
     * 툴팁 표시 여부
     *
     * @remarks
     *
     * grid.header.showTooltip이 `undefined`이면 column.header.showTooltip이 `true`인 컬럼만 tooltip을 표시한다.
     * grid.header.showTooltip이 `true`이면 column.header.showTooltip이 `undefined`이거나 `true`인 컬럼의 tooltip을 표시한다.
     * grid.header.showTooltip이 `false`인경우 표시되지 않는다.
     *
     * @defaultValue `undefined`
     */
    showTooltip?: boolean;
    /**
     * 표시할 툴팁 메시지
     *
     * @remarks
     * 지정되지 않으면 text를 표시한다.
     *
     * @defaultValue `undefined`
     */
    tooltip?: string;
    /**
     * 스타일 클래스 이름
     */
    styleName?: string;
    /**
     * excel로 export될때 적용될 스타일 명
     */
    exportStyleName?: string;
    /**
     * {@link ColumnObject.template}에 특정 문자열을 교체해서 표시할때 사용
     *
     * * @remarks
     * `values`에 없는 문자열인 경우 호출된다.
     */
    templateCallback?: RealizeHeaderCallback;
}

/**
 * @public
 *
 * 컬럼 헤더의 이미지나 체크 박스의 위치 유형
 *
 * @remarks
 * {@link ColumnHeader.checkLocation} 에서 사용된다.
 *
 * @example
 * ```js
 * let col = grid.columnByName('col1')
 * col.header.checkLocation = 'leftEdge';
 * ```
 */
export declare enum ColumnHeaderItemLocation {
    /**
     * 없음
     */
    NONE = "none",
    /**
     * 왼쪽 모서리
     */
    LEFT_EDGE = "leftEdge",
    /**
     * 오른쪽 모서리
     */
    RIGHT_EDGE = "rightEdge",
    /**
     * 위쪽 모서리
     */
    TOP_EDGE = "topEdge",
    /**
     * 아래쪽 모서리
     */
    BOTTOM_EDGE = "bottomEdge",
    /**
     * 왼쪽
     */
    LEFT = "left",
    /**
     * 오른쪽
     */
    RIGHT = "right",
    /**
     * 위쪽
     */
    TOP = "top",
    /**
     * 아래쪽
     */
    BOTTOM = "bottom",
    /**
     * 가운데
     */
    CENTER = "center"
}

/**
 * @public
 * 그리드 헤더 영역에 표시되는 ColumnSummary 의 설정 정보
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link ColumnObject} - {@link ColumnSummary}
 */
export declare interface ColumnHeaderSummary extends ColumnSummary {
}

/**
 * @public
 * {@link ColumnHeaderSummary}의 컬렉션
 */
export declare interface ColumnHeaderSummaryCollection {
    /**
     * 해당 컬럼
     */
    column?: GridColumn;
    /**
     * Summary 개수
     *
     * @readonly
     */
    count?: number;
    /**
     * ColumnHeaderSummary를 가져온다.
     * @param index - ColumnHeaderSummary의 순번
     */
    get(index: number): ColumnHeaderSummary;
}

/**
 * Cell Layout 설정 시 배치 방향
 *
 * @remarks
 * {@link CellLayoutGroupItem.direction} 에서 사용된다.
 */
export declare enum ColumnLayoutDirection {
    /**
     * 수직적으로 배치
     */
    VERTICAL = "vertical",
    /**
     * 수평적으로 배치
     */
    HORIZONTAL = "horizontal"
}

/**
 * @public
 * 설정된 레이아웃이 {@link CellLayoutColumnItem} 모델일 경우, {@link GridBase.saveColumnLayout} 에서 반환되는 오브젝트
 *
 * @remarks
 * {@link LayoutInfo} 의 한 종류이다.
 *
 * @example
 * ```js
 * {
 *      column: "OrderID",
 *      visible: true,
 *      width: 80
 * }
 * ```
 */
export declare interface ColumnLayoutInfo {
    /**
     * 컬럼명
     */
    column: string;
    /**
     * 표시여부
     */
    visible: boolean;
    /**
     * 컬럼 너비
     */
    width: number;
}

/**
 * @public
 * 컬럼 관련 클래스들의 기반 클래스
 *
 * @remarks
 * ColumnObject 의 모든 속성은 이를 상속한 {@link ColumnHeader} 등에서만 호출할 수 있다.
 *
 * [하위 클래스]
 *
 * {@link ColumnHeader}
 *
 * {@link ColumnSummary}
 *
 * - {@link ColumnFooter}
 *
 * - {@link ColumnHeaderSummary}
 *
 * @warning ColumnObject 로 직접 설정하거나 호출할 수 없다.
 */
export declare interface ColumnObject {
    /**
     * ColumnObject의  컬럼
     */
    column?: GridColumn;
    /**
     * 적용되어 표시될 html 템플릿
     *
     * @remarks
     * {@link TemplateCellRenderer} 의 설명을 참고
     */
    template?: string;
    /**
     * template에서 사용되는 값들
     */
    values?: any;
    /**
     * 팝업 메뉴
     *
     * @remarks
     * `gridView`에 팝업메뉴를 등록하지 않고 ColumnObject에 바로 popupMenu를 등록할때 사용한다.
     */
    popupMenu?: ConfigObject[];
    /**
     * 팝업 메뉴의 이름
     *
     * @remarks
     * `gridView`에 등록한 팝업메뉴이름을 지정한다. {@link GridBase.addPopupMenu} 참조
     */
    popupMenuName?: string;
}

/**
 * @public
 * `dataType`이 `object`인 data를 화면에 표시할때 사용되는 콜백
 *
 * @remarks
 * [매개변수 목록]
 *
 * `fieldName` - field명
 *
 * `dataRow` - dataRow
 *
 * `value` - value
 *
 * [반환값] - 화면에 표시할 내용
 *
 * @example
 *
 * ```js
 * const callback = function(fieldName, dataRow, value) {
 *   return JSON.stringify(value);
 * }
 *
 * gridView.columnByName("objectColumn").objectCallback = callback;
 * ```
 */
export declare type ColumnObjectCallback = (fieldName: string, dataRow: number, value: any) => any;

/**
 * {@link CellStyleCallback} 으로 셀 스타일 변경 시 반환해야 하는 스타일 모델 중 하나
 *
 * @remarks
 * {@link GridBase.setCellStyleCallback} 또는 {@link ValueColumn.styleCallback} 에서 사용된다.
 *
 * @example
 * ```js
 * // column 별 적용
 * let column = gridView.columnByName('Company');
 *
 * const f = function (grid, cell) {
 *      return {
 *          styleName: 'custom-column'
 *      }
 * }
 * column.styleCallback = f;
 *
 * // data cell 별 적용
 * gridView.setCellStyleCallback(f);
 * ```
 */
export declare interface ColumnStyleObject {
    /**
     * 스타일 명
     */
    styleName?: string;
    /**
     * excel로 export될때 적용될 스타일 명
     */
    exportStyleName?: string;
    /**
     * 렌더러
     */
    renderer?: CellRenderer | ConfigObject;
    /**
     * 편집기로 수정 가능 여부
     */
    editable?: boolean;
    /**
     * 수정 가능 금지 여부
     */
    readOnly?: boolean;
    /**
     * 에디터
     */
    editor?: CellEditor | ConfigObject;
    /**
     * 텍스트 형식의 값일 때 서식
     */
    textFormat?: string;
    /**
     * 날짜 형식의 값일 때 서식
     */
    datetimeFormat?: string;
    /**
     * 숫자 형식의 값일 때 서식
     */
    numberFormat?: string;
    /**
     * Boolean 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 boolean 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * 지정되지 않은 경우 데이터필드에 설정된 값을 사용한다.
     *
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
    /**
     * 값의 앞쪽에 덧붙여 표시할 텍스트
     */
    prefix?: string;
    /**
     * 값의 뒤쪽에 덧붙여 표시할 텍스트
     */
    suffix?: string;
    /**
     * 엑셀로 export할때 format을 지정한다.
     *
     * @remarks
     * 지정하지 않으면 {@link DataColumn.excelFormat} 또는 dataType에 따른 format이 적용된다.
     */
    excelFormat?: string;
    /**
     * 엑셀로 export할때 셀 잠금 또는 수식 숨기기를 설정한다.
     *
     * @remarks
     * 지정하지 않으면 {@link DataColumn.cellProtectProps}가 적용된다.
     * {@link GridExportOptions.sheetProtect}와 함께 사용한다.
     */
    cellProtectProps?: CellProtectProperties;
}

/**
 * @public
 * {@link ColumnFooter}, {@link ColumnHeaderSummary} 등의 기반 클래스
 *
 * @remarks
 * ColumnSummary 의 모든 속성은 이를 상속한 하위 클래스들에서만 호출할 수 있다.
 *
 * [상위 클래스]
 *
 * {@link ColumnObject}
 *
 * [하위 클래스]
 *
 * {@link ColumnFooter}
 *
 * {@link ColumnHeaderSummary}
 *
 * @warning ColumnSummary 로 직접 설정하거나 호출할 수 없다.
 */
export declare interface ColumnSummary extends ColumnObject {
    /**
     * summary의 순번
     *
     * @remarks
     * {@link GridColumn.footer} 또는 {@link GridColumn.headerSummary}가 여러개인 경우 순번.
     */
    summaryIndex?: number;
    /**
     * @deprecated
     * summaryIndex로 대체
     */
    index?: number;
    /**
     * 화면에 표시되는 값을 사용자가 지정할때 사용하는 콜백
     *
     * @eventProperty
     *
     * @remarks
     * valueCallback이 지정되면 text/expression은 무시된다.
     */
    valueCallback?: ColumnSummaryCallback;
    /**
     * 화면에 표시되는 텍스트
     *
     * @remarks
     * text가 지정되면 expression은 무시된다.
     */
    text?: string;
    /**
     * 표현식
     *
     */
    expression?: string;
    /**
     * 스타일 클래스 명
     */
    styleName?: string;
    /**
     * excel로 export할때 적용될 스타일 명
     */
    exportStyleName?: string;
    /**
     * 스타일을 지정하기 위한 콜백
     *
     * @remarks
     * {@link CellStyleCallback} 참조
     *
     * @eventProperty
     */
    styleCallback?: CellStyleCallback;
    /**
     * 숫자 형식의 값일 때 표시되는 서식
     */
    numberFormat?: string;
    /**
     * 날짜 형식의 값일 때 표시되는 서식
     *
     */
    datetimeFormat?: string;
    /**
     * Boolean 형식의 값일 때 표시되는 서식
     *
     * @remarks
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
    /**
     * 텍스트 형식의 값일 때 변환 서식
     *
     * @remarks
     * 세미콜론(;)으로 구분하여 왼쪽에는 String.prototype.replace의 첫 번째 매개변수, 오른쪽에는 두 번째 매개변수와 같은 타입으로 지정
     * 예) `'([A-Za-z]*); Mr\. \$1'`
     *
     */
    textFormat?: string;
    /**
     * 앞에 추가 될 텍스트
     */
    prefix?: string;
    /**
     * 뒤에 추가 될 텍스트
     */
    suffix?: string;
    /**
     * {@link ColumnObject.template}에 특정 문자열을 교체해서 표시할때 사용
     *
     * @remarks
     * `values`에 없는 문자열인 경우 호출된다.
     */
    templateCallback: RealizeSummaryCallback;
}

/**
 * @public
 * 컬럼의 footer 또는 summary에 표시되는 값을 사용자가 지정할때 사용되는 콜백의 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `grid` - gridView
 *
 * `column` - footer 또는 summary의 컬럼
 *
 * `footerIndex` - column의 footer가 여러개인경우 순번
 *
 * `summary` - footer 또는 summary객체 groupFooter인 경우 GroupItem객체
 *
 * `value` - expression이 지정된 경우 값
 *
 * [반환값] - 화면에 표시될 내용.
 */
export declare type ColumnSummaryCallback = (grid: GridBase, column: DataColumn, footerIndex: number, summary: ColumnSummary | GroupItem, value: any) => any;

/**
 * {@link CellStyleCallback} 으로 셀 스타일 변경 시 반환해야하는 스타일 모델 중 하나
 *
 * @remarks
 * {@link GridFooter.cellStyleCallback}, {@link HeaderSummary.cellStyleCallback} 에서 사용된다.
 *
 * @example
 * ```js
 * // 푸터 적용
 * const f = function (grid, cell) {
 *      return {
 *          styleName: 'custom-footer'
 *      }
 * }
 * footer.cellStyleCallback = f;
 *
 * const f2 = function (grid, cell) {
 *      return {
 *          styleName: 'custom-summary'
 *      }
 * }
 *
 * headerSummary.cellStyleCallback = f2;
 * ```
 */
export declare interface ColumnSummaryStyleObject {
    /**
     * 스타일 명
     */
    styleName?: string;
    /**
     * excel로 export할때 적용될 스타일 명
     */
    exportStyleName?: string;
    /**
     * 텍스트 형식의 값일 때 서식
     */
    textFormat?: string;
    /**
     * 날짜 형식의 값일 때 서식
     */
    datetimeFormat?: string;
    /**
     * 숫자 형식의 값일 때 서식
     */
    numberFormat?: string;
    /**
     * Boolean 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 boolean 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * 지정되지 않은 경우 데이터필드에 설정된 값을 사용한다.
     *
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
    /**
     * 값의 앞쪽에 덧붙여 표시할 텍스트
     */
    prefix?: string;
    /**
     * 값의 뒤쪽에 덧붙여 표시할 텍스트
     */
    suffix?: string;
}

/**
 * 검색할 때 사용자 임의로 조건을 지정하기 위한 값 비교 콜백 형식
 *
 * @remarks
 *
 * [매개변수 목록]
 *
 * `v1` - 검색되어지는 값
 *
 * `v2` - 검색한 값
 *
 * `sensitive` - 대소문자 구분 여부
 *
 * `partialMatch` - 포함되는 글자도 검색하는지 여부
 *
 * [반환값] - 해당 값 매칭 여부
 *
 * @example
 * ```js
 * const f = function(v1, v2, sensitive, partialMatch) {
 *      if (v1 === v2) {
 *           return true;
 *      }
 *      let s1 = String(v1);
 *      let s2 = v2 == null ? undefined : String(v2);
 *      if (!s1 && !s2) {
 *           return true;
 *      }
 *      if (!s1 || !s2) {
 *           return false;
 *      }
 *      if (!caseSensitive) {
 *           s1 = s1.toLowerCase();
 *           s2 = s2.toLowerCase();
 *      }
 *      if (partialMatch) {
 *      	    return s2.indexOf(s1) >= 0;
 *      } else {
 *      	    return s1 == s2;
 *      }
 * }
 * ```
 *
 */
export declare type CompareCallback = (v1: string, v2: string, sensitive: boolean, partialMatch: boolean, dataRow: number, fieldName: string) => boolean;

/**
 * @public
 * 비교함수 형식
 *
 * @remarks
 * Array.prototype.sort() 에서 쓰는 CompareFunction 과 같은 형식이다.
 *
 * {@link DataProviderBase.setDataComparer} 에서 사용한다.
 */
export declare type CompareFunction = (field: number, row1: any, row2: any) => number;

export declare type ConfigObject = {
    [key: string]: any;
};

/**
 * 그리드의 내용을 클립보드를 복사하는 것에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setCopyOptions({enabled: false});
 * ```
 */
export declare interface CopyOptions {
    /**
     * 복사 가능 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
    /**
     * 선택 영역과 상관없이 focus 된 셀 하나만 복사할 것인지에 대한 여부
     *
     * @defaultValue `false`
     */
    singleMode?: boolean;
    /**
     * 보여지는 text 로 복사할 것인지의 여부
     *
     * @remarks
     * `true` 시 number, date, dropdown, multicheck 의 경우 보여지는 Text로 복사한다.
     *
     * @defaultValue `false`
     */
    copyDisplayText?: boolean;
    /**
     * 헤더의 text 를 포함하여 복사할 것인지의 여부
     *
     * @remarks
     * ex) OrderID 10233
     *
     * @defaultValue `false`
     */
    includeHeaderText?: boolean;
    /**
     * lookupDisplay가 true인 컬럼의 text복사
     *
     * @remarks
     * `true`시 lookupDisplay가 true인 컬럼은 value가 아닌 label 또는 labelField의 값을 복사
     *
     * @defaultValue `false`
     */
    lookupDisplay?: boolean;
    /**
     * boolean 형식의 값일 때 변환 서식
     *
     * @remarks
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'N:Y'`
     */
    booleanFormat?: string;
    /**
     * 날짜 형식의 값일 때 변환 서식
     *
     * @remarks
     * 예) `'yyyy-MM-dd'`
     *
     */
    datetimeFormat?: string;
    /**
     * 클립보드에 복사될 text를 결정하는 콜백
     *
     * @remarks
     * 셀이 복사될때 호출된다.
     *
     * 지정되지 않거나 `undefined`를 return하면 value또는 다른 설정값이 적용된다.
     *
     * {@link CopyTextCallback}의 형식이다.
     * @eventProperty
     */
    copyTextCallback?: CopyTextCallback;
}

/**
 * 그리드를 복사할때 클립보드에 저장되는 text를 반환하는 콜백 형식
 *
 * @remarks
 * {@link CopyOptions.copyTextCallback}에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `itemIndex` - 복사되는 행의 itemIndex
 *
 * `column` - {@link DataColumn} 객체
 *
 * [반환값] - 클립보드에 복사될 text `undefined` 를 return 하면 value 또는 copyOptions의 다른 설정값에 따른 text가 복사된다.
 *
 * ```js
 * const f = function(grid, itemIndex, column, value) {
 *      if (value != null && column.name === "number1") {
 *          return value + "";
 *      }
 * }
 * grid.copyOptions.copyTextCallback = f;
 * ```
 */
export declare type CopyTextCallback = (grid: GridBase, itemIndex: number, column: ValueColumn, value: any) => string;

/**
 * @public
 *
 * 특정 그룹 푸터의 표시 여부를 지정하기 위한 콜백 형식
 *
 * @remarks
 * {@link RowGroup.createFooterCallback} 에서 사용되는 형식이다.
 *
 * [매개변수 목록]
 *
 * `owner` - GridBase 컨트롤
 *
 * `group` - 그룹 아이템
 *
 * `footerIndex` - 푸터 콜렉션 내에서의 인덱스
 *
 * @example
 * ```js
 * createFooterCallback: function(owner, group, footerIndex) {
 * 		if (group.level >= 5) { return false }
 * 		if (group.level === 4) {
 * 			let relation2 = owner.getDataSource().getValue(group.firstItem.dataRow, "relation2");
 * 			return relation2 === "친족"
 * 		}
 * 		if (group.level === 3) {
 * 			let relation1 = owner.getDataSource().getValue(group.firstItem.dataRow, "relation1");
 * 			return relation1 === "동일인측"
 * 		}
 * 		return true;
 * 	}
 * ```
 */
export declare type CreateFooterCallback = (owner: GridView, group: GroupItem, footerIndex: number) => boolean;

/**
 * @public
 *
 * 사용자 지정 셀 렌더러를 설정할 때 사용하는 오브젝트
 *
 * @remarks
 * {@link GridBase.registerCustomRenderer} 로 사용 가능하다.
 *
 * @example
 * ```js
 * gridView.registerCustomRenderer("renderer01", {
 *     initContent(parent) {
 *         var span = this._span = document.createElement("span");
 *         parent.append(span);
 *     },
 *     ...
 * }
 * ```
 */
export declare interface CustomCellRenderer {
    /**
     * 내용 초기화 시에 실행 될 콜백
     * @eventProperty
     *
     * [매개변수 목록]
     *
     * `dom` - parent element
     *
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      initContent: function(dom) {
     *          let span = this._span = document.createElement("span");
     *          span.className = "custom_render_span"
     *          dom.appendChild(span);
     *
     *          dom.appendChild(this._button1 = document.createElement("span"));
     *          dom.appendChild(this._button2 = document.createElement("span"));
     *
     *          let a = this._href = document.createElement("a");
     *          a.href = "http://realgrid.com";
     *          a.target = "_blank";
     *          a.tabIndex = -1;
     *          a.textContent = "real";
     *          dom.appendChild(a);
     *      }
     * }
     * ```
     */
    initContent?: (dom: HTMLElement) => void;
    /**
     * 내용 초기화 시에 실행 될 콜백
     *
     * @remarks
     * {@link GridBase.destroy | grid.destroy} 를 실행했을때 호출되는 method 이다.
     *
     * 메모리 누수를 방지하기 위해서 {@link CustomCellRenderer.initContent | initContent} 에서 생성되거나 참조하는 객체들을 모두 해제해 주어야 한다.
     *
     * `addEventListener` 또는 `onclick`등으로 연결한 이벤트가 있는 경우 반드시 해제를 해주어야 한다
     *
     * [매개변수 목록]
     *
     * `dom` - parent element
     *
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      clearContent: function(dom) {
     *          dom.innerHTML = "";
     *      }
     * }
     * ```
     */
    clearContent?: (dom: HTMLElement) => void;
    /**
     * 렌더링 시에 실행 될 콜백
     *
     * @remarks
     * element 내의 text 나 style 을 적용 시킬 수 있다.
     *
     * [매개변수 목록]
     *
     * `grid` - {@link GridBase} 컨트롤
     *
     * `model` - GridCell 객체
     *
     * `w` - 폭
     *
     * `h` - 너비
     *
     * `info` - 추가정보
     *
     * @eventProperty
     *
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      render: function(grid, model, w, h, info) {
     *           let span = this._span;
     *
     *           // text설정.
     *           span.textContent = model.value + "-YYY";
     *           this._value = model.value;
     *
     *           // className 또는 style에 직접설정
     *           // style에 직접설정하는 경우 className을 이용하는것보다 속도가 느려질수 있다.
     *           // 가능하다면 className을 이용한다.
     *           this._button1.className = "custom_none";
     *           this._button2.className = "custom_none";
     *
     *           switch(model.value) {
     *               case "Germany":
     *                   this._button1.className = "custom_search custom-hover";
     *                   this._button2.className = "custom_de custom-hover";
     *                   break;
     *               case "France":
     *                   this._button1.className = "custom_fr custom-hover";
     *                   break;
     *               case "Brazil":
     *                   this._button1.className = "custom_br custom-hover";
     *                   break;
     *           }
     *      }
     * }
     * ```
     */
    render?: (grid: any, model: GridCell, w: number, h: number, info: any) => void;
    /**
     * 그리드의 클릭 이벤트를 사용할지 결정하기 위한 콜백
     *
     * @remarks
     * `false` 를 반환하면 그리드는 더 이상 이벤트를 처리하지 않고, element 의 기본동작이 실행된다.
     *
     * 해당 콜백을 등록하지 않는 경우 `false` 를 반환한다.
     *
     * {@link CustomCellRenderer.click} 을 사용하기 위해서는 `true`를 반환하는 함수로 설정해야 한다.
     *
     * [매개변수 목록]
     *
     * `event` - 마우스 클릭 이벤트
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      canClick : function() {
     *          return true;
     *      }
     * }
     * ```
     */
    canClick?: (event: MouseEvent) => boolean;
    /**
     * 클릭 시에 실행 될 콜백
     *
     * @remarks
     * element 의 click event 와는 별개로 처리된다.
     *
     * `event.target`이 클릭 가능하면 {@link ClickData} 를 반환해야 한다.
     *
     * 반환 된 데이터는 {@link GridBase.onCellItemClicked} 이벤트로 전달된다.
     *
     * `false` 반환 시 해당 이벤트를 중지시킨 후 {@link CustomCellRenderer.preventClick | preventClick} 을 호출한다.
     *
     * [매개변수 목록]
     *
     * `event` - 마우스 클릭 이벤트
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      click: function(event) {
     *          let index = this.index.toProxy();
     *          if ( event.target === this._button1 ||  event.target === this._button2 || event.target === this._href) {
     *              return {
     *                  cellType:"data",
     *                  target : event.target,
     *                  index: index,
     *                  value: this._value
     *              }
     *          }
     *      }
     * }
     * ```
     */
    click?: (event: MouseEvent) => any;
    /**
     * 클릭을 중지시키기 위한 콜백
     *
     * @remarks
     * `event.preventDefault()` 를 자유롭게 호출하기 위해 만들어졌다.
     *
     * 해당 콜백을 지정하지 않으면, {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault | Event.preventDefault} 가 호출한다.
     *
     * [매개변수 목록]
     *
     * `event` - 마우스 클릭 이벤트
     * @eventProperty
     */
    preventClick?: (event: MouseEvent) => void;
    /**
     * 편집 가능한 렌더러인지의 여부
     *
     * @remarks
     * [매개변수 목록]
     *
     * `event` - 마우스 이벤트
     *
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      canEdit: function() {
     *          return true;
     *      }
     * }
     * ```
     */
    canEdit?: (event: MouseEvent) => boolean;
    /**
     * 편집 완료 행위를 결정하는 콜백
     *
     * @remarks
     * `false` 반환 시 {@link CustomCellRenderer.preventEditClick} 을 호출한다.
     *
     * [매개변수 목록]
     *
     * `index` - 편집
     *
     * `event` - 마우스 이벤트
     *
     * `result` - 편집 완료 결과
     * @eventProperty
     */
    editClick?: (index: CellIndex, event: MouseEvent, result: RendererEditResult) => boolean;
    /**
     * 편집 시 편집 완료를 중지시키기 위한 콜백
     *
     * @remarks
     * `event.preventDefault()` 를 자유롭게 호출하기 위해 만들어졌다.
     *
     * 해당 콜백을 지정하지 않으면, {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault | Event.preventDefault} 가 호출한다.
     *
     * [매개변수 목록]
     *
     * `event` - 마우스 이벤트
     * @eventProperty
     */
    preventEditClick?: (event: MouseEvent) => void;
    /**
     * 편집 단축키를 지정하는 것을 결정하기 위한 콜백
     *
     * @remarks
     * `false` 를 반환하면 특정 키를 눌렀을 때 편집하는 기능을 반영하지 않는다.
     *
     * [매개변수 목록]
     *
     * `event` - 키보드 이벤트
     *
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      canEditKey: function(event) {
     *          return event.ctrlKey && event.keyCode === 65;
     *      }
     * }
     * ```
     */
    canEditKey?: (event: KeyboardEvent) => boolean;
    /**
     * 설정한 편집 단축키로 편집을 하기 위한 콜백
     *
     * @remarks
     * `false` 반환 시 편집을 취소한다.
     *
     * [매개변수 목록]
     *
     * `index` - 편집
     *
     * `event` - 마우스 이벤트
     *
     * `result` - 편집 완료 결과
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      editKey: function(index, event, result) {
     *          result.commit = false;
     *          if (event.ctrlKey && event.keyCode === 65) {
     *              result.commit = true;
     *              result.value = '가나다라';
     *              return true;
     *          }
     *          return false;
     *      }
     * }
     * ```
     */
    editKey?: (index: CellIndex, event: KeyboardEvent, result: RendererEditResult) => boolean;
}

/**
 * 그리드 Data영역의 셀정보
 *
 */
export declare interface DataCell {
    /**
     *
     * data 변경여부
     *
     * @remarks
     * dataProvider.restoreMode가 "explicit" 또는 "auto"인경우 사용가능.
     */
    isValueChanged?: boolean;
    /**
     * column의 equalBlank가 true인경우 셀의 blankState값
     */
    getBlankState?: BlankState;
}

/**
 * @public
 * {@link ValueColumn} 을 상속한 컬럼 정보 모델
 *
 * @remarks
 * 추가로 정렬, 필터링, 그룹 정보 등이 들어가 있다.
 *
 * [상위 클래스]
 *
 * {@link GridColumn} - {@link ValueColumn}
 */
export declare interface DataColumn extends ValueColumn {
    /**
     * 컬럼에 연결된 데이터 필드의 dataType
     *
     * @readonly
     */
    valueType?: ValueType;
    /**
     * 컬럼이 표시하는 필드의 인덱스
     *
     * @defaultValue `-1`
     */
    fieldIndex?: number;
    /**
     * 컬럼이 표시하는 데이터 필드의 이름
     *
     * @remarks
     * 존재하지 않는 필드 이름을 지정하거나 지정하지 않으면 이 컬럼에 해당하는 셀은 아무것도 표시하지 않는다.
     */
    fieldName?: string;
    /**
     * 편집 가능 여부
     *
     * @remarks
     * 컬럼의 editable이 undefined이면 {@link GridBase.editOptions}의 editable을 따라간다.
     *
     * `true`이면 해당 컬럼은 편집가능하고 `false`이면 그리드 편집기가 활성화 되지 않는다.
     *
     * @defaultValue `undefined`
     */
    editable?: boolean;
    /**
     * readOnly 여부
     *
     * @remarks
     *
     * `false`이면 그리드 편집기는 활성화되지만 편집은 할수 없다.
     *
     * @defaultValue `false`
     */
    readOnly?: boolean;
    /**
     * 값이 `NaN` 일 경우 표시되는 텍스트
     *
     * @remarks
     * dataType 이 숫자인 경우에만 가능
     */
    nanText?: string;
    /**
     * 값이 `0`일 때 표시되는 텍스트
     *
     * @remarks
     * dataType 이 숫자인 경우에만 가능
     */
    zeroText?: string;
    /**
     * 초기값
     *
     * @remarks
     * insert 또는 append시 해당 컬럼의 기본값이다.
     */
    defaultValue?: any;
    /**
     * 각 값을 구분하기 위한 구분자
     *
     * @remarks
     *
     * data가 "value,value" 형태로 되어있는것을 "label,label" 형태로 보여줄때 value를 구분하기 위한 구분자.
     *
     * @defaultValue `,`
     */
    valueSeparator?: string;
    /**
     * 컬럼 머지 규칙
     *
     * @remarks
     * 컬럼에 속한 셀들을 묶어서 표시할 수 있다. 이전 행의 셀과 병합할 것인 지를 판단할 수식을 설정한다.
     * `{criteria: string}`형식은 이전버전과 호환을  위해 사용한다.
     */
    mergeRule?: string | {
        criteria: string;
    };
    /**
     * 빈 셀일 때 머지 중단 여부
     *
     * @defaultValue `false`
     */
    breakMergeOnEmpty?: boolean;
    /**
     * 같은 컬럼의 이전 행의 셀과 값이 동일할때 셀의 묶음 여부
     *
     * @remarks
     *
     * mergeRule과는 다르게 셀을 merge하지 않고 단지 text만 보여주지 않는다.
     *
     * @defaultValue `false`
     *
     */
    equalBlank?: boolean;
    /**
     * {@link DataColumn.equalBlank | equalBlank } 가 `true`인 경우 같은 값으로 처리할 수식
     */
    equalBlankExpression?: string;
    /**
     * 이전행의 값과 동일할때 표시되는 string
     *
     * @defaultValue `""`
     */
    equalBlankText?: string;
    /**
     * 이전행의 값과 동일할때 셀 하단 라인 표시 여부
     *
     * @defaultValue `false`
     */
    equalBlankLine?: boolean;
    /**
     * merge된 셀을 편집했을때 merge된 모든 행을 변경한다.
     *
     * @remarks
     * `true`이면 mergeRule 또는 mergedRowGrouping에 의해서 merge된 셀을 수정한 경우 merge된 행 전체를 수정한다.
     * {@link EditOptions.commitByCell | commitByCell } 이 `true`여야 한다.
     *
     * @defaultValue `false`
     */
    mergeEdit?: boolean;
    /**
     * 엑셀 export 시 출력되는 서식
     *
     * @remarks
     * 예) `excelFormat: "#,##0;[Red]-#,##0;-"`
     */
    excelFormat?: string;
    /**
     * 엑셀 export시 출력되는 수식
     *
     * @remarks
     *
     * 예) `excelFormulaStatement: '${excelcolumn[‘컬럼1’]}${row} + ${excelcolumn[‘컬럼2’]}${row}'`
     */
    excelFormulaStatement?: string;
    /**
     * 엑셀 export시 셀의 잠금 또는 수식 숨기기를 설정한다.
     *
     * @remarks
     * {@link GridExportOptions.sheetProtect}와 함께 사용한다.
     */
    cellProtectProps?: CellProtectProperties;
    /**
     * rowGroup의 group순번.
     *
     * @remarks
     * rowGroup상태일때 컬럼이 참조하는 field의 groupLevel
     *
     */
    groupLevel?: number;
    /**
     * 컬럼 셀에 실제 값의 목록
     *
     * @remarks
     * values 에 셀 값에 해당하는 항목이 없으면 셀 값이 그대로 표시된다.
     *
     * @defaultValue `null`
     */
    values?: string[];
    /**
     * 컬럼 셀에 표시될 값의 목록
     *
     * @remarks
     * values 에 셀 값에 해당하는 항목이 없으면 셀 값이 그대로 표시된다.
     *
     * @defaultValue `null`
     */
    labels?: string[];
    /**
     * 컬럼 셀에 values 목록 중 셀의 값에 해당하는 위치에 있는 labels 항목의 값의 표시 여부
     */
    lookupDisplay?: boolean;
    /**
     * 등록한 lookupSourceTree의 id
     */
    lookupSourceId?: string;
    /**
     * lookupKeyFields
     *
     * @remarks
     * lookupSourceTree를 이용해서 lookup을 표시할때 선행 value를 찾아오기 위한 field의 name들
     *
     */
    lookupKeyFields?: string[];
    /**
     * 컬럼 셀에 표시될 값의 목록을 지정하는 필드
     *
     * @remarks
     * labelField 가 다른 필드로 지정되면, 해당 컬럼 셀에는 실제 값 대신 이 필드의 셀과 같은 행에 있는 labelField 의 값을 표시한다.
     * values, labels 속성보다 labelField 속성이 우선한다.
     */
    labelField?: string;
    /**
     * 셀 데이터가 lookup values 에 없는 경우 표시되는 텍스트
     *
     * @remarks
     * 문자열을 지정하면 해당 문자열이 표시된다.
     */
    textOfInvalid?: string;
    /**
     * 셀 데이터가 없는 경우 표시되는 문자열
     *
     * @remarks
     * 데이터가 없는 경우 해당 문자열이 표시된다.
     */
    placeHolder?: string;
    /**
     * 셀 데이터가 없는 경우 적용되는 class명
     *
     * @defaultValue `rg-data-empty-cell`
     */
    placeHolderStyleName?: string;
    /**
     * 화면에 표시하는 값을 설정하기 위한 콜백
     * @eventProperty
     */
    displayCallback?: any;
    /**
     * 정렬 가능 여부
     *
     * @remarks
     * `false`인경우 컬럼 header를 클릭하여도 정렬되지 않는다.
     * @defaultValue `true`
     */
    sortable?: boolean;
    /**
     * 정렬 순서
     * @readonly
     * @defaultValue `-1`
     */
    sortOrder?: number;
    /**
     * 정렬 방식
     * @readonly
     * @defaultValue `undefined`
     */
    sortDirection?: SortDirection;
    /**
     * Label 기준으로 정렬 여부
     *
     * @defaultValue `false`
     */
    sortByLabel?: boolean;
    /**
     * 필터링 가능 여부
     *
     * @defaultValue `true`
     */
    filterable?: boolean;
    /**
     * 필터 Icon 표시여부
     *
     * @defaultValue `true`
     */
    filterIconVisible?: boolean;
    /**
     * 자동 필터링 적용 여부
     *
     * @defaultValue `false`
     */
    autoFilter?: boolean;
    /**
     * 필터들
     *
     * @remarks
     * 반환할 때는 {@link ColumnFilterCollection} 모델만을 따르지만, 설정할 때는 {@link GridBase.setColumnFilters} 의 매개변수 형식과 동일하다.
     */
    filters?: any | ColumnFilterCollection;
    /**
     * 자동으로 생성된 filter들
     *
     * @remarks
     * autoFilter가 true이면서 filterIcon을 클릭했을때 갱신된다.
     * 또는 {@link GridBase.autoFiltersRefresh}를 이용해서 갱신한다.
     */
    autoFilters?: any | ColumnFilterCollection;
    /**
     * 필터 선택창의 너비
     *
     * @remarks
     *
     * 필터 선택창의 너비를 지정한다.
     */
    filterSelectorWidth?: number;
    /**
     * 필수 여부
     *
     * @defaultValue `false`
     */
    required?: boolean;
    /**
     * 검증 시 값이 요구될 때 발생하는 메시지
     */
    requiredMessage?: string;
    /**
     * 검증 시 값이 요구될 때 표시될 레벨
     *
     * @defaultValue {@link ValidationLevel.ERROR}
     */
    requiredLevel?: ValidationLevel;
    /**
     * 이 컬럼에 적용할 {@link EditValidation} 목록
     * @remarks
     * 반환할 때는 {@link EditValidationCollection} 모델을 따르지만, 설정할 때는 {@link GridBase.setValidations} 의 매개변수 형식과 동일하다.
     */
    validations?: any | EditValidationCollection;
    /**
     * true로 지정하면 사용자가 컬럼 헤더를 마우스로 드래깅해서 그룹핑을 할 수 있다.
     *
     * @defaultValue `true`
     */
    groupable?: boolean;
    /**
     * field의 dataType이 `object`인 경우 화면에 보여주고자하는 `name`
     *
     * @remarks
     * objectKey가 지정되면 해당 `name`은 편집이 가능.
     *
     * @defaultValue `undefined`
     */
    objectKey?: string;
    /**
     * @eventProperty
     * field의 dataType이 `object`인 경우 화면에 표시하는 값을 설정하기 위한 콜백
     *
     */
    objectCallback?: ColumnObjectCallback;
    /**
     * header/export/feedback에 표시되는 text;
     */
    displayText?: string;
    /**
     * values와 labels를 설정한다.
     *
     * @remarks
     * 서버에서 code정보를 map 형태로 가져온후 values와 labels를 설정할때 사용한다.
     *
     * @example
     *
     * ```js
     * var col = grid.columnByName("column");
     * var codeInfo = {
     *   "type": "areacode",
     *   "list": [
     *     {code:"11", text:"서울특별시"},
     *     {code:"21", text:"부산광역시"}
     *   ]
     * }
     * col.lookupData = codeInfo;
     *
     * // 배열로 설정하는 경우.
     * var codeList = [
     *  {code:"11", text:"서울특별시"},
     *  {code:"21", text:"부산광역시"}
     *  ...
     * ];
     * col.lookupData = codeList;
     * ```
     */
    lookupData?: ConfigObject | ConfigObject[];
    /**
     * filters에 등록된 filter를 삭제하고 초기화 한다.
     */
    clearFilters(): void;
    /**
     * filters에 filter를 추가한다.
     *
     * @remarks
     * 컬럼에 filter를 등록한다.
     *
     * @param filters - filter객체 배열
     * @param overwrite - filterName이 존재하는 경우 덮어쓰기한다 defaultValue `false`
     */
    addFilters(filters: (ColumnFilter | ConfigObject) | (ColumnFilter | ConfigObject)[], overwrite?: boolean): void;
    /**
     * filters에서 filter를 제거한다.
     */
    removeFilters(filterNames: string | string[]): void;
    /**
     * filters에서 지정된 filter의 active상태를 변경한다.
     */
    activateFilters(filterNames: string | string[], active: boolean): void;
    /**
     * filters에 등록된 filter의 active상태를 입력된 값으로 변경한다.
     *
     * @param active - boolean
     */
    activateAllFilters(active: boolean): void;
    /**
     * 지정된 filter를 filter Selector에서 보이지 않도록 한다.
     * hide상태여도 filter의 active상태는 그리드에 적용된다.
     *
     * @param filterNames - 숨기거나 보이고자하는 filter의 name 배열
     * @param hide - boolean;
     */
    hideColumnFilters(filterNames: string | string[], hide: boolean): void;
    /**
     * 컬럼의 모든 filter를 숨기거나 표시한다.
     *
     * @param hide - boolean;
     */
    hideAllColumnFilters(hide: boolean): void;
    /**
     * 지정된 filter의 acitve상태를 toggle한다.
     *
     * @param filterNames - active 상태를 변경하려는 filter의 name들
     */
    toggleFilters(filterNames: string | string[]): void;
    /**
     * 컬럼의 모든 filter들의 active상태를 toggle한다.
     */
    toggleAllFilters(): void;
    /**
     * 컬럼 필터객체를 가져온다.
     */
    getFilter(filterName: string): ColumnFilter;
    /**
     * 입력된 active상태에 있는 filte들을 가져온다.
     *
     * @param active - boolean;
     */
    getActiveFilters(active: boolean): ColumnFilter[];
    /**
     * 컬럼에 filter가 있는지 확인한다.
     *
     * @readonly
     */
    hasFilters?: boolean;
    /**
     * 컬럼이 filtering중인지 확인한다.
     *
     * [반환값] boolean
     */
    isFiltered(): boolean;
    /**
     * 컬럼에 filter를 설정한다.
     *
     * @param filters - filter 설정 정보 배열
     * @example
     *
     * ```js
     * var col = gridView.columnByName("areacode");
     * var filters = [{
     *   name:"서울",
     *   criteria:"value = '11'",
     *   active: true
     * }, {
     *   name:"부산",
     *   criteria:"value = '21'",
     *   text:"부산광역시",
     *   active: false
     * }];
     * col.setFilters(filters);
     * ```
     */
    setFilters(filters: (ColumnFilter | ConfigObject)[]): void;
    /**
     * autoFilter가 true일때 filter정보를 갱신한다.
     */
    autoFilterRefresh(applyFilters: boolean): void;
    /**
     * filterPanel의 입력창 표시여부
     *
     * @remarks
     * {@link FilterPanel.showInput}이 `false`이면 column.showInlineFilter가 `true`인 것만 표시된다.
     * @defaultValue - `undefined`
     */
    showInlineFilter?: boolean;
    /**
     * 사용자가 지정하는 임의 값
     *
     * @remarks
     * {@link GridBase.columnByTag | columnByTag}또는 {@link GridBase.columnsByTag | columnsByTag}를 이용해서 가져올수 있다.
     *
     * @defaultValue - `undefined`
     */
    tag?: any;
}

/**
 * 그리드 간 drag and drop 을 시작할 때 발생하는 콜백 형식
 *
 * @remarks
 * `false` 반환 시 drag and drop 이 취소된다.
 * {@link DataDropOptions.dragCallback} 에서 쓰인다.
 *
 * [매개변수 목록]
 *
 * `source` - 드래그한 아이템이 있던 GridBase 컨트롤
 *
 * `sourceItems` - 드래그한 그리드의 아이템들의 인덱스
 *
 * `target` - 드랍할 GridBase 컨트롤
 *
 * `targetItem` - 드랍할 그리드에서의 아이템 인덱스
 *
 * `targetColumn` - 드랍할 그리드에서의 targetColumn
 *
 * [반환값] - drag and drop 가능 여부
 *
 * @example
 * ```js
 * gridView.dataDropOptions.dragCallback = function (source, sourceItems, target, targetItem) {
 *     return targetItem % 2 == 0;
 * }
 * ```
 */
export declare type DataDragCallback = (source: GridBase, sourceItems: number[], target: GridBase, targetItem: number, targetColumn: string) => boolean;

/**
 * drag 중인 item 의 label 텍스트를 결정하기 위한 콜백의 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `source` - 드래그한 아이템이 있던 GridBase 컨트롤
 *
 * `sourceItems` - 드래그한 그리드의 아이템들의 인덱스
 *
 * `target` - 드랍할 GridBase 컨트롤
 *
 * `targetItem` - 드랍할 그리드에서의 아이템 인덱스
 *
 * `targetColumn` - 드랍할 그리드에서의 targetColumn
 *
 * [반환값] - 레이블의 텍스트
 *
 * @example
 * ```js
 * gridView.dataDropOptions.labelCallback = function (source, sourceItems, target, targetItem) {
 *     return sourceItems.length + " 개의 행";
 * }
 * ```
 */
export declare type DataDragLabelCallback = (source: GridBase, sourceItems: number[], target: GridBase, targetItem: number, targetColumn: string) => string;

/**
 * 그리드 간 drag and drop 했을 때 발생하는 콜백 형식
 *
 * @remarks
 * {@link DataDropOptions.callback} 에서 사용 된다.
 *
 * [매개변수 목록]
 *
 * `source` - 드래그한 아이템이 있던 GridBase 컨트롤
 *
 * `sourceItems` - 드래그한 그리드의 아이템들의 인덱스
 *
 * `target` - 드랍할 GridBase 컨트롤
 *
 * `targetItem` - 드랍할 그리드에서의 아이템 인덱스
 *
 * `targetColumn` - 드랍할 그리드에서의 targetColumn
 *
 * @example
 * ```js
 * gridView.dataDropOptions.callback = function (source, sourceItems, target, targetItem) {
 *     alert('row from ' + sourceItems + ' to ' + targetItem);
 *     for (var i = 0; i < sourceItems.length; i++) {
 *         var r = source.getDataRow(sourceItems[0]);
 *         var ds = source.getDataSource();
 *         var row = ds.getJsonRow(r)
 *         if (targetItem >= target.getItemCount()) {
 *             ds.addRow(row);
 *         } else {
 *             r = target.getDataRow(targetItem);
 *             target.getDataSource().insertRow(r, row);
 *         }
 *     }
 * }
 * ```
 */
export declare type DataDropCallback = (source: GridBase, sourceItems: number[], target: GridBase, targetItem: number, targetColumn: string) => void;

/**
 * 데이터 drop 시 모드
 */
export declare enum DataDropMode {
    /**
     * 복사
     */
    COPY = "copy",
    /**
     * 이동
     */
    MOVE = "move"
}

/**
 * 다른 그리드에서 drag 된 데이터를 처리하는 방식에 대한 설정 모델
 *
 * @remarks
 * callback 이 지정되지 않은 경우, {@link DataDropOptions.fieldMap | fieldMap} 이나 {@link DataDropOptions.fieldMapCallback | fieldMapCallback} 에 설정된대로 동작한다.
 *
 * 아무것도 지정되지 않은 경우 필드명이 같은 필드들의 값을 {@link DataDropOptions.dropMode | dropMode} 에 따라 이동 / 복사한다.
 *
 * {@link EditOptions.movable} 이 `true` 여야한다.
 *
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 * ```js
 * grid.setDataDropOptions({dropMode: 'copy'});
 * ```
 */
export declare interface DataDropOptions {
    /**
     * drag and drop 을 결정하는 콜백
     *
     * @remarks
     * drag 시작 시 발생한다.
     * {@link DataDragCallback} 의 형식이다.
     * @eventProperty
     */
    dragCallback?: DataDragCallback;
    /**
     * drop 했음을 알리는 콜백
     *
     * @remarks
     * drop 시 발생한다.
     * {@link DataDropCallback} 의 형삭이다.
     * @eventProperty
     */
    callback?: DataDropCallback;
    /**
     * 데이터 drop 모드
     *
     * @remarks
     * drop 시 {@link DataDropMode} 의 값으로 행 이동할 것인지 복사할 것인지 설정 가능하다.
     *
     * @defaultValue {@link DataDropMode.COPY}
     */
    dropMode?: DataDropMode;
    /**
     * feedbackStyle
     *
     * @remarks
     * mouse over시 표시되는 feedback의 style
     *
     * @defaultValue {@link DragFeedbackStyle.LINE}
     */
    feedbackStyle?: DragFeedbackStyle;
    /**
     * drag 를 시작한 그리드의 필드명 - drop 할 그리드의 필드명 쌍
     *
     * @remarks
     * callback 이나 feildMapcallback 이 설정되지 않았을 경우에 이 값을 따른다.
     * {@link FieldMap} 형식으로 drop 될 그리드에 설정해야한다.
     *
     * @example
     * ```js
     * {'CompanyName': 'ShipAddress'}
     * ```
     */
    fieldMap?: FieldMap;
    /**
     * {@link FieldMap} 형식의 오브젝트를 반환하여 규칙으로 사용하는 콜백
     *
     * @remarks
     * {@link DropFieldMapCallback} 의 형식이다.
     * drop 될 그리드에 설정해야한다.
     * @eventProperty
     */
    fieldMapCallback?: DropFieldMapCallback;
    /**
     * drag 중인 item 의 label 텍스트
     *
     * @remarks
     * {@link DataDropOptions.labelCallback} 이 설정되지 않았을 경우에 이 값을 따른다.
     *
     * [사용 가능 표현 목록]
     *
     * `${rows}` - 드래그 된 아이템의 개수
     *
     * `${mode}` - 현재 dropMode
     *
     * `${from}` - 드래그 된 위치 (인덱스)
     *
     * `${to}` - 복사 혹은 이동 될 위치 (인덱스)
     *
     * @defaultValue `${rows}행${mode}`
     *
     * @example
     * ```js
     * gridView.dataDropOptions.proxyLabel = '${rows} 개 행을 ${to} 로 ${mode}'
     * // ex)  '1 개 행을 4 로 복사'
     * ```
     */
    proxyLabel?: string;
    /**
     * drag 중인 item 의 label 텍스트를 결정하기 위한 콜백
     * @eventProperty
     */
    labelCallback?: DataDragLabelCallback;
    /**
     * `false`이면 drag중에 그리드 수직 스크롤이 실행되지 않도록 한다.
     *
     * @defaultValue `true`
     */
    scroll?: boolean;
}

/**
 * @public
 * 내보내기에 관한 설정 모델
 *
 * @remarks
 * {@link ExportOptions} 를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link ExportOptions}
 */
export declare interface DataExportOptions extends ExportOptions {
    /**
     * 내보내기 시 포함할 필드명들
     *
     * @remarks
     * 지정하지 않은 경우 모든 필드가 내보내기 된다.
     *
     * {@link DataExportOptions.hideFields | hideFields} 와 동시사용 불가능
     */
    exportFields?: string[];
    /**
     * 내보내기 시 제외할 필드명들
     *
     * @remarks
     * {@link DataExportOptions.exportFields | exportFields} 와 동시사용 불가능
     */
    hideFields?: string[];
    /**
     * fieldName 포함 여부
     *
     * @defaultValue `false`
     */
    includeFieldNames?: boolean;
}

/**
 * 데이터 필드 모델 객체
 *
 * @remarks
 * {@link DataProviderBase | DataProvider} 의 필드관련 method 에서 사용된다.
 *
 * @example
 * ```js
 * // model
 * let fields = ds.getFields();
 * ds.setFields(fields);
 * ```
 */
export declare interface DataField {
    /**
     * 필드의 인덱스
     * @readonly
     */
    index: number;
    /**
     * 필드명
     *
     * @remarks
     * 읽어올 때에는 대문자로 출력된다.
     *
     * 속성으로 접근 하여 설정하면, {@link DataField.orgFieldName | orgFieldName} 이 그대로 설정되고 해당 속성은 내부적으로 처리하기 위해 대문자로 바뀌어 설정된다.
     */
    fieldName: string;
    /**
     * 지정 당시의 필드명
     * @readonly
     */
    orgFieldName: string;
    /**
     * 자료형
     *
     * @remarks
     * {@link ValueType} 참고
     */
    dataType: ValueType;
    /**
     * 기본 자료형을 제한된 범위로 사용하기 위한 지시자
     *
     * @remarks
     * {@link ValueType} 참고
     *
     * @defaultValue `null`
     */
    subType: ValueType;
    /**
     * {@link DataField.subType | 자료형을 제한 된 범위로 사용하기 위한 지시자} 사용 가능 여부
     *
     * @defaultValue `true`
     */
    subTypeEnabled: boolean;
    /**
     * 기준 필드
     *
     * @remarks
     * 읽어올 때는 대문자로 출력된다.
     *
     * 속성으로 접근하여 설정하면 대문자로 저장된다.
     *
     * 검증 시 사용된다.
     */
    baseField: string;
    /**
     * 데이터 길이
     */
    length: number;
    /**
     * 필드셋
     *
     * @remarks
     * 배열에 포함된 값이 아니면 `undefined`로 저장되게 한다.
     *
     * Boolean 자료형을 제외한 나머지 자료형에서 사용가능하다.
     */
    set: any[];
    /**
     * 최소 범위의 한계값
     *
     * @remarks
     * 숫자 또는 날짜형 자료형일 때 사용 가능하다.
     */
    minimum: number;
    /**
     * 최대 범위의 한계값
     *
     * @remarks
     * 숫자 또는 날짜형 자료형일 때 사용 가능하다.
     */
    maximum: number;

    /**
     * 그룹 헤더 타이틀
     *
     * @remarks
     * Row Grouping 시 그룹 헤더의 타이틀에 기준필드의 헤더 값을 표시할 수 있다.
     */
    header: string;
    /**
     * 필드의 기본 데이터 값
     * @remarks
     * 기본값을 지정하면 {@link GridView.beginInsertRow}, {@link GridView.beginAppendRow} 함수 호출시 지정된 기본값이 입력된 상태로 새로운 행이 추가된다.
     */
    defaultValue: any;
    /**
     * 데이터가 `null` 일 때 대체될 데이터
     */
    nullValue: any;
    /**
     * Boolean 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 boolean 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * {@link DataOutputOptions.booleanFormat} 에 설정된 값을 우선한다.
     *
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat: string;
    /**
     * 날짜 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 datetime 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * {@link DataOutputOptions.datetimeFormat} 에 설정된 값을 우선한다.
     *
     * 예) `'yyyy-M-dd'`
     */
    datetimeFormat: string;
    /**
     * 오전 표시 텍스트
     */
    amText: string;
    /**
     * 오후 표시 텍스트
     */
    pmText: string;
    /**
     * 년도 값이 100보다 작을 경우 기준 년도
     *
     * @defaultValue `2000`
     */
    baseYear: number;
    /**
     * calculated 필드일 경우 사용될 수식
     *
     * @remarks
     * values['필드명'], values[필드인덱스]로 참조한다.
     *
     * 수식에서 다른 calculated 필드의 참조는 허용하지 않는다.
     *
     * @example
     * ```js
     * dataField.valueExpression = "values['Quantity'] * values['UnitPrice']";
     * ```
     */
    valueExpression: string;
    /**
     * calculated 필드일 경우 수식을 지정하여 계산 될 콜백
     *
     * @remarks
     * 수식에서 다른 calculated 필드의 참조는 허용하지 않는다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataField.valueCallback = function (provider, dataRow, fieldName, fieldNames, values) {
     *     let quantity = values[fieldNames.indexOf("Quantity")];
     *     let unitprice = values[fieldNames.indexOf("UnitPrice")];
     *     if (isNaN(quantity) || isNaN(unitprice))
     *         return undefined;
     *     else
     *         return quantity >= 1000 ? Math.round(quantity * unitprice * 0.95) : quantity * unitprice;
     * }
     * ```
     */
    valueCallback: FieldValueCallback;
    /**
     * calculated 필드인지 여부
     *
     * @remarks
     * {@link DataField.valueExpression | valueExpression} 이나 {@link DataField.valueCallback | valueCallback} 이 설정되어 있으면 calculated 이다.
     *
     * @readonly
     */
    calculated: boolean;
    /**
     * 필드값 수정 가능 여부
     */
    updatable: boolean;
}

/**
 * @public
 * 데이터 필드에 관한 입력 형식
 *
 * @remarks
 * {@link DataProviderBase.setFields |setFields} 등에서 사용한다.
 *
 * @example
 * ```js
 * // string
 * ds.setFields('fieldnName');
 *
 * // model
 * let fields = ds.getFields();
 * ds.setFields(fields);
 *
 * // config
 * ds.setFields({
 *      fieldName: 'OrderID',
 *      dataType: 'text',
 * });
 * ```
 */
export declare type DataFieldInput = string | DataField | DataFieldObject;

/**
 * 설정할 때 사용하는 {@link DataField} 와 동일한 구조의 오브젝트
 *
 * @remarks
 * {@link DataProviderBase.setFields | setFields()} 에서 사용된다.
 *
 * @example
 * ```js
 * // config
 * ds.setFields({
 *      fieldName: 'OrderID',
 *      dataType: 'text',
 * });
 * ```
 */
export declare interface DataFieldObject {
    /**
     * 필드명
     */
    fieldName?: string;
    /**
     * 자료형
     *
     * @remarks
     * {@link ValueType} 참고
     */
    dataType?: ValueType;
    /**
     * 기본 자료형을 제한된 범위로 사용하기 위한 지시자
     *
     * @remarks
     * {@link ValueType} 참고
     *
     * @defaultValue `null`
     */
    subType?: string;
    /**
     * 데이터 길이
     */
    length?: number;
    /**
     * 필드셋
     *
     * @remarks
     * 배열에 포함된 값이 아니면 `undefined`로 저장되게 한다.
     *
     * Boolean 자료형을 제외한 나머지 자료형에서 사용가능하다.
     */
    set?: any[];
    /**
     * 필드의 기본 데이터 값
     * @remarks
     * 기본값을 지정하면 {@link GridView.beginInsertRow}, {@link GridView.beginAppendRow} 함수 호출시 지정된 기본값이 입력된 상태로 새로운 행이 추가된다.
     */
    defaultValue?: any;
    /**
     * 기준 필드
     *
     * @remarks
     * 검증 시 사용된다.
     */
    baseField?: string;
    /**
     * Boolean 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 boolean 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * {@link DataOutputOptions.booleanFormat} 에 설정된 값을 우선한다.
     *
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
    /**
     * 날짜 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 datetime 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * {@link DataOutputOptions.datetimeFormat} 에 설정된 값을 우선한다.
     *
     * 예) `'yyyy-M-dd'`
     */
    datetimeFormat?: string;
    /**
     * 오전 표시 텍스트
     */
    amText?: string;
    /**
     * 오후 표시 텍스트
     */
    pmText?: string;


    /**
     * 최소 범위의 한계값
     *
     * @remarks
     * 숫자 또는 날짜형 자료형일 때 사용 가능하다.
     */
    minimum?: number;
    /**
     * 최대 범위의 한계값
     *
     * @remarks
     * 숫자 또는 날짜형 자료형일 때 사용 가능하다.
     */
    maximum?: number;

    /**
     * 년도 값이 100보다 작을 경우 기준 년도
     *
     * @defaultValue `2000`
     */
    baseYear?: number;
    /**
     * calculated 필드일 경우 사용될 수식
     *
     * @remarks
     * values['필드명'], values[필드인덱스]로 참조한다.
     *
     * 수식에서 다른 calculated 필드의 참조는 허용하지 않는다.
     *
     * @example
     * ```js
     * ds.setFields({
     *      fieldName: 'TotalPrice',
     *      dataType: 'text',
     *      valueExpression: "values['Quantity'] * values['UnitPrice']"
     * });
     * ```
     */
    valueExpression?: string;
    /**
     * calculated 필드일 경우 수식을 지정하여 계산 될 콜백
     *
     * @remarks
     * 수식에서 다른 calculated 필드의 참조는 허용하지 않는다.
     * @eventProperty
     *
     * @example
     * ```js
     * ds.setFields({
     *      fieldName: 'TotalPrice',
     *      dataType: 'text',
     *      valueCallback: function (dataRow, fieldName, fieldNames, values) {
     *          let quantity = values[fieldNames.indexOf("Quantity")];
     *          let unitprice = values[fieldNames.indexOf("UnitPrice")];
     *          if (isNaN(quantity) || isNaN(unitprice))
     *              return undefined;
     *          else
     *              return quantity >= 1000 ? Math.round(quantity * unitprice * 0.95) : quantity * unitprice;
     *      }
     * });
     * ```
     */
    valueCallback?: FieldValueCallback;
    /**
     * 그룹 헤더 타이틀
     *
     * @remarks
     * Row Grouping 시 그룹 헤더의 타이틀에 기준필드의 헤더 값을 표시할 수 있다.
     */
    header?: string;
}

/**
 * 데이터 채우기 방법
 *
 * @remarks
 * {@link DataFillOptions.fillMode} 에서 사용한다.
 */
export declare enum DataFillMode {
    /**
     * 기존 데이터를 무시하고 0행부터 데이터 행 개수만큼 채움
     */
    SET = "set",
    /**
     * 마지막 행 뒤에 데이터 추가
     */
    APPEND = "append",
    /**
     * 삽입
     */
    INSERT = "insert",
    /**
     * 기존 데이터를 대체한다. 마지막행까지 도착한 이후 남은 데이터는 무시된다.
     */
    UPDATE = "update"
}

/**
 * 데이터 불러오기에 관한 설정 모델
 *
 * @remarks
 * {@link LocalDataProvider.fillJsonData}, {@link LocalTreeDataProvider.fillJsonData} 등의 fill 관련 method 에서 사용된다.
 *
 * 원하는 정보만 입력하여 설정하면 된다.
 */
export declare interface DataFillOptions {
    /**
     * 데이터 채움 방법
     *
     * @defaultValue {@link DataFillMode.SET}
     */
    fillMode?: DataFillMode;
    /**
     * `fillMode`가 'insert' 거나 'update' 때 시작되는 행
     *
     * @defaultValue `0`
     */
    fillPos?: number;
    /**
     * 가져올 데이터 행
     *
     * @remarks
     * `-1`인 경우 전체를 가져온다.
     * @defaultValue `-1`
     */
    count?: number;
    /**
     * 데이터 소스의 최상위가 Array 인지의 여부
     *
     * @remarks
     * json인 경우에만 사용
     *
     * @defaultValue `true`
     */
    rootArray?: boolean;
    /**
     * 행의 데이터 형식
     *
     * 데이터 중에서 row element나 array 요소의 이름. json, xml안 경우에만 사용가능 하다.
     *
     * @defaultValue 'row'
     */
    rows?: string;
    /**
     * 데이터에서 해더등을 제외한 실제 데이터 시작 행
     *
     * @remarks
     *
     * @defaultValue `0`
     */
    start?: number;
    /**
     * 구분자
     *
     * @remarks
     * CSV 경우인 경우에만 사용
     *
     * @defaultValue `','`
     */
    delimiter?: string;
    /**
     * 각 셀 데이터가 double-quotation mark("") 로 감싸져 있는지 여부
     *
     * @remarks
     * CSV 경우인 경우에만 사용
     *
     * @defaultValue `false`
     */
    quoted?: boolean;
    /**
     * 부모 행의 고유번호
     *
     * @remarks
     * TreeProvider만 사용가능하다.
     *
     * `parent` 라는 속성으로 지정할 수도 있다.
     * @defaultValue `0`
     */
    parentId?: number;
    /**
     * TreeProvider만 사용가능, children field
     */
    childrenField?: string;
    /**
     * 트리 필드 명
     *
     * @remarks
     * TreeProvider만 사용가능하다.
     *
     * `tree` 라는 속성으로 지정할 수도 있다.
     *
     * @defaultValue `null`
     */
    treeField?: string;
    /**
     * 아이콘 필드 명
     *
     * @remarks
     * TreeProvider만 사용가능하다.
     *
     * `icon` 라는 속성으로 지정할 수도 있다.
     *
     * @defaultValue `null`
     */
    iconField?: string;
    /**
     * 정렬 여부
     *
     * @remarks
     * TreeProvider만 사용가능하다.
     *
     * `sorting` 라는 속성으로 지정할 수도 있다.
     *
     * @defaultValue `false`
     */
    needSorting?: boolean;
    /**
     * 생성 된 데이터 행들에 상태를 설정하지 않을 것인지의 여부
     *
     * @defaultValue `false`
     */
    noStates?: boolean;
}

/**
 * 데이터 필터 조건을 갖고 있는 오브젝트
 *
 * @remarks
 * {@link DataFilters} 의 하위 타입으로 이 모델의 배열이 포함된다.
 *
 * {@link LocalDataProvider.setFilters} 에서 실질적으로 사용된다.
 *
 * @example
 * ```js
 * dataProvider.setFilters({criteria: "value['field1']='가수'"});
 * ```
 */
export declare interface DataFilter {
    /**
     * 필터 조건식
     */
    criteria: string;
}

/**
 * 필터 조건의 배열 및 컬렉션 오브젝트
 *
 * @remarks
 * {@link LocalDataProvider.setFilters} 에서 사용한다.
 *
 * @example
 * ```js
 * // string
 * dataProvider.setFilters([
 *   "value['field1']='가수'",
 *   "value['field2']='여자'"
 * ], "and");
 *
 * // object
 * dataProvider.setFilters([
 *   {criteria: "value['field1']='가수'"},
 *   {criteria: "value['field2']='여자'"}
 * ], "and");
 * ```
 */
export declare type DataFilters = DataFilter | DataFilter[] | string | string[];

/**
 * {@link DataProviderBase} 의 전체설정 정보들
 *
 * @remarks
 * {@link DataProviderBase.getOptions}, {@link DataProviderBase.setOptions | setOptions} 에서 사용한다.
 *
 * @example
 * ```js
 * let options = ds.getOptions();
 * options.undoable = true;
 * ds.setOptions(options);
 * ```
 */
export declare interface DataOptions {
    subTypeEnabled?: boolean;
    undoable?: boolean;
    insertable?: boolean;
    updatable?: boolean;
    deletable?: boolean;
    softDeleting?: boolean;
    deleteCreated?: boolean;
    checkStates?: boolean;
    restoreMode?: string;
    strictRestore?: boolean;
    booleanFormat?: string;
    datetimeFormat?: string;
    baseYear?: number;
    amText?: string;
    pmText?: string;
    commitBeforeDataEdit?: boolean;
}

/**
 * 출력할 때 데이터를 반환하는 방식에 대한 설정 모델
 *
 * @remarks
 * datetime, boolean, number 필드에 대해 변환 형식을 지정한다.
 *
 * {@link LocalDataProvider.getOutputRow}, {@link LocalDataProvider.getOutputRows} 에서 사용한다.
 *
 * {@link LocalTreeDataProvider.getOutputRow}, {@link LocalTreeDataProvider.getOutputRows} 에서 사용한다.
 *
 * @example
 * ```js
 * let opt = {
 *      nullText: '빈 값'
 * }
 * let row = dataProvider.getOutputRow(opt, 4);
 * ```
 */
export declare interface DataOutputOptions {
    /**
     * 날짜 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 datetime 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * 지정되지 않은 경우 데이터필드에 설정된 값을 사용한다.
     *
     * 예) `'yyyy-M-dd'`
     */
    datetimeFormat?: string;
    /**
     * Boolean 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 boolean 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * 지정되지 않은 경우 {@link DataField | DataField}에 설정된 값을 사용한다.
     *
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
    /**
     * 숫자 형식의 값일 때 서식
     *
     * @remarks
     * 예) `'#,##0.###'`
     *
     */
    numberFormat?: string;
    /**
     * DateTime 필드의 값이 null 일때 표현되는 값
     */
    nullDateText?: string;
    /**
     * text 필드의 값이 `null` 일때 표현되는 값
     */
    nullText?: string;
    /**
     * number 필드의 값이 `null` 일때 표현되는 값
     */
    nanText?: string;
    /**
     * `true`이면 반환값에 행 상태값을 추가한다.
     */
    rowState?: boolean;
    /**
     * datetime 필드 변환시 수행 될 콜백
     *
     * @remarks
     * {@link DatetimeOutputCallback} 의 형식이다.
     * @eventProperty
     */
    datetimeCallback?: DatetimeOutputCallback;
    /**
     * boolean 필드 변환시 수행 될 콜백
     *
     * @remarks
     * {@link BooleanOutputCallback} 의 형식이다.
     * @eventProperty
     */
    booleanCallback?: BooleanOutputCallback;
    /**
     * number 필드 변환시 수행 될 콜백
     *
     * @remarks
     * {@link NumberOutputCallback} 의 형식이다.
     * @eventProperty
     */
    numberCallback?: NumberOutputCallback;
}

/**
 * @public
 * {@link LocalDataProvider} 와 {@link LocalTreeDataProvider} 의 기반 클래스
 *
 * @remarks
 * DataProviderBase 의 모든 속성과 method 는 이를 상속한 하위 클래스들에서만 호출할 수 있다.
 *
 * [하위 클래스]
 *
 * {@link LocalDataProvider}
 *
 * {@link LocalTreeDataProvider}
 *
 * @param undoable - 데이터를 되돌릴 수 있는지 여부
 *
 * @warning DataProviderBase 로 직접 설정하거나 호출할 수 없다.
 *
 */
export declare abstract class DataProviderBase {

    
    /**
     * @param undoable - 데이터를 되돌릴 수 있는지 여부
     */
    constructor(undoable: boolean);

    /**
     * {@link DataField} 의 subType 속성의 활성화 여부
     *
     * @defaultValue `true`
     *
     * @example
     * ```js
     * ds.subTypeEndabled = false;
     * ```
     */
    get subTypeEnabled(): boolean;
    set subTypeEnabled(value: boolean);
    /**
     * undo/redo 사용 여부
     *
     * @defaultValue `false`
     *
     * @example
     * ```js
     * ds.undoable = true;
     * ```
     */
    get undoable(): boolean;
    set undoable(value: boolean);
    /**
     * 행 삽입 가능 여부
     *
     * @defaultValue `true`
     *
     * @example
     * ```js
     * ds.insertable = false;
     * ```
     */
    get insertable(): boolean;
    set insertable(value: boolean);
    /**
     * 행 수정 가능 여부
     *
     * @defaultValue `true`
     *
     * @example
     * ```js
     * ds.updatable = false;
     * ```
     */
    get updatable(): boolean;
    set updatable(value: boolean);
    /**
     * 행 삭제 가능 여부
     *
     * @defaultValue `true`
     *
     * @example
     * ```js
     * ds.deletable = false;
     * ```
     */
    get deletable(): boolean;
    set deletable(value: boolean);
    /**
     * 행 삭제 시 실제로 삭제하지 않고 RowState 만 변경할지의 여부
     * @defaultValue `false`
     *
     * @example
     * ```js
     * ds.softDeleting = false;
     * ```
     */
    get softDeleting(): boolean;
    set softDeleting(value: boolean);
    /**
     * 추가된 행을 삭제 시 실제로 삭제할지의 여부
     *
     * @defaultValue `false`
     *
     * @example
     * ```js
     * ds.deleteCreated = false;
     * ```
     */
    get deleteCreated(): boolean;
    set deleteCreated(value: boolean);
    /**
     * 행 상태 관리 활성화 여부
     *
     * @defaultValue `true`
     *
     * @example
     * ```js
     * ds.checkStates = false;
     * ```
     */
    get checkStates(): boolean;
    set checkStates(value: boolean);
    /**
     * 복원 모드
     * @defaultValue {@link RestoreMode.NONE}
     *
     * @example
     * ```js
     * ds.restoreMode = 'explicit';
     * ```
     */
    get restoreMode(): RestoreMode;
    set restoreMode(value: RestoreMode);
    /**
     * 복원시 `undefined`, `null`, 빈 문자열을 다른 값으로 인식할지의 여부
     *
     * @defaultValue `false`
     *
     * @example
     * ```js
     * ds.strictRestore = true;
     * ```
     */
    get strictRestore(): boolean;
    set strictRestore(value: boolean);
    /**
     * 데이터에서 Boolean으로 Parsing 하기 위한 포맷
     *
     * @defaultValue `null` (기본 포맷 이용)
     *
     * @example
     * ```js
     * ds.booleanFormat = 'No: Yeah';
     * ```
     */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    /**
     * text형식의 날짜 데이터를 datetime 값으로 Parsing하기위한 포맷
     *
     * @defaultValue `null` (기본 포맷 이용)
     *
     * @example
     * ```js
     * ds.datetimeFormat = 'yyyy-MM-dd';
     * ```
     */
    get datetimeFormat(): string;
    set datetimeFormat(value: string);
    /**
     * 데이터의 년도가 2자리일때 기준으로 하는 년도
     *
     * @defaultValue `2000`
     *
     * @example
     * ```js
     * ds.baseYear = 1000;
     * ```
     */
    get baseYear(): number;
    set baseYear(value: number);
    /**
     * 데이터에서 오전에 해당하는 문자열
     *
     * @defaultValue `'AM'`
     *
     * @example
     * ```js
     * ds.amText = "오전";
     * ```
     */
    get amText(): string;
    set amText(value: string);
    /**
     * 데이터에서 오후에 해당하는 문자열
     * @defaultValue `'PM'`
     *
     * @example
     * ```js
     * ds.pmText = "오후";
     * ```
     */
    get pmText(): string;
    set pmText(value: string);
    /**
     * 편집 상태일 때 다른 행에 대한 변경 함수(`setValue()` 등) 호출 시 이전 편집 자동 커밋 여부
     *
     * @defaultValue `false`
     *
     * @example
     * ```js
     * ds.commitBeforeDataEdit = true;
     * ```
     */
    get commitBeforeDataEdit(): boolean;
    set commitBeforeDataEdit(value: boolean);
    /**
     * json 형태의 data를 dataProvider에 입력할때 각 행별로 호출되는 콜백
     *
     * @remarks
     *
     * @defaultValue `undefined`
     */
    get valuesCallback(): ObjectToValuesCallback;
    set valuesCallback(value: ObjectToValuesCallback);
    /**
     * 설정 정보를 반환한다.
     *
     * @remarks
     * 설정정보를 {@link DataOptions} 형태로 반환한다.
     *
     * @example
     * ```js
     * let options = ds.getOptions();
     * options.undoable = true;
     * ds.setOptions(options);
     * ```
     */
    getOptions(): DataOptions;
    /**
     * 설정정보를 변경한다.
     *
     * @remarks
     * options 에 기입하지 않은 설정은 원래의 값을 유지한다.
     *
     * @param options - {@link DataOptions} 설정정보 객체
     *
     * @example
     * ```js
     * let options =  {
     *     insertable: true,
     *     updatable: true,
     *     softDeleting: false
     * };
     * ds.setOptions(options);
     * ```
     */
    setOptions(options: DataOptions): void;
    /**
     * 일괄 갱신의 시작점을 지정한다.
     *
     * @remarks
     * DataProvider에서 변경 작업이 발생하면 이를 View에 이벤트를 전달하여 처리하는데 일괄처리를 할때는 이벤트가 빈번히 발생하여 성능이 저하 될 수 있다.
     * beginUpdate()를 호출하면 {@link DataProviderBase.endUpdate | endUpdate()} 가 호출 되기전까지 이벤트가 발생하지 않고 endUpdate()가 호출될 때 일괄 발생한다.
     * beginUpdate ~ endUpdate는 중첩될 수 있는데 반드시 쌍으로 호출되어야 하고 마지막 쌍의 endUpdate가 호출될때 이벤트가 View에 전달된다.
     *
     * @example
     * ```js
     * dataProvider.beginUpdate();
     * try {
     *     for (var i = 0; i < 10; i++) {
     *         var values = gridView.getValues(i);
     *         dataProvider.addRow(values);
     *     }
     * } finally {
     *     dataProvider.endUpdate();
     * }
     * ```
     */
    beginUpdate(): void;
    /**
     * 일괄 갱신의 완료점을 지정한다.
     *
     * @remarks
     * DataProvider에서 변경 작업이 발생하면 이를 View에 이벤트를 전달하여 처리하는데 일괄처리를 할때는 이벤트가 빈번히 발생하여 성능이 저하 될 수 있다.
     * {@link DataProviderBase.beginUpdate | beginUpdate()} 를 호출하면 endUpdate()가 호출될 되기전까지 이벤트를 발생하지 않고 endUpdate()가 호출될대 일괄 발생한다.
     * beginUpdate ~ endUpdate는 중첩될 수 있는데 반드시 쌍으로 호출되어야 하고 마지막 쌍의 endUpdate가 호출될때 이벤트가 View에 전달된다.

     * @example
     * ```js
     * dataProvider.beginUpdate();
     * try {
     *     for (var i = 0; i < 10; i++) {
     *         var values = gridView.getValues(i);
     *         dataProvider.addRow(values);
     *     }
     * } finally {
     *     dataProvider.endUpdate();
     * }
     * ```
     */
    endUpdate(refresh?: boolean): void;
    /**
     * {@link DataField} 객체들을 반환한다.
     *
     * @remarks
     * 현재 DataProvider에 설정된 DataField 객체를 배열로 반환한다.
     *
     * @example
     * ```js
     * let fields = ds.getFields();
     * ds2.setFields(fields);
     * ```
     */
    getFields(): DataField[];
    /**
     * 필드셋을 설정한다
     *
     * @remarks
     * 기존 필드 정보와 binding된 데이터를 삭제하고 전달받은 필드 정보 배열로 부터 새로운 필드셋을 구성한다.
     * fields의 갯수만큼 {@link DataField} 객체를 생성, 요소가 문자열일경우 fieldName으로, DataField 인 경우 복제, {@link DataFieldObject} 인 경우 속성값 기준으로 생성한다.
     *
     * @param fields - 생성할 DataField의 정보 배열
     *
     * @example
     * ```js
     * // string
     * ds.setFields('fieldnName');
     *
     * // model
     * let fields = ds.getFields();
     * ds.setFields(fields);
     *
     * // config
     * ds.setFields({
     *      fieldName: 'OrderID',
     *      dataType: 'text',
     * });
     * ```
     */
    setFields(fields: DataFieldInput[]): void;
    /**
     * 필드를 추가로 생성한다.
     *
     * @remarks
     * {@link DataField} 객체를 생성하여 기존 필드셋에 추가한다.
     *
     * @param field - 생성할 데이터 필드의 정보값, 문자열일 경우 fieldName으로 설정
     * @param resetFields - 기존 데이터 필드에 binding된 데이터를 초기화 할지의 여부
     * @param calculateData - calculated 필드를 다시 계산할지의 여부
     *
     * @example
     * ```js
     * // string
     * ds.addField('fieldnName');
     *
     * // model
     * let fields = ds.getFields();
     * ds2.addField(fields);
     *
     * // config
     * ds.addField({
     *      fieldName: 'OrderID',
     *      dataType: 'text',
     * });
     * ```
     */
    addField(field: DataFieldInput, resetFields?: boolean, calculateData?: boolean): DataField;
    /**
     * 현재 구성된 필드셋의 갯수를 반환한다.
     *
     * @example
     * ```js
     * let fCount = ds.getFieldCount();
     * ```
     */
    getFieldCount(): number;
    /**
     * 이름에 해당하는 필드를 반환한다.
     *
     * @returns fieldName속성을 기준으로 해당하는 {@link DataField} 객체를 반환한다. fieldName이 모두 일치하지 않을 경우 `null`을 반환한다.
     *
     * @param name - 필드의 fieldName에 해당하는 값
     *
     * @example
     * ```js
     * let field = ds.fieldByName('Fruits');
     * ```
     */
    fieldByName(name: string): DataField;
    /**
     * 필드들의 이름을 반환한다.
     *
     * @remarks
     * 필드셋에서 필드의 fieldName 속성들을 배열로 반환한다.
     *
     * fieldName은 내부적으로 대문자로 저장되므로 대문자 문자열로 출력된다.
     *
     * 설정시의 fieldName으로 가져오려면 {@link DataProviderBase.getOrgFieldNames | getOrgFieldNames()} 를 사용한다.
     *
     * @example
     * ```js
     * let fieldNames = ds.getFieldNames();
     * ```
     */
    getFieldNames(): string[];
    /**
     * 필드들의 원래의 이름을 반환한다.
     *
     * @returns 필드셋에서 필드 설정당시의 fieldName 속성들을 반환한다.
     *
     * @example
     * ```js
     * let orgFieldNames = ds.getOrgFieldNames();
     * ```
     */
    getOrgFieldNames(): string[];
    /**
     * 특정 인덱스의 필드의 이름을 반환한다.
     *
     * @remarks
     * 필드셋에서 fieldIndex에 위치된 필드의 fieldName속성을 반환한다.
     *
     * fieldName은 내부적으로 대문자로 저장되므로 대문자 문자열로 출력된다.
     *
     * 설정시의 fieldName으로 가져오려면 {@link DataProviderBase.getOrgFieldName | getOrgFieldName()} 을 사용한다.
     *
     * @param fieldIndex - 필드 인덱스
     *
     * @example
     * ```js
     * let fieldName = ds.getFieldName(3);
     * ```
     */
    getFieldName(fieldIndex: number): string;
    /**
     * 특정 인덱스의 필드의 원래 이름을 반환한다.
     *
     * @param fieldIndex - 필드의 인덱스
     * @returns 필드셋에서 fieldIndex에 위치된 필드의 설정 당시의 fieldName속성을 반환한다.
     *
     * @example
     * ```js
     * let fieldName = ds.getOrgFieldName(3);
     * ```
     */
    getOrgFieldName(fieldIndex: number): string;
    /**
     * 필드명에 해당하는 인덱스를 반환한다.
     *
     * @param fieldName - 필드명, 대소문자를 구분하지 않는다.
     * @returns 필드셋에서 fieldName에 해당하는 필드의 인덱스를 반환한다.
     *
     * @example
     * ```js
     * let index = ds.getFieldIndex('fieldName');
     * ```
     */
    getFieldIndex(fieldName: string): number;
    /**
     * 행에 값이 채워져씼는지 여부를 반환한다.
     *
     * @remarks
     * 지정한 데이터행이 값이 채워져있는지 빈 행인지 여부를 반환한다.
     *
     * @param row - 데이터셋의 행 고유번호
     *
     * @returns 값이 있으면 `true`, 데이터없이 추가된 빈 행이면 `false`
     *
     * @example
     * ```js
     * let has = ds.hasData(5);
     * ```
     */
    hasData(row: number): boolean;
    /**
     * 행의 값들을 반환한다.
     *
     * @remarks
     * 해당 데이터 행의 값들을 배열로 반환한다.
     *
     * @param row - 데이터 셋의 행 고유번호
     * @returns 필드 순서대로 배열화한다.
     *
     * @example
     * ```js
     * let val = ds.getValeus(5);
     * ```
     */
    getValues(row: number): RowValues;
    /**
     * 행 상태 기록 여부를 지정한다.
     *
     * @remarks
     * 행 추가/수정/삭제 상태가 변경될 때 상태를 기록할지를 결정한다.
     * 기록 되지 않으면 {@link DataProviderBase.softDeleting | softDeleting} 이 `true`여도 무시하고 삭제 된다.
     * @param value - 행 상태 기록 여부
     *
     * @example
     * ```js
     * let checkState = ds.checkRowStates(true);
     * ```
     */
    checkRowStates(value: boolean): void;
    /**
     * 지정한 행의 상태를 반환한다.
     *
     * @param row - 데이터 셋의 행 고유 번호
     * @returns 아무 상태도 없으면 {@link RowState.NONE} 을 반환한다.
     *
     * @example
     * ```js
     * let rowState = ds.getRowState(4);
     * ```
     */
    getRowState(row: number): RowState;
    /**
     * 특정 상태를 갖는 데이터 행 인덱스들을 반환한다.
     *
     * @remarks
     * 지정된 rowState 값을 상태로 갖는 행들의 인덱스를 배열로 반환한다.
     *
     * @param rowState - 행 상태, {@link RowState} 모델
     *
     * @example
     * ```js
     * let rows = ds.getStateRows('c');
     * ```
     */
    getStateRows(rowState?: RowState): number[];
    /**
     * 상태값을 갖는 모든 행의 인덱스를 반환한다.
     *
     * @remarks
     * {@link RowState.NONE } 이 아닌 행들의 번호를 상태별로 배열로 만들어 Object 형태로 반환한다.
     *
     * @returns - {@link RowStateList} 모델이다.
     *
     * @example
     * ```js
     * let rows = ds.getAllStateRows();
     * ```
     */
    getAllStateRows(): RowStateList;
    /**
     * 모든 행의 상태를 제거한다.
     *
     * @remarks
     * 모든 데이터 행의 상태를 {@link RowState.NONE } 으로 초기화한다.
     *
     * @param deleteRows - 행 상태가 삭제인 행을 실제로 삭제할지의 여부, `true`이면 데이터 셋에서 제거되고 `false`이면 행 상태를 리셋하고 데이터를 보존한다.
     * @param rowEvents - 상태가 제거된 행에 대해 {@link LocalDataProvider.onRowStateChanged | onRowStateChanged} 등의 상태변경 콜백을 발생시킬지의 여부
     *
     * @example
     * ```js
     * ds.clearRowState(true);
     * ```
     */
    clearRowStates(deleteRows: boolean, rowEvents?: boolean): void;
    /**
     * 특정 행의 상태를 변경한다.
     *
     * @param row - 상태를 변경할 데이터 행 인덱스
     * @param state - 변경할 상태, 기본값: {@link RowState.NONE}
     * @param force - DataProvider의 상태 관리에 관계없이 적용 여부, 기본값: `false`
     *
     * @example
     * ```js
     * ds.setRowState(5, 'updated');
     * ```
     */
    setRowState(row: number, state?: RowState, force?: boolean): void;
    /**
     * 복수의 행의 상태를 일괄 변경한다.
     *
     * @remarks
     * 배열로 전달된 데이터 행들의 상태를 일괄적으로 변경한다.
     *
     * @param rows - 상태를 변경할 데이터 행 인덱스의 배열
     * @param state - 변경할 상태
     * @param force -  DataProvider의 상태 관리에 관계없이 적용 여부
     * @param rowEvents - `true`이면 각각의 데이터 행의 상태 변경 이벤트 발생, `false`면 하나의 이벤트로 묶어서 발생
     *
     * @example
     * ```js
     * ds.setRowStates([1,3,5], "updated");
     * ```
     */
    setRowStates(rows: number[], state?: RowState, force?: boolean, rowEvents?: boolean): void;
    /**
     * 상태별 데이터 행 개수를 반환한다.
     *
     * @remarks
     * 지정한 상태 배열 또는 문자열에 따라 포함된 상태별 행 건수를 반환한다.
     *
     * `'*'`, `'all'` 입력 시 모두 반환한다.
     *
     * @param states - 행의 상태, 복수일때는 상태의 배열, 모든 상태를 알고싶은 경우 'all' 또는 '*' 문자열을 사용한다.
     * @returns 상태에 해당하는 데이터 행의 건수, {@link RowState.NONE} 인 경우는 제외한다.
     * @example
     * ```js
     * var allStateCount = dataProvider.getRowStateCount('all');
     * var updateCount = dataProvider.getRowStateCount(RealGrid.RowState.UPDATED);
     * ```
     */
    getRowStateCount(states: string | RowState | RowState[]): number;
    /**
     * 지정한 행들의 상태를 복원한다.
     *
     * @remarks
     * restoreMode속성이 {@link RestoreMode.EXPLICIT}일 때 값이 변경되었다가 원복된 행의 상태를 복원한다.
     * 예를들어 상태가 {@link RowState.NONE} 인 행을 편집하여 {@link RowState.UPDATED} 상태가 되었을때 행의 값이 원래대로 돌아간후 호출하면 상태가 {@link RowState.NONE}으로 원복된다.
     * restoreMode가 AUTO일 땐 행 값에 따라 자동으로 복원된다.
     * @param rows - 상태를 원복하려는 데이터행 인덱스의 배열
     *
     * @example
     * ```js
     * ds.restoreUpdatedStates([2, 4]);
     * ```
     */
    restoreUpdatedStates(rows: number[]): void;
    /**
     * 지정한 행들의 값과 상태를 복원한다.
     * @remarks
     * restoreMode속성이 {@link RestoreMode.EXPLICIT} 또는 AUTO일 때, 지정된 행들의 변경내용과 상태를 원래대로 복원한다.
     * @param rows - 복원하려는 행의 인덱스 또는 인덱스 배열
     *
     * @example
     * ```js
     * ds.restoreUpdatedRows([2, 4]);
     * ```
     */
    restoreUpdatedRows(rows: number | number[]): void;
    /**
     * 지정한 행들의 변경된 셀정보를 반환한다
     *
     * @remarks
     * restoreMode속성이 {@link RestoreMode.EXPLICIT} 또는 AUTO일 때, 지정된 행들 각각의 값이 변경된 셀의 정보를 반환한다.
     *
     * @param rows - 변경된 셀의 정보를 가져올 행의 배열, `null`일 경우 상태가 {@link RowState.UPDATED}인 전체 행의 정보를 반환한다.
     * @example
     * ```js
     *
     * let cells = ds.getUpdatedCells([1]);
     *
     * // 변환 데이터 예)
     * [
     *   {
     *     __rowId: 1,
     *     updatedCells: [
     *       {
     *         fieldName: 'OrderID',
     *         oldValue: '1002',
     *         newValue: '1003',
     *       },
     *       {
     *         fieldName: 'OrderCount',
     *         oldValue: 20,
     *         newValue: 30
     *       }
     *     ]
     *   }
     * ]
     * ```
     */
    getUpdatedCells(rows: number[]): UpdatedRow[];
    /**
     * 필드의 중복되지 않은 값들을 반환한다.
     *
     * @remarks
     * 데이터 셋에서 지정된 필드에 해당하는 값들을 중복을 배제하여 정렬상태로 반환한다,
     *
     * @param field - 필드 명 또는 필드 인덱스
     * @param maxCount - 최대 건수, 정렬한 상태에서 위에부터 건수만큼 잘라서 반환한다. 기본값: `-1`
     * @param sortDir - 정렬 방법, 기본값: {@link SortDirection.ASCENDING}
     *
     * @example
     * ```js
     * ds.getDistinctValues('field1');
     * ```
     */
    getDistinctValues(field: string | number, maxCount?: number, sortDir?: SortDirection): any[];
    /**
     * 데이터 셋의 복구 시점을 기록한다.
     *
     * @remarks
     * 데이터 셋의 데이터및 상태를 복제하여 저장하고 포인트의 인덱스를 반환한다.
     * 이 후 {@link DataProviderBase.rollback | rollback()} 함수를 통해 특정 포인트로 돌아갈 수 있다.
     * @param saveStates - 상태 기록 여부
     *
     * @example
     * ```js
     * ds.savePoint([2, 4]);
     * ```
     */
    savePoint(saveStates?: boolean): number;
    /**
     * 데이터 셋을 복원한다
     *
     * @remarks
     * 데이터 셋의 데이터및 상태를 해당 포인트 시점으로 되돌린다.
     *
     * @param savePoint - 복구 포인트의 인덱스, 기본값: 0
     *
     * @example
     * ```js
     * ds.rollback();
     * ```
     */
    rollback(savePoint?: number): void;
    /**
     * 모든 복구시점을 제거한다.
     *
     * @remarks
     * 모든 복구 시점과 관련 저장한 데이터및 상태를 삭제한다.
     *
     * @example
     * ```js
     * ds.clearSavePoints();
     * ```
     */
    clearSavePoints(): void;
    /**
     * 모든 복구시점들을 반환한다.
     *
     * @remarks
     * 저장된 모든 복구시점들의 인덱스를 배열로 반환한다.
     *
     * @example
     * ```js
     * ds.getSavePoints([0, 1, 2]);
     * ```
     */
    getSavePoints(): number[];
    /**
     * 특정 필드의 정렬 함수를 설정한다.
     *
     * @remarks
     * 해당 필드의 정렬이 발생시 기본적으로 사용는 정렬 함수가 아닌 사용자 정의 정렬 함수를 설정한다.
     * 정렬 함수는 자바스크립트 Array.prototype.sort()의 compareFunction과 동일하다.
     * @param field - 정렬방식을 지정할 필드의 이름 또는 인덱스
     * @param comparer - 사용자 정의 정렬 함수
     * @example
     * ```js
     * dataProvider.setDataCompare('OrderID', function(field, row1, row2) {
     *   var val1 = dataProvider.getValue(row1, field);
     *   var val2 = dataProvider.getValue(row2, field);
     *   return val1 == val2 ? 0 : val1 > val2 ? 1 : -1;
     * }
     * ```
     */
    setDataComparer(field: string | number, comparer: CompareFunction): void;
    /**
     * 데이터 셋을 CSV파일로 내보낸다.
     *
     * @remarks
     * options의 설정에 따라 데이터 셋에 저장된 데이터를 CSV파일로 내보낸다.
     *
     * 이는 데이터 수준에서의 내보내기이므로 View 에서 설정하는 상태와는 무관하게 진행된다.
     *
     * @param options - 내보내기 설정
     *
     * @example
     * ```js
     * ds.exportToCsv();
     * ```
     */
    exportToCsv(options: DataExportOptions): void;
    /**
     * DataProvider 객체를 메모리에서 해제한다.
     *
     * @remarks
     * DataProvider내부에서 사용된 객체와 데이터등을 제거하고 가비지 콜렉팅이 되도록 한다.
     *
     * @example
     * ```js
     * ds.destroy();
     * ```
     */
    destroy(): void;
    /**
     * 이전에 수정한 내용을 되돌린다.
     *
     * @example
     * ```js
     * ds.undo();
     * ```
     */
    undo(): void;
    /**
     * 되돌린 내용을 취소한다.
     *
     * @example
     * ```js
     * ds.redo();
     * ```
     */
    redo(): void;
    /**
     * Command Stack 을 초기화한다.
     *
     * @example
     * ```js
     * ds.clearCommandStack();
     * ```
     */
    clearCommandStack(): void;



}

/**
 * 행 오브젝트 및 행 배열
 *
 * @remarks
 * {@link LocalDataProvider}, {@link LocalTreeDataProvider} 의 method 에서 다양하게 쓰인다.
 *
 * {@link RowObject} 또는 {@link RowValues} 이다.
 *
 * @example
 * ```js
 * // array
 * let row = ['value1', 'value2', 'value3']
 *
 * // object
 * let row = {field1: 'value1', field2: 'value2', field3: 'value3'}
 * ```
 */
export declare type DataValues = RowObject | RowValues;

/**
 * @public
 * 날짜 편집기
 *
 * @remarks
 * Date picker 를 표시해서 날짜를 선택한다.
 *
 * 달력 팝업에 표시되는 달력의 년, 월이나 요일의 표시 문구를 {@link GridBase.setEditorOptions} 나 {@link GridBase.editorOptions} 를 통해 개발자가 원하는 대로 바꿀 수 있다.
 *
 * (ex 월, 화, 수… == Mon, Tue, Wed…)
 *
 * {@link TextCellEditor}를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link CellEditor} - {@link TextCellEditor}
 *
 * @example
 * ```js
 * // string type
 * column.editor = "date"
 *
 * // object type
 * column.editor = { type: "date", maxLength: 6, yearNavigation: true }
 * ```
 */
export declare interface DateCellEditor extends TextCellEditor {


    /**
     * 입력 가능한 최소 날짜
     *
     * @remarks
     * 키보드로 minDate보다 이전 날짜가 입력되면, minDate로 변경된다.
     *
     * @defaultValue `new Date(1970, 0, 1)`
     */
    minDate?: string | Date;
    /**
     * 입력 가능한 최대 날짜
     *
     * @remarks
     * 키보드로 maxDate보다 이후 날짜가 입력되면, maxDate로 변경된다.
     *
     * @defaultValue `new Date(2100, 11, 31)`
     */
    maxDate?: string | Date;
    /**
     * 년도 이동 버튼 표시 여부
     *
     * @defaultValue `false`
     */
    yearNavigation?: boolean;
    /**
     * 키보드를 이용한 입력 금지 여부
     */
    textReadOnly?: boolean;
    /**
     * 달력 선택 상자의 위치
     *
     * @defaultValue {@link DropDownPosition.BUTTON}
     */
    dropDownPosition?: DropDownPosition;
    /**
     * 셀을 클릭했을 때 목록을 펼칠지의 여부
     *
     * @defaultValue `false`
     */
    dropDownWhenClick?: boolean;
    /**
     * `Today` 버튼 표시 여부
     *
     * @defaultValue `true`
     */
    showToday?: boolean;
    /**
     * 년에 대한 문구
     *
     * @defaultValue `'{Y}년'`
     */
    yearDisplayFormat?: string;
    /**
     * 월에 대한 문구
     *
     * @defaultValue `'{M}월'`
     */
    monthDisplayFormat?: string;
    /**
     * 월에 대한 표시 방법
     *
     * @remarks
     * 지정하면 {@link EditorOptions.months} 는 무시된다.
     */
    months?: string[];
    /**
     * 요일에 대한 표시 방법
     */
    weekDays?: string[];
    /**
     * 달력 연 주차 표시 여부
     *
     * @remarks
     * ISO 8601 기준으로 표시되나 날짜선택시 앞에 표시되고 있는 주차로 반환한다.
     *
     * @defaultValue `false`
     */
    showWeeks?: boolean;
    /**
     * 달력에서 시작되는 요일
     *
     * @remarks
     * 0: 일요일, 1: 월요일, ...
     *
     * @defaultValue `0`
     */
    startWeek?: number;
    /**
     * 년 주차 선택 가능 여부
     *
     * @defaultValue `false`
     */
    weekSelectable?: boolean;
    /**
     * 반환되는 결과의 년과 주차사이의 구분자
     *
     * @defaultValue `''`
     */
    weekSeparator?: string;
    /**
     * 선택 시 commit 여부
     *
     * @defaultValue `false`
     */
    commitOnSelect?: boolean;
    /**
     * 표시시 달력에 선택되는 날짜유형
     *
     * @defaultValue {@link DefaultShowDate.NORMAL}
     */
    defaultShowDate?: DefaultShowDate;
    /**
     * Date picker가 표시될때 선택될 날짜를 지정.
     *
     * @remarks
     * defaultShowDate가 {@link DefaultShowDate.DEFAULT} 또는 {@link DefaultShowDate.DEFAULT_WHEN_NULL}인 경우 선택되어 표시될 날짜
     *
     * @defaultValue `null`
     */
    defaultDate?: string | Date;
    /**
     * 표시되는 공휴일
     */
    holidays?: Holidays;
}

/**
 * 날짜로 지정하는 공휴일
 *
 * ```js
 *  {
 *      type : "date",
 *      dates : ["2020-01-24","2020-01-25","2020-01-26","2020-01-27"],
 *      styleName: "seollal",
 *      tooltips : ["설날1","설날2","설날3","설날4"]
 *  }
 * ```
 */
export declare interface DateHoliday {
    /**
     * 공휴일 유형
     */
    type?: "date";
    /**
     * 날짜들
     */
    dates?: string[];
    /**
     * 스타일 명
     */
    styleName?: string;
    /**
     * 툴팁들
     */
    tooltips?: string[];
    /**
     * 선택 가능 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
}

declare enum DateProperty {
    YEAR = 0,
    HALF = 1,
    QUARTER = 2,
    MONTH = 3,
    WEEK = 4,
    DAY = 5,
    HOUR = 6
}

/**
 * datetime 필드 변환시 수행 될 콜백함수 형식
 *
 * @remarks
 * {@link DataOutputOptions.datetimeCallback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `ds` - DataProvider 컨트롤
 *
 * `row` - 아이템의 인덱스
 *
 * `field` - 필드명
 *
 * `value` - 값
 *
 * [반환값] - 출력할 값
 *
 * @example
 * ```js
 * const f = function(ds, row, field, value) {
 *      if (value === 'today) {
 *          return new Date();
 *      }
 *      return new Date(value);
 * }
 * ```
 */
export declare type DatetimeOutputCallback = (ds: DataProviderBase, row: number, field: string, value: any) => Date | any;

/**
 * 요일로 지정하는 공휴일
 *
 * @example
 * ```js
 *  {
 *      type : "day",
 *      days : [0, 4],
 *      styleName: "custom-holiday",
 *      tooltips : ["쉬는 날","쉬는 날"]
 *  }
 * ```
 */
export declare interface DayHoliday {
    /**
     * 공휴일 유형
     */
    type: "day";
    /**
     * 요일들
     *
     * @remarks
     *
     * 월요일 부터 일요일까지 각각 0~6에 해당된다.
     */
    days: number[];
    /**
     * 스타일 명
     */
    styleName?: string;
    /**
     * 툴팁들
     */
    tooltips?: string[];
    /**
     * 선택 가능 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
}

/**
 * @public
 * 달력 편집기를 사용할 때, 달력에 표시되는 날짜 유형
 *
 * @remarks
 * {@link DateCellEditor} 에서 사용된다.
 *
 * @example
 * ```js
 * column.editor = { type: "date", maxLength: 6, yearNavigation: true, defaultShowDate: 'today' }
 * ```
 */
export declare enum DefaultShowDate {
    /**
     * 일반
     *
     * @remarks
     * 셀에 데이터가 있는 경우 해당일자, 없는 경우 이전에 popup된 날짜 또는 현재일자가 선택되어 표시된다.
     *
     */
    NORMAL = "normal",
    /**
     * 오늘
     *
     * @remarks
     * 현재 일자를 선택하여 표시한다.
     */
    TODAY = "today",
    /**
     * normal 의 동작과 같지만, 날짜가 없는 경우에만 현재 일자가 선택되어 표시되는 유형
     */
    TODAY_WHEN_NULL = "todayWhenNull",
    /**
     * 지정된 날짜
     *
     * @remarks
     * 지정된 날짜를 선택하여 표시한다.
     */
    DEFAULT = "default",
    /**
     * 셀에 데이터가 있는 경우 해당일자, 없는 경우 지정된 날짜가 선택되어 표시된다.
     */
    DEFAULT_WHEN_NULL = "defaultWhenNull"
}

/**
 * 그리드 수준에서 관리되는 표시 정보들에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setDisplayOptions({rowResizable: true});
 * ```
 */
export declare interface DisplayOptions {
    /**
     * 그리드를 다시 그릴 때의 모드
     *
     * @defaultValue {@link RefreshMode.ALL}
     */
    refreshMode?: RefreshMode;
    /**
     * 컬럼 너비 변경 가능 여부
     *
     * @remarks
     * 헤더 셀 우측을 드래그하여 변경 가능
     *
     * @defaultValue `true`
     */
    columnResizable?: boolean;
    /**
     * 컬럼 위치 변경 가능 여부
     *
     * @remarks
     * 헤더 셀을 드래그하여 변경 가능
     *
     * @defaultValue `true`
     */
    columnMovable?: boolean;
    /**
     * 컬럼 너비의 기본값
     *
     * @defaultValue `100`
     */
    defaultColumnWidth?: number;
    /**
     * 그리드의 너비에 맞춰 컬럼 너비를 조정하는지에 대한 양식
     *
     * @defaultValue {@link GridFitStyle.NONE}
     */
    fitStyle?: GridFitStyle;
    /**
     * fitStyle적용시 fixed도 영역도 포함할지 여부.
     *
     * @remarks
     *
     * {@link DisplayOptions.fitStyle}을 {@link GridFitStyle.EVEN | even} 또는 {@link GridFitStyle.EVEN_FILL | evenFill}로 설정하면 고정영역에 있는 컬럼들도 너비를 변경한다.
     *
     * {@link GridFitStyle.FILL}은 적용되지 않는다.
     *
     * @defaultValue `false`
     */
    fitStyleIncludeFixed?: boolean;
    /**
     * 전체적인 행 높이 조절 가능 여부
     *
     * @remarks
     * 첫 번째 컬럼의 셀 아래쪽이나 첫 번째 행의 인디케이터의 아래 쪽을 드래그하면 조정 할 수 있다.
     *
     * @defaultValue `false`
     */
    rowResizable?: boolean;
    /**
     * 각 행 높이 조절 가능 여부
     *
     * @remarks
     * 셀 아래쪽을 드래그하면 조정 할 수 있다.
     * {@link DisplayOptions.rowResizable}이 `true`여야 한다.
     *
     * @defaultValue `false`
     */
    eachRowResizable?: boolean;
    /**
     * {@link DisplayOptions.rowHeight | rowHeight} 속성이 변경될 때 개별 아이템마다 설정된 높이를 삭제할 지 여부
     *
     * @defaultValue `true`
     */
    autoClearHeights?: boolean;
    /**
     * {@link DisplayOptions.rowHeight | rowHeight}가 `-1`일때 그리드 스크롤시 표시되고 있는 행의 높이는 다시 찾지 않고 계산된 높이를 사용한다.
     *
     * @remarks
     * `false`로 설정하면 행이 화면에 표시될때 다시 높이를 계산한다. 화면에 많은 행이 표시되면 속도가 느려질수 있다.
     *
     * @defaultValue `true`
     */
    refCalcHeights?: boolean;
    /**
     * 행 높이
     *
     * @remarks
     * 0 이면 그리드의 폰트와 Padding 스타일을 고려해서 적절한 값으로 행들의 높이를 찾는다.
     * 0 보다 큰 값이면 지정한 값이 행들의 높이가 된다.
     * `-1` 이면 셀의 내용에 따라 행의 높이를 변경한다.
     *
     *
     * @defaultValue `0`
     */
    rowHeight?: number;
    /**
     * Table 행 최소 높이
     *
     * @defaultValue `23`
     */
    minTableRowHeight?: number;
    /**
     * 행 최소 높이
     *
     * @defaultValue `23`
     */
    minRowHeight?: number;
    /**
     * 행 최대 높이
     *
     * @defaultValue `0`
     */
    maxRowHeight?: number;
    /**
     * 셀 최소 너비
     *
     * @defaultValue `8`
     */
    minCellWidth?: number;
    /**
     * 수평 스크롤 바 표시 여부
     *
     * @defaultValue `true`
     */
    hscrollBar?: boolean;
    /**
     * 수직 스크롤 바 표시 여부
     *
     * @defaultValue `true`
     */
    vscrollBar?: boolean;
    /**
     * 스크롤바의 track-thumb을 이용한 스크롤시 즉시 스크롤 여부
     *
     * @remarks
     * `false`이면 마우스버튼을 놓았을때 스크롤한다.
     *
     * @defaultValue `true`
     */
    liveScroll?: boolean;
    /**
     * 수직 스크롤시 tooltip 표시 지연 시간
     *
     * @remarks
     * 스크롤바의 track-thumb를 이용한 스크롤시 tooltip의 발생을 지연시킨다.
     *
     * {@link DisplayOptions.liveScroll | liveScroll}이 `false`인 경우만 적용된다.
     *
     * @defaultValue `0` (ms)
     */
    scrollDuration?: number;
    /**
     * 수평 스크롤시 tooltip 표시 지연 시간
     *
     * @remarks
     * 스크롤바의 track-thumb를 이용한 스크롤시 tooltip의 발생을 지연시킨다.
     *
     * {@link DisplayOptions.liveScroll | liveScroll}이 `false`인 경우만 적용된다.
     *
     * @defaultValue `0` (ms)
     */
    hscrollDuration?: number;
    /**
     * 툴팁 지연 시간
     *
     * @defaultValue `0` (ms)
     */
    hintDelay?: number;
    /**
     * 데이터 행 위치 변경의 지연 시간
     *
     * @remarks
     * {@link GridBase.onCurrentRowChanged | onCurrentRowChanged} 를 지연시킨다.
     *
     * @defaultValue `0` (ms)
     */
    rowChangeDelay?: number;
    /**
     * 키보드로 컬럼 이동시 page단위 스크롤
     *
     * @defaultValue `false`
     */
    horzPageScroll?: boolean;
    /**
     * 그리드에 표시되는 데이터 행이 한 건도 없을 때 표시되는 메세지
     *
     * @defaultValue `'이 곳에 표시할 메시지를 DisplayOptions.emptyMessage 속성으로 설정합니다.'`
     */
    emptyMessage?: string;
    /**
     * 그리드에 표시되는 데이터 행이 한 건도 없을 때 메시지 표시 여부
     *
     * @defaultValue `false`
     */
    showEmptyMessage?: boolean;
    /**
     * focus의 보임 여부
     *
     * @defaultValue `true`
     */
    focusVisible?: boolean;
    /**
     * focus의 형태
     *
     * @defaultValue `layer`
     */
    focusType?: FocusType;
    /**
     * focus 된 행의 마스크 종류
     *
     * @defaultValue {@link RowMaskType.NONE}
     */
    rowFocusType?: RowMaskType;
    /**
     * focus된 셀이 그룹layout의 하위 셀일때 그룹layout에 focus를 표시한다.
     *
     * @remarks
     * 최상위 그룹layout만 해당한다.
     *
     * @defaultValue `false`
     */
    groupFocusVisible?: boolean;
    /**
     * 휠 가능 여부
     *
     * @defaultValue `true`
     */
    wheelEnabled?: boolean;
    /**
     * 한 번에 스크롤 되는 행 갯수
     *
     * @defaultValue `3`
     */
    wheelScrollLines?: number;
    /**
     * 휠로 수평 스크롤 했을 때 위치 이동 변동 값 (속도)
     *
     * @defaultValue `16`
     */
    wheelScrollHorz?: number;
    /**
     * 수직 스크롤 시 가속을 위한 최소 시간
     *
     * @remarks
     * {@link DisplayOptions.wheelAccelScroll | wheelAccelScroll} 과 함께 사용한다.
     *
     * @defaultValue `0`
     */
    wheelAccelDelay?: number;
    /**
     * {@link DisplayOptions.wheelAccelDelay | wheelAccelDelay} 만큼이 지연 되었을 경우, 해당 속성 만큼 스크롤을 가속한다.
     *
     * @remarks
     * 숫자 - 아이템 개수
     *
     * 문자열 - 백분율 ex) `'50%'`
     *
     * @defaultValue `null`
     */
    wheelAccelScroll?: number | string;
    /**
     * touchPad를 이용한 스크롤시 민감도를 조정한다.
     *
     * @remarks
     * touchPad의 경우 약간의 움직임만 있어도 스크롤되던것을 지정된 숫자만큼의 움직임이 있어야 스크롤되도록 한다.
     *
     * `10` ~ `20` 정도의 값이 적당하다.
     *
     * 세로스크롤에만 적용된다.
     *
     * @defaultValue `0`
     */
    wheelDeltaY?: number;
    /**
     * 그리드 내 발생한 휠 이벤트 외부 방출 여부
     *
     * @defaultValue `true`
     */
    wheelEventPropagate?: boolean;
    /**
     * 마우스 오른쪽 버튼 사용 가능 여부
     *
     * @defaultValue `true`
     */
    rightClickable?: boolean;
    /**
     * 컬럼 위치가 변경됐을 때 병합을 다시 시도할 지 여부.
     *
     * @defaultValue `true`
     */
    remergeWhenColumnMoved?: boolean;
    /**
     * Merged Row Grouping 또는 Cell Merging상태에서 셀 편집시 편집 중인 행의 merge 여부.
     * `true`이면 merge상태를 유지한다.
     *
     * @defaultValue `false`
     */
    editItemMerging?: boolean;
    /**
     * Merged Cell에서 개별 셀 영역 표시 여부
     *
     * @defaultValue `true`
     */
    showInnerFocus?: boolean;
    /**
     * 표시되는 Toast 창의 zIndex 지정
     *
     * @defaultValue `3000`
     */
    toastZIndex?: number;
    /**
     * 팝업이나 컨텍스트 메뉴에 한 화면에 표시되는 목록들의 개수
     *
     * @defaultValue `0`
     */
    popupDropdownCount?: number;
    /**
     * 선택 영역의 모드
     *
     * @remarks
     * {@link SelectionMode.EXTENDED | 다중선택}인경우 `rowMove`, `copy`를 지원하지 않는다.
     *
     * @defaultValue {@link SelectionMode.SINGLE}
     */
    selectionMode?: SelectionMode;
    /**
     * 선택 영역의 스타일
     *
     * @remarks
     * 자세한 설명은 {@link SelectionStyle} 참조
     *
     * @defaultValue {@link SelectionStyle.BLOCK}
     */
    selectionStyle?: SelectionStyle;
    /**
     * 선택 영역의 디스플레이
     * @remarks
     * 자세한 설명은 {@link SelectionDisplay} 참조
     *
     * @defaultValue {@link SelectionDisplay.CELL}
     */
    selectionDisplay?: SelectionDisplay;
    /**
     * `true`이면 셀을 선택한 후 바로 drag&drop 모드로 변경한다.
     *
     * @remarks
     * {@link DisplayOptions.selectionStyle}이 `column`인 경우는 적용되지 않는다.
     *
     * @defaultValue `false`
     */
    selectAndImmediateDrag?: boolean;
    /**
     * {@link DisplayOptions.selectionStyle}이 {@link SelectionStyle.BLOCK} 이거나 {@link SelectionStyle.GROUP}일 때 여러행 선택 가능 여부
     *
     * @remarks
     * `false`이면 한행에서만 Selection이 가능하다.
     *
     * @defaultValue `false`
     */
    selectAtSingleRow?: boolean;
    /**
     * 행 hover 시 마스크 종류
     *
     * @remarks
     * hovering 시 행 선택 영역 표시를 보여준다.
     *
     * @defaultValue {@link RowMaskType.NONE}
     */
    rowHoverType?: RowMaskType;
    /**
     * 행 선택 시 마스크 종류
     *
     * @remarks
     * 행 및 셀 선택시 행 선택 영역 표시를 보여준다.
     *
     * @defaultValue {@link RowMaskType.NONE}
     */
    rowBlockType?: RowMaskType;
    /**
     * 사용자 지정 {@link DisplayOptions.rowBlockType | rowBlockType} 을 설정하기 위한 콜백
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * const f = function(grid, itemIndex) {
     *     let billNo;
     *     let ds = grid.getDataSource();
     *     let fld = ds.getFieldIndex("text1");
     *     let dataRow = grid.getDataRow(itemIndex);
     *     if (dataRow >= 0) {
     *         billNo = ds.getValue(dataRow, fld);
     *     } else {
     *         billNo = null;
     *     }
     *
     *     let top = Math.min(grid.getTopItem(), itemIndex);
     *     let full = top + grid.fullItemCount();
     *     let startNo = top + full;
     *     let endNo = -1;
     *     let check1 = false;
     *
     *     for (let i = top; i <= full; i++) {
     *         dataRow = grid.getDataRow(i);
     *         if (dataRow < 0) {
     *             continue;
     *         }
     *
     *         let cBillNo = ds.getValue(dataRow, fld);
     *
     *         if (cBillNo === billNo) {
     *             startNo = Math.min(startNo, i), endNo = Math.max(endNo, i);
     *             check1 = true;
     *         } else {
     *             if (check1) {
     *                 break;
     *             }
     *         }
     *     };
     *
     *     if (startNo <= endNo && endNo > 0) {
     *         console.log(startNo)
     *         console.log(endNo);
     *         return { start: startNo, end: endNo };
     *     }
     * }
     *
     * grid.setDisplayOptions = {
     *      rowBlockType: 'row,
     *      rowBlockCallback: f
     * }
     * ```
     */
    rowBlockCallback?: RowBlockCallback;
    /**
     * 데이터와 무관하게 툴팁을 보여줄 건지에 대한 여부
     *
     * @remarks
     * `true`시 {@link GridBase.onShowTooltip | onShowTooltip()} 발생
     *
     * @defaultValue `false`
     */
    showEmptyTooltip?: boolean;
    /**
     * 마커 변경을 보여줄지에 대한 여부
     *
     * @defaultValue `true`
     */
    showChangeMarker?: boolean;
    /**
     * `liveScroll`이 `false`일 때 스크롤 위치를 알려주는 view에 표시되는 메세지를 반환하는 콜백
     *
     * @remarks
     * {@link ScrollMessageCallback} 의 형식이다.
     *
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.displayOptions.scrollMessageCallback = function(grid, vertical, itemIndex) {
     *     var msg = grid.getValue(itemIndex, "area3name");
     *     return "<span style='color:blue;font-size:20px'>itemIndex = " + msg+"</span>";
     * }
     * ```
     */
    scrollMessageCallback?: ScrollMessageCallback;
    /**
     * Native 드랍다운 편집기(date, list)일 때 셀 우측에 edit button을 표시할 것인 지 여부.
     *
     * @defaultValue `false`
     */
    showNativeEditButton?: boolean;
    /**
     * editor / editorButton 의 zIndex를 설정한다.
     *
     * @defaultValue `2000`
     */
    baseZindex?: number;
    /**
     * 짝수행의 className에 "rg-alternate-row" 추가를 설정한다.
     *
     * @defaultValue `true`
     */
    useAlternateRowStyle?: boolean;
    /**
     * focus된 셀과 row의 class명을 설정한다.
     *
     * @remarks
     * `true`이면 focus된 셀의 className에 `rg-focused-cell`을 추가한다.
     * Row의 className에 `rg-focused-row`를 추가한다.
     *
     * @defaultValue `false`
     */
    useFocusClass?: boolean;
    /**
     * container의 display가 변경되는 경우 자동으로 화면을 갱신
     *
     * @remarks
     * 그리드 상위element의 display가 변경되면 자동으로 화면을 갱신한다.
     *
     * @defaultValue `true`
     */
    watchDisplayChange?: boolean;
    /**
     * data가 모두 화면에 보이도록 그리드 컨테이너의 높이를 변경한다.
     *
     * @remarks
     * 표시되는 data의 건수가 많은 경우 속도가 느려질수 있다.
     * 그리드가 생성되기 전에 그리드 컨테이너의 높이가 지정되어야 원래 크기로 돌아갈수 있다.
     *
     * {@link DisplayOptions.rowHeight | rowHeight}가 -1인경우 적용되지 않는다.
     *
     * @defaultValue {@link SyncGridHeight.NONE}
     */
    syncGridHeight?: SyncGridHeight;

}

/**
 * @public
 * {@link GridExportOptions} 모델과 {@link GridBase.exportGrid} 를 사용하여 그리드를 내보내기 할 때, Excel 문서의 제목, 부제, 꼬릿말을 설정하기 위한 모델
 *
 * @remarks
 * {@link GridExportOptions.documentTitle}, {@link GridExportOptions.documentSubtitle | documentSubtitle}, {@link GridExportOptions.documentTail | documentTail} 에서 사용된다.
 */
export declare interface DocumentTitle {
    /**
     * 설정할 메시지 (제목) 내용
     *
     * @defaultValue `''`
     */
    message: string;
    /**
     * 엑셀에 출력 여부
     *
     * @defaultValue `true`
     */
    visible: boolean;
    /**
     * 윗 여백 (행)
     *
     * @defaultValue `0`
     */
    spaceTop: number;
    /**
     * 아래 여백 (행)
     *
     * @defaultValue `0`
     */
    spaceBottom: number;
    /**
     * 제목의 전체 높이
     *
     * @remarks
     * 높이를 지정하지 않으면 (`-1`이면) 1행으로 표시된다.
     *
     * @defaultValue `-1`
     */
    height: number;
    /**
     * 셀들에게 적용할 스타일들
     */
    styles?: string;
    /**
     * title에 적용될 className
     * @remarks
     * styleName이 설정되면 styles는 적용되지 않는다.
     */
    styleName?: string;
}

/**
 * @public
 * mouse가 over 될때 drop 되는 위치를 보여주는 feedback의 style
 *
 */
export declare enum DragFeedbackStyle {
    /**
     * Line
     *
     * 드랍되는 행의 위 또는 아래에 line형태로 표시
     */
    LINE = "line",
    /**
     * Block or Row
     *
     * 드랍되는 행에 overlay되는 block형태로 표시
     */
    ROW = "row",
    /**
     *
     */
    CELL = "cell",
    /**
     * 드랍되는 컬럼 Group셀에 overlay되는 block형태로 표시.
     */
    GROUP = "group"
}

/**
 * @public
 * 목록으로 수정할 수 있는 편집기 (dropdown 편집기)
 *
 * @remarks
 * dropdown 편집기의 {@link DropDownCellEditor.values | values} 속성으로 지정된 목록 중 한 값을 선택하여 편집한다.
 *
 * {@link DropDownCellEditor.labels | labels}에 {@link DropDownCellEditor.values | values} 대신 dropdown 리스트에 표시될 텍스트들을 지정할 수 있다.
 *
 * {@link TextCellEditor} 를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link CellEditor} - {@link TextCellEditor}
 *
 * [하위 클래스]
 *
 * {@link SearchCellEditor}
 *
 * {@link MultiCheckCellEditor}
 *
 * @example
 *
 * ```js
 * // string type
 * column.editor = "list"
 *
 * // object type
 * column.editor = {
 *      type: "list",
 *      values: ["VINET", "TOMSP", "VICTE"],
 *      labels: ['label1', 'label2', 'label3'],
 *      displayLabels: "valueLabel",
 *      textReadOnly: true
 * }
 * ```
 */
export declare interface DropDownCellEditor extends TextCellEditor {

    /**
     * 목록의 실제 값들
     */
    values?: any[];
    /**
     * 목록의 표시 값들
     */
    labels?: any[];
    /**
     * label 을 보여주는 방식
     *
     * @defaultValue {@link DropDownValueLabel.LABEL}
     */
    displayLabels?: DropDownValueLabel;
    /**
     * 키보드를 이용한 입력 금지 여부
     */
    textReadOnly?: boolean;
    /**
     * 목록에 있는 값들만 지정할 수 있는지의 여부
     *
     * @remarks
     * `true` 시 목록 외의 값은 지정 할 수 없다.
     *
     * @defaultValue `false`
     */
    domainOnly?: boolean;
    /**
     * 목록 선택 상자의 너비
     */
    dropDownWidth?: number;
    /**
     * 목록 선택 상자의 위치
     *
     * @defaultValue {@link DropDownPosition.EDITOR}
     */
    dropDownPosition?: DropDownPosition;
    /**
     * 목록 아이템들의 개수
     */
    dropDownCount?: number;
    /**
     * 목록의 정렬 방식
     * @defaultValue {@link DropDownSortStyle.NONE}
     */
    itemSortStyle?: DropDownSortStyle;
    /**
     * 키 입력 시 대소문자 구분 여부
     *
     * @defaultValue `false`
     */
    caseSensitive?: boolean;
    /**
     * 한글 초성 입력 시 해당 값으로 이동 여부
     *
     * @defaultValue `false`
     */
    partialMatch?: boolean;
    /**
     * 목록을 선택하였을 때 commit 여부
     *
     * @defaultValue `true`
     */
    commitOnSelect?: boolean;
    /**
     * 셀을 클릭했을 때 목록을 펼칠지의 여부
     *
     * @defaultValue `false`
     */
    dropDownWhenClick?: boolean;
    /**
     * 목록의 텍스트들 trim 여부
     *
     * @defaultValue `true`
     */
    trimLabelText?: boolean;
    /**
     * {@link DropDownCellEditor.displayLabels | displayLabels} 속성이 {@link DropDownValueLabel.VALUE_LABEL}, {@link DropDownValueLabel.LABEL_VALUE} 인 경우, 두 값들 사이의 구분자
     *
     * @defaultValue `null`
     */
    separator?: string;
    /**
     * {@link DropDownCellEditor.displayLabels | displayLabels} 속성이 {@link DropDownValueLabel.VALUE_LABEL}, {@link DropDownValueLabel.LABEL_VALUE} 인 경우, 두 값들 사이 여백의 자동 조절 후 정렬 여부
     *
     * @defaultValue `false`
     */
    itemColumned?: boolean;
}

/**
 * {@link DropDownCellEditor.dropDownPosition | DropDownCellEditor} 의 목록 또는 {@link DateCellEditor.dropDownPosition | DateCellEditor}, {@link BTDateCellEditor.dropDownPosition | BTDateCellEditor} 달력 선택 상자의 위치
 *
 * @example
 * ```js
 * column.editor = {
 * 		type: 'list',
 * 		values: ['value1', 'value2'],
 * 		dropDownPosition: 'editor'
 * }
 * ```
 */
export declare enum DropDownPosition {
    /**
     * 버튼에 맞추어 정렬
     */
    BUTTON = "button",
    /**
     * 편집기에 맞추어 정렬
     */
    EDITOR = "editor"
}

/**
 * {@link DropDownCellEditor} 목록의 정렬 방식
 *
 * @example
 * ```js
 * column.editor = {
 * 		type: 'list',
 * 		values: ['value1', 'value2'],
 * 		itemSortStyle: 'descending'
 * }
 * ```
 */
export declare enum DropDownSortStyle {
    /**
     * 지정 안함
     */
    NONE = "none",
    /**
     * 오름차순
     */
    ASCENDING = "ascending",
    /**
     * 내림차순
     */
    DESCENDING = "descending"
}

/**
 * {@link DropDownCellEditor} 의 목록을 보여주는 방법
 *
 * @example
 * ```js
 * column.editor = {
 * 		type: 'list',
 * 		values: ['value1', 'value2'],
 * 		labels: ['label1', 'label2'],
 * 		displayLabels: 'valueLabel'
 * }
 * ```
 */
export declare enum DropDownValueLabel {
    /**
     * value 값만
     */
    VALUE = "value",
    /**
     * label 값만
     */
    LABEL = "label",
    /**
     * value - label 순서쌍
     */
    VALUE_LABEL = "valueLabel",
    /**
     * label - value 순서쌍
     */
    LABEL_VALUE = "labelValue"
}

/**
 * 그리드 간 drag and drop 으로 이동 / 복사를 할 때 적용되는 규칙을 반환하는 콜백 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `source` - 드래그한 아이템이 있던 GridBase 컨트롤
 *
 * `sourceItems` - 드래그한 그리드의 아이템들의 인덱스
 *
 * `target` - 드랍할 GridBase 컨트롤
 *
 * `targetItem` - 드랍할 그리드에서의 아이템 인덱스
 *
 * `targetColumn` - 드랍할 그리드에서의 targetColumn
 *
 * [반환값] - {@link FieldMap} 오브젝트
 *
 * @example
 * ```js
 * gridView.dataDropOptions.fieldMapCallback = function (source, sourceItems, target, targetItem) {
 *     if (targetItem % 2 == 0) {
 *         return {
 *             Country: "Country",
 *             CompanyName: "ShipAddress",
 *             EmployeeID: "ShipPostalCode"
 *         }
 *     }
 * }
 * ```
 */
export declare type DropFieldMapCallback = (source: GridBase, sourceItems: number[], target: GridBase, targetItem: number, targetColumn: string) => FieldMap;

/**
 * @public
 *
 * edgeMark
 *
 * @remarks
 * {@link ValueColumn.edgeMark}에서 사용된다.
 *
 * @example
 * ```js
 * column.edgeMark = "leftTop"
 * ```
 */
export declare const enum EdgeMark {
    /**
     * 왼쪽 위
     */
    LEFT_TOP = "leftTop",
    /**
     * 왼쪽 아래
     */
    LEFT_BOTTOM = "leftBottom",
    /**
     * 오른쪽 위
     */
    RIGHT_TOP = "rightTop",
    /**
     * 오른쪽 아래
     */
    RIGHT_BOTTOM = "rightBottom"
}

/**
 * @public
 *
 * {@link GridBase.getEditingItem} 에서 반환되는 오브젝트 형식
 */
export declare interface EditingItemInfo {
    /**
     * 행의 인덱스 (순서)
     */
    itemIndex: number;
    /**
     * 행의 고유번호
     */
    dataRow: number;
    /**
     * 해당 행의 값들
     */
    values: {
        [fieldName: string]: string;
    };
}

/**
 * @public
 * 텍스트나 날짜 필드에 적용할 수 있는 편집기의 표시 형식
 *
 * @remarks
 * {@link ValueColumn.editor} 를 적용할 때, 에디터의 {@link TextCellEditor.mask | mask} 속성에서 사용된다.
 *
 * 숫자 필드는 {@link NumberCellEditor.editFormat} 을 사용한다.
 *
 * 마크스에 적용된 형식은 편집기에만 표시된다.
 *
 * {@link DropDownCellEditor | dropDown}, {@link MultiLineCellEditor | multiLine}, {@link MultiCheckCellEditor | multiCheck}, {@link NumberCellEditor | number Editor} 에서는 동작하지 않는다.
 *
 *
 * @example
 * ```js
 * // string
 * column.editor = {
 *      type: 'line',
 *      mask: '9999-99-99'
 * }
 *
 * // object
 * column.editor = {
 *      type: 'line',
 *      mask: {
 *          editMask: '9999-99-99',
 *          placeHolder: 'input...'
 *      }
 * }
 * ```
 */
export declare type EditMask = EditMaskObject | string;

/**
 * @public
 * 텍스트나 날짜 필드에 적용할 수 있는 편집기의 오브젝트 형태 표시 형식
 *
 * @remarks
 * {@link ValueColumn.editor} 를 적용할 때, 에디터의 {@link TextCellEditor.mask | mask} 속성에서 사용된다.
 *
 * 숫자 필드는 {@link NumberCellEditor.editFormat} 을 사용한다.
 *
 * 마크스에 적용된 형식은 편집기에만 표시된다.
 *
 * {@link DropDownCellEditor | dropDown}, {@link MultiLineCellEditor | multiLine}, {@link MultiCheckCellEditor | multiCheck}, {@link NumberCellEditor | number Editor} 에서는 동작하지 않는다.
 *
 * @example
 * ```js
 * column.editor = {
 *      type: 'line',
 *      mask: {
 *          editMask: '9999-99-99',
 *          placeHolder: 'input...'
 *      }
 * }
 * ```
 */
export declare interface EditMaskObject {
    /**
     * 편집기에 표시된 내용이 그대로 셀 값으로 전달되는지의 여부
     *
     * @defaultValue `false`
     */
    includedFormat: boolean;
    /**
     * 편집기의 placeHolder
     */
    placeHolder: string;
    /**
     * "0000-00-00" 등으로 표시되는 형식
     *
     * @remarks
     * 기본적으로 제공하는 형식은 다음의 정규식과 같다.
     *
     * `9`: `new RegExp("[0-9 ]")`
     *
     * `0`: `new RegExp("[0-9]")`
     *
     * `a`: `new RegExp("[A-Za-z]")`
     *
     * `*`: `new RegExp("[A-Za-z0-9]")`
     */
    editMask: string;
    /**
     * 정의 되어있는 마스크 형식
     *
     * @remarks
     * 기본적으로 제공되는 "9", "0", "a", "*" 외에 개발자가 추가로 정의하고 싶은 경우나 수정하고 싶은 경우 사용한다.
     *
     * @example
     * ```js
     * definitions: {"h": "[a-h]"} //"h"는 a~h까지 입력 가능하다.
     * ```
     */
    definitions: any;
    /**
     * 잘못된 형식이 입력되었을 때 표시할 메세지
     */
    invalidFormatMessage: string;
    /**
     * 잘못된 형식이 입력되었을때 메시지 표시 유무
     */
    showInvalidFormatMessage: boolean;
    /**
     * 입력시 기존 문자를 덮어쓰기 여부
     *
     * @defaultValue `false`
     */
    overWrite: boolean;
    /**
     * mask 가 0로 설정된 경우 빈값 `''`의 허용 여부
     */
    allowEmpty: boolean;
    /**
     * 중간부터 입력 중단 여부
     *
     * @defaultValue `false`
     */
    restrictNull: boolean;
}

/**
 * 그리드에서의 데이터 편집에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setEditOptions({editable: false});
 * ```
 */
export declare interface EditOptions {
    /**
     * 그리드 수준에서 데이터 셀의 값 수정 금지 여부
     *
     * @remarks
     * 각 컬럼에서 지정한 readOnly 값 또한 false 여야 수정 가능하다.
     *
     * @defaultValue `false`
     *
     */
    readOnly?: boolean;
    /**
     * 그리드의 데이터 수정 가능 여부
     *
     * @remarks
     * 각 컬럼에서 지정한 readOnly 값 또한 false 여야 수정 가능하다.
     *
     * @defaultValue 모바일: `false`, 그외: `true`
     */
    editable?: boolean;
    /**
     * column.editable과 editOptions.editable의 적용순서 변경
     *
     * @remarks
     * `true`이면 column.editable이 설정된경우 editOptions.editable은 무시된다.
     *
     * @defaultValue `false`
     */
    columnEditableFirst?: boolean;
    /**
     * 행의 Checked 상태 변경 가능 여부
     *
     * @remarks
     * `true` 시 CheckBar Cell 을 클릭하여 변경 가능
     *
     * @defaultValue `true`
     */
    checkable?: boolean;
    /**
     * 그리드의 데이터 수정 가능 여부
     *
     * @remarks
     * `true` 면 그리드의 데이터들을 수정 할 수 있다.
     * `false` 면 기존 데이터는 수정할 수 없고 {@link GridBase.commit | commit() } 되기 전 새로 추가된 행만 수정 가능하다.
     *
     * @defaultValue `true`
     */
    updatable?: boolean;
    /**
     * 행 추가 가능 여부
     *
     * @remarks
     * 그리드 마지막행에서 방향키로 추가 가능
     *
     * @defaultValue `false`
     */
    appendable?: boolean;
    /**
     * 행 삽입 가능 여부
     *
     * @remarks
     * `true` 시 Insert 키를 눌러 행 삽입 가능
     *
     * @defaultValue `false`
     */
    insertable?: boolean;
    /**
     * 행 삭제 가능 여부
     *
     * @remarks
     * `true` 시 사용자가 Ctrl+Del 키를 누르거나 {@link GridBase.deleteSelection | deleteSelection()} 을 호출해서 현재 선택된 행을 삭제할 수 있다.
     * `deleteSelection(true)` 와 같이 호출하면 해당 옵션과 상관없이 삭제할 수 있다.
     *
     * @defaultValue `false`
     */
    deletable?: boolean;
    /**
     * 삭제 취소 가능 여부
     *
     * @remarks
     * {@link DataProviderBase.softDeleting | dataProvider.softDeleting} == true 인 경우, 삭제 상태인 행들을 ctrl+shift+del 키 입력시 원래 상태로 되돌릴 수 있다.
     *
     * @defaultValue `false`
     */
    revertable?: boolean;
    /**
     * 선택 영역에 포함된 셀 삭제 가능 여부
     *
     * @defaultValue `false`
     */
    erasable?: boolean;
    /**
     * 행 이동 가능 여부
     *
     * @remarks
     * sorting된 상태인경우 이동할수 없다.
     * 트리의 경우 동일 노드내에서만 이동가능
     *
     * @defaultValue `false`
     */
    movable?: boolean;
    /**
     * 셀 단위 수정 후 commit 여부
     *
     * @defaultValue `false`
     */
    commitByCell?: boolean;
    /**
     * 셀 focus 시 편집기 표시 여부
     *
     * @defaultValue `false`
     */
    editWhenFocused?: boolean;
    /**
     * 셀이 편집되지 않아도 commit 할지의 여부
     *
     * @defaultValue `false`
     */
    commitWhenNoEdit?: boolean;
    /**
     * Tab 이나 Enter 키로 셀을 벗어날 때 행을 commit 할지의 여부
     *
     * @defaultValue `false`
     */
    commitWhenExitLast?: boolean;
    /**
     * focus가 그리드를 벗어날때 그리드를 commit 할지의 여부
     *
     * @defaultValue `false`
     */
    commitWhenLeave?: boolean;
    /**
     * Tab이 이나 Enter 키로 마지막 셀을 벗어날 때 다음 행으로 이동할지의 여부
     *
     * @defaultValue `false`
     */
    crossWhenExitLast?: boolean;
    /**
     * 셀 편집이 완료될 때 컬럼 Validation 실행 여부
     *
     * @defaultValue `true`
     */
    validateOnEdited?: boolean;
    /**
     * 셀에서 벗어날 때 컬럼 Validation 실행 여부
     *
     * @defaultValue `false`
     */
    validateOnExit?: boolean;
    /**
     * 편집 중에 에러가 있는 셀에 마우스가 위치할 때 에러 힌트 툴팁 표시 여부
     *
     * @defaultValue `true`
     */
    hintOnError?: boolean;
    /**
     * 삭제 대화 상자에 표시할 메세지
     *
     * @defaultValue `'선택된 행(들)을 삭제하시겠습니까??'`
     */
    deleteRowsMessage?: string;
    /**
     * mask 에서 지정한 형태가 아닐 때 표시할 오류 메시지
     *
     * @defaultValue `'잘못된 입력 유형입니다.'`
     */
    invalidFormatMessage?: string;
    /**
     * mask 에서 지정한 형태가 아닐 때 오류 메시지를 보여줄 것인지의 여부
     *
     * @defaultValue `true`
     */
    showInvalidFormatMessage?: boolean;
    /**
     * 삭제 여부를 묻는 대화 상자의 호출 여부
     *
     * @remarks
     * true시 사용자 삭제나 {@link GridBase.deleteSelection | deleteSelection()} 실행할 때 삭제 여부를 묻는 대화 상자를 먼저 호출한다.
     * GridView.deleteSelection(true)로 호출하면 대화 상자 표시 없이 바로 삭제한다.
     *
     * @defaultValue `true`
     */
    confirmWhenDelete?: boolean;
    /**
     * 선택된 셀을 클릭했을 시 편집기 표시 여부
     *
     * @defaultValue `false`
     */
    editWhenClickFocused?: boolean;
    /**
     * 행 편집을 완료할 수 있는 최상위 ValidationLvel
     *
     * @defaultValue {@link ValidationLevel.IGNORE}
     */
    commitLevel?: ValidationLevel;
    /**
     * Tab 키로 셀 이동 가능 여부
     *
     * @defaultValue `true`
     */
    useTabKey?: boolean;
    /**
     * 방향키로 셀 이동 가능 여부
     *
     * @defaultValue `true`
     */
    useArrowKeys?: boolean;
    /**
     * 컬럼간 이동시 readOnly 셀을 건너뛰고 이동할지에 대한 여부.
     *
     * @defaultValue `false`
     */
    skipReadOnly?: boolean;
    /**
     * 한 컬럼에서 행 간 이동시 readOnly 셀을 건너뛰고 이동할지에 대한 여부.
     *
     * @defaultValue `false`
     */
    skipReadOnlyCell?: boolean;
    /**
     * 컬럼 그룹의 컬럼 셀을 위나 아래로 이동시 동작 방법
     *
     * @remarks
     * 'row' 또는 'cell'이다.
     *
     * @defaultValue `'row'`
     */
    verticalMoveStep?: VerticalMoveStep;
    /**
     * 셀 편집 중 Enter 키를 입력하면 편집을 완료하고 다음 셀로 이동할지의 여부
     *
     * @remarks
     * enterToNextRow == true 시 다음 행으로 이동
     *
     * @defaultValue `false`
     */
    enterToTab?: boolean;
    /**
     * 셀 편집 중 Enter 키를 입력하면 편집을 완료하고 다음 행으로 이동할지의 여부
     *
     * @defaultValue `false`
     */
    enterToNextRow?: boolean;
    /**
     * focus된 셀이 편집상태가 아닐때 Enter키 를 입력하면 편집상태로 변경한다.
     *
     * @remarks
     * enterToNextRow가 `true` 인경우에는 편집상태로 변경하지 않고 다음 `row`로 이동한다.
     *
     * @defaultValue `false`
     */
    enterToEdit?: boolean;
    /**
     * 지정한 자리수 만큼 입력되면 다음 셀로 이동할지의 여부
     *
     * @remarks
     * column.editor.maxLength에 지정한 자리수 만큼 입력되면 다음 셀로 이동된다.
     * editFormat이 있는 경우 보여지는 글자를 기준으로 maxLength가 체크된다. (numberEditor, dateEditor)
     * multiLine의 경우 `\n`과 같이 제어문자도 글자수에 포함된다.
     * editOptions.skipReadOnly가 true 인 경우 readOnly인 셀은 건너뛴다.
     *
     * @defaultValue `false`
     */
    maxLengthToNextCell?: boolean;
    /**
     * 변경된 내용이 없어도 Inserting 상태에서 항상 commit 할 건지의 여부
     *
     * @defaultValue `false`
     */
    forceInsert?: boolean;
    /**
     * 변경된 내용이 없어도 Appending 상태에서 항상 commit 할 건지의 여부
     *
     * @defaultValue `false`
     */
    forceAppend?: boolean;
    /**
     * 행 편집 완료 시 실제 셀이 변경 되었을 때 상태 변경 확인 여부
     *
     * @remarks
     * `true` 시 행 편집 완료 요청 시 실제 변경된 셀이 하나라도 있어야 완료된다.
     * 그렇지 않으면 무시된다.
     * `false` 시 실제 값이 변경되었는 지와 상관없이 사용자 편집 행위가 있었다면 그 행은 변경된 상태가 된다.
     *
     * @defaultValue `false`
     */
    checkDiff?: boolean;
    /**
     * 셀 편집 완료 시 실제 값이 변경 되었을 때 상태 변경 확인 여부
     *
     * @remarks
     * `true`면 셀 편집 완료 요청 시 실제 변경 값이 하나라도 있어야 완료된다.
     * 그렇지 않으면 무시된다.
     * `false` 면 실제 값이 변경되었는 지와 상관없이 사용자 편집 행위가 있었다면 그 행은 변경된 상태가 된다.
     *
     * @defaultValue `false`
     */
    checkCellDiff?: boolean;
    /**
     * strict 하게 판단하여 셀 편집시 실제 값이 변경 되었는지 확인 여부 (자료형도 같아야함)
     *
     * @remarks
     * `true` 면 셀 편집 완료 요청 시 실제 변경 값이 하나라도 있어야 완료된다.
     * 그렇지 않으면 무시된다.
     * `false` 면 실제 값이 변경되었는 지와 상관없이 사용자 편집 행위가 있었다면 그 행은 변경된 상태가 된다.
     *
     * @defaultValue `false`
     */
    strictDiff?: boolean;
    /**
     * 셀 편집 시 편집 취소 후 선택된 행 삭제 가능 여부
     *
     * @defaultValue `true`
     */
    deletableWhenEdit?: boolean;
    /**
     * commit 오류 발생 시 보여줄 것인지에 대한 여부
     *
     * @defaultValue `false`
     */
    showCommitError?: boolean;

    /**
     * Insert 키로 마지막에 행을 추가할지의 여부
     *
     * @defaultValue `false`
     */
    appendWhenInsertKey?: boolean;
    /**
     * Tab 또는 Enter 키로 마지막 셀을 벗어날 때 행 추가 여부
     *
     * @remarks
     * commitWhenExitLast 가 true 여야 한다.
     *
     * @defaultValue `false`
     */
    appendWhenExitLast?: boolean;
    /**
     * 설정한 Validation Error의 메시지만 보여줄지 의 여부
     *
     * @remarks
     * `true`인경우 Validation의 `message`만 보여주며 false 인경우 `level`과 `message`를 동시에 보여준다.
     * 셀별로 `message`를 변경하려면 {@link GridBase.onValidationFail}을 참조
     *
     * @defaultValue `true`
     */
    showOnlyValidationMessage?: boolean;
    /**
     * 그리드의 행의 마지막에 항상 빈 행을 추가할지의 여부
     *
     * @remarks
     * 해당 빈 행에 데이터가 입력되고 행 commit()이 발생하면 다시 빈 행이 추가된다.
     *
     * @defaultValue `false`
     */
    displayEmptyEditRow?: boolean;

    /**
     * tab 키를 눌렀을 때 그리드 벗어남 여부
     *
     * @defaultValue {@link ExitGridWhenTab.NONE}
     */
    exitGridWhenTab?: ExitGridWhenTab;
    /**
     * 편집 취소 가능 여부
     *
     * @defaultValue `false`
     */
    cancelWhenLastUndo?: boolean;
    /**
     * 편집 중 일때 스크롤 시 처리
     *
     * @defaultValue {@link ScrollOnEditing.DEFAULT}
     */
    scrollOnEditing?: ScrollOnEditing;
    /**
     * commitEdit와 {@link GridBase.onCurrentChanging}의 실행 순서
     *
     * @remarks
     * `true`이면 그리드의 commitEdit보다 onCurrentChanging 이벤트가 먼저 실행된다.
     *
     * @defaultValue `false`
     */
    currentChangingFirst?: boolean;
    /**
     * 왼쪽 또는 오른쪽 화살표를 입력했을때 focus가 셀또는 그룹단위로 이동하도록 한다.
     *
     * @remarks
     * `group`이면 최상위 그룹단위로 focus가 이동한다.
     *
     * @defaultValue `cell`
     */
    focusMoveStep?: FocusMoveStep;
}

/**
 * 그리드 수준에서 관리되는 편집기 정보들에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * {@link EditorOptions.months | months} 속성이 지정되면 {@link EditorOptions.monthDisplayFormat | monthDisplayFormat} 속성은 무시된다.
 *
 * @example
 *
 * ```js
 * grid.setEditorOptions({yearDisplayFormat: "{Y} year"});
 * ```
 */
export declare interface EditorOptions {
    /**
     * 달력 팝업에서의 년의 표시 형태
     *
     * @remarks
     * "년"에 대한 문구만 수정 가능
     * ex) `{Y} Year`
     *
     * @defaultValue `'{Y}년'`
     */
    yearDisplayFormat?: string;
    /**
     * 달력 팝업에서의 월의 표시 형태
     *
     * @remarks
     * "월"에 대한 문구만 수정 가능
     * {@link EditorOptions.months | months } 속성이 지정되면 본 속성은 무시
     * ex) `{M} Month`
     *
     * @defaultValue `'{M}월'`
     */
    monthDisplayFormat?: string;
    /**
     * 달력 팝업에서의 월의 표시 형태
     *
     * @remarks
     * ex) `['Jan', 'Feb', 'Mar', 'Apr', ...]`
     *
     * @defaultValue `null`
     */
    months?: string[];
    /**
     * 달력 팝업에서의 요일의 표시 형태
     *
     * @remarks
     * ex) `['Mon', 'Tue', 'Wed', 'Thu', ...]`
     *
     * @defaultValue `null`
     */
    weekDays?: string[];
    /**
     * 그리드 DOM 내부에 포함시킬 것인지의 여부
     *
     * @remarks
     * editor element 가 그리드 element 내부에 생성되어 브라우저가 스크롤 되는 경우 함께 스크롤 된다.
     *
     * @defaultValue `false`
     */
    viewGridInside?: boolean;

    /**
     * 표시되는 공휴일
     *
     * @defaultValue `null`
     */
    holidays?: Holidays;
}

/**
 * @public
 *
 * {@link GridBase.onGetEditValue} 에서 쓰이는 셀 편집 후 출력 정보
 *
 * @remarks
 * DropDownCellEditor, SearchCellEditor, MultiCheckCellEditor의 경우 editResult.text에는 labels에 해당하는 값이 출력되고 editResult.value에는 values에 해당하는 값이 출력된다.
 *
 * DateCellEditor의 경우에는 editResult.text에는 editor의 datetimeFormat으로 Formatting된 값이 출력되고 editResult.value에는 Date객체가 출력된다.
 *
 * 다른 Editor의 경우 text와 value에 동일한 값이 출력된다.
 */
export declare interface EditResult {
    /**
     * 텍스트
     */
    text: string;
    /**
     * 값
     */
    value: any;
}

/**
 * @public
 *
 * 컬럼 단위 혹은, 행 단위 데이터 편집 검증 조건과 방식에 대한 모델
 *
 * @remarks
 * {@link GridBase.setValidations} 에서 사용한다.
 *
 * @example
 * ```js
 * // 문자열
 * gridView.setValidations("values['UnitPrice'] > 100");
 *
 * // 오브젝트
 * gridView.setValidations({
 *      message: 'Too expensive!',
 *      criteria: "values['UnitPrice'] > 100"
 * })
 *
 * // 배열
 * gridView.setValidations([{
 *      message: 'Too expensive!',
 *      criteria: "values['UnitPrice'] > 100"
 * }])
 * ```
 */
export declare interface EditValidation {
    /**
     * 이름
     *
     * @remarks
     * 검증 실패시 메시지나 description 이 설정되지 않았을 경우 메시지로 사용된다.
     */
    name?: string;
    /**
     * 검증 진행 여부
     *
     * @defaultValue `true`
     */
    active?: boolean;
    /**
     * 검증 모드
     *
     * @remarks
     * Insert 시, Update 시, 또는 두 경우 모두 실행한다.
     *
     * @defaultValue {@link ValidationMode.ALWAYS}
     */
    mode?: ValidationMode;
    /**
     * 검증 결과 수준
     *
     * @defaultValue {@link ValidationLevel.ERROR}
     */
    level?: ValidationError;
    /**
     * 검증식
     */
    criteria?: string;
    /**
     * 검증 실패 시 보여지는 에러 메시지
     */
    message?: string;
    /**
     * 검증 실패 시의 설명
     *
     * @remarks
     * 검증 실패시 메시지가 지정되지 않았을 경우 메시지로 사용된다.
     */
    description?: string;
}

/**
 * @public
 *
 * {@link EditValidation} 의 콜렉션 모델
 *
 * @remarks
 * {@link DataColumn.validations | column의 validations} 를 반환할 때 이 오브젝트를 반환한다.
 */
export declare interface EditValidationCollection {
    /**
     * 검증 조건 모델들의 갯수
     * @readonly
     */
    count: number;
    /**
     * 검증 조건 모델의 배열
     */
    items: EditValidation[];
}

/**
 * @public
 *
 * tab 입력 시 그리드를 벗어나기 위한 조건
 *
 * {@link EditOptions.exitGridWhenTab} 에서 설정 가능하다.
 *
 * @example
 * ```js
 * grid.editOptions.exitGridWhenTab = 'grid';
 * ```
 */
export declare enum ExitGridWhenTab {
    /**
     * 행의 마지막 셀일 경우 벗어난다.
     */
    ROW = "row",
    /**
     * 그리드의 마지막 셀일 경우 벗어난다.
     */
    GRID = "grid",
    /**
     * tab키를 입력했을때 그리드를 벗어나지 않는다.
     */
    NONE = "none"
}

/**
 * @public
 *
 * 행 그룹핑 시 Expander 표시여부
 *
 * @remarks
 * {@link RowGroup.mergeExpanderVisibility} 에서 사용된다.
 *
 * @example
 * ```js
 * gridView.rowGroup.mergeExpanderVisibility = 'always';
 * ```
 */
export declare enum ExpanderVisibility {
    /**
     * 행 그룹핑 시 Expander 를 항상 표시한다.
     */
    ALWAYS = "always",
    /**
     * 기본값: 그룹핑 된 행들이 여러 개 보임 상태이면 표시하고 그렇지 않으면 표시하지 않는다.
     */
    DEFAULT = "default",
    /**
     * 행 그룹핑 시 Expander 를 표시하지 않는다.
     */
    NONE = "none"
}

/**
 * 그룹 expander의 visible 여부를 return 하는 callback
 *
 * @remarks
 * {@link RowGroup.expanderVisibleCallback} 에서 사용되는 형식이다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨트롤
 *
 * `group` - 그룹 아이템
 *
 * @example
 * ```js
 * gridView.rowGroup.expanderVisibleCallback = function(grid, group) {
 *      // 2 level인 group만 expander를 표시한다.
 *      return group.level === 2;
 * 	}
 * ```
 */
export declare type ExpanderVisibleCallback = (grid: GridView, group: GroupItem) => boolean;

/**
 * @public
 * 그리드 및 데이터 내보내기에 관한 설정들의 기반 모델
 *
 * @remarks
 * {@link GridExportOptions}, {@link DataExportOptions} 가 하위 모델이다.
 *
 * [하위 클래스]
 *
 * {@link GridExportOptions}
 *
 * {@link DataExportOptions}
 */
export declare interface ExportBaseOptions {
    /**
     * 내보내기를 할 타입
     */
    type?: ExportType | string;
    /**
     * 내보내기 할 대상 / 경로
     *
     * @defaultValue {@link ExportTarget.LOCAL}
     */
    target?: ExportTarget | string;
    /**
     * 그리드가 내보내는 문서 스트림을 전송 받은 후 다시 사용자 컴퓨터에 내려 주는 서버의 url
     */
    url?: string;
    /**
     * Datetime 필드의 값이 `null` 일 때 표현되는 값
     *
     * @defaultValue `''`
     */
    nullDateText?: string;
    /**
     * 내보내기 시 파일 명
     *
     * @example
     * `'gridExportSample.xlsx'`
     */
    fileName?: string;

    /**
     * 내보내기 시 프로그레스 바 표시여부
     *
     * @defaultValue `false`
     */
    showProgress?: boolean;
    /**
     * 프로그레스 바 사용 시 표시될 메시지
     * @remarks
     *
     * @defaultValue `'csv'`: `'Exporting...'`, `'excel'`: `null`
     */
    progressMessage?: string;
    /**
     * 사용자 Progress Bar를 위한 callback
     * @remarks
     * progressCallback이 설정되면 Grid내부의 progressBar는 표시되지 않는다.
     *
     */
    progressCallback?: ProgressCallback;
    /**
     * 내보내기를 완료할 때 수행 될 콜백
     *
     * @remarks
     * {@link ExportBaseOptions.target} 이 {@link ExportTarget.STREAM} 인경우 Base64로 encoding된 Data가 전달된다.
     */
    done?: ExportSimpleCallback;
    /**
     * target이 "remote"일때 서버로 전달될 parameters
     *
     * @remarks
     * target이 remote일때 서버로 전달되어야 할 추가 정보가 있는 경우 사용한다.
     *
     * @example
     * ```js
     * var params = {
     *   userId: "userId",
     *   param1: "param1",
     *   param2: "param2"
     * }
     * gridView.exportGrid({type:"excel", target:"local", params:params})
     * ```

     */
    params?: ConfigObject;
}

/**
 * layout Expandable이 true인 layut을 excel로 export할때
 */
export declare enum ExportLayoutExpand {
    /**
     * expandable을 무시하고 설정된 layout모양대로 출력한다.
     */
    IGNORE = "ignore",
    /**
     * current 현재모양
     */
    CURRENT = "current",
    /**
     * 펼쳐진 상태로 출력한다.
     */
    EXPAND = "expand",
    /**
     * 접힌 상태로 출력한다.
     */
    COLLAPSE = "collapse"
}

/**
 * @public
 * 그리드 및 데이터 내보내기에 관한 설정들의 공통 모델
 *
 * @remarks
 * {@link ExportBaseOptions} 를 상속한다.
 * {@link GridExportOptions}, {@link DataExportOptions} 가 하위 모델이다.
 *
 * [상위 클래스]
 *
 * {@link ExportBaseOptions}
 *
 * [하위 클래스]
 *
 * {@link GridExportOptions}
 *
 * {@link DataExportOptions}
 */
export declare interface ExportOptions extends ExportBaseOptions {
    /**
     * 날짜 형식일 때의 서식
     */
    datetimeFormat?: string;
    /**
     * Boolean 형식일 때의 서식
     */
    booleanFormat?: string;
    /**
     * datetime 필드 출력 시 수행될 콜백
     *
     * @eventProperty
     */
    datetimeCallback?: ExportValueCallback;
    /**
     * number 필드 출력 시 수행될 콜백
     *
     * @eventProperty
     */
    numberCallback?: ExportValueCallback;
    /**
     * boolean 필드 출력 시 수행될 콜백
     *
     * @eventProperty
     */
    booleanCallback?: ExportValueCallback;
    /**
     * object 필드 출력 시 수행될 콜백
     *
     * @eventProperty
     */
    objectCallback?: ExportValueCallback;
    /**
     * text 필드 출력 시 수행될 콜백
     *
     * @remarks
     * text 타입으로 된 시간값을 내보내기 하였을 때, 엑셀에서 연산을 가능할 수 있게 하기위해 만들어졌다.
     *
     * @eventProperty
     */
    textCallback?: ExportValueCallback;
    /**
     * 내보내기를 시작할 행
     *
     * @defaultValue `0`
     */
    start?: number;
    /**
     * 내보내기 할 행 수
     *
     * @remarks
     * `-1` 로 지정하면 전체 행이 내보내기 된다.
     * @defaultValue `-1`
     */
    count?: number;
    /**
     * 구분자
     *
     * @remarks
     * csv로 export시 구분자
     */
    seperator?: string;
    /**
     * cr(Carriage Return)가 있는 경우 치환할 문자열
     *
     * @defaultValue `null`
     */
    replaceCrText?: string;
    /**
     * lf(Line Feed)가 있는 경우 치환할 문자열
     *
     * @defaultValue `null`
     */
    replaceLfText?: string;
}

/**
 * {@link ExportBaseOptions.done | done} 을 설정하기 위한 내보내기를 완료할 때 수행될 콜백의 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `data` - target이 `stream`인 경우 전달된다.
 */
export declare type ExportSimpleCallback = (data?: string) => void;

/**
 * 그리드를 외부 문서로 내보내기 할 때의 대상
 */
export declare enum ExportTarget {
    /**
     * 로컬에 직접 저장
     */
    LOCAL = "local",
    /**
     * 서버를 경유해서 저장
     */
    REMOTE = "remote",
    /**
     * 콘솔에 내보내기
     */
    STREAM = "stream"
}

/**
 * 그리드를 외부 문서로 내보내기 할 때의 종류
 *
 * @remarks
 * {@link ExportBaseOptions."type"} 에서 사용된다.
 */
export declare enum ExportType {
    /**
     * 엑셀
     */
    EXCEL = "excel",
    /**
     * CSV
     */
    CSV = "csv"
}

/**
 * {@link ExportBaseOptions | 그리드 내보내기 설정}에서 필드 별로 출력 시 수행될 콜백을 지정하기 위한 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `index` - 인덱스
 *
 * `name` - 필드명
 *
 * `value` - 입력된 값
 *
 * [반환값] - 내보내기 될 값
 */
export declare type ExportValueCallback = (index: number, name: string, value: any) => any;

/**
 * {@link DataDropOptions.fieldMap} 에서 사용되는 옮길 그리드의 필드명 - 옮김을 받은 그리드의 필드명 쌍 형식
 *
 * @remarks
 * `'*':'*'` 로 필드명이 동일한 필드끼리 매핑할 수 있다.
 *
 * @example
 * ```js
 * {
 *      'CompanyName': 'ShipAddress',
 *      '*': '*'
 * }
 * ```
 */
export declare interface FieldMap {
    [fieldName: string]: string;
}

/**
 * calculated 필드일 경우 수식을 지정하여 계산 될 콜백의 형식
 *
 * @remarks
 * {@link DataField.valueCallback} 또는 {@link DataFieldObject.valueCallback} 에서 사용된다.
 *
 * 최종적으로 출력하고자 하는 값을 반환하면 된다.
 *
 * [매개변수 목록]
 *
 * `ds` - DataProvider 컨트롤
 *
 * `rowId` - 행 고유번호
 *
 * `fieldName` - 필드명
 *
 * `fields` - 필드명 배열
 *
 * `values` - 값 배열
 *
 * [반환값] - 출력할 값
 *
 * @example
 * ```js
 * function (ds, rowID, fieldName, fields, values) {
 *     let quantity = values[fields.indexOf("Quantity")];
 *     let unitprice = values[fields.indexOf("UnitPrice")];
 *     if (isNaN(quantity) || isNaN(unitprice))
 *         return undefined;
 *     else
 *         return quantity >= 1000 ? Math.round(quantity * unitprice * 0.95) : quantity * unitprice;
 * }
 * ```
 */
export declare type FieldValueCallback = (ds: DataProviderBase, rowId: number, fieldName: string, fields: string[], values: any[]) => any;

/**
 * 자동 필터링에 관한 설정 정보
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFilteringOptions({
 *      automating: {
 *          dateCategorize: false
 *      }
 * });
 * ```
 */
export declare interface FilterAutomatingOptions {
    /**
     * 날짜를 분류할 것인지의 여부
     *
     * @remarks
     * `true` 시 설정한 foramt 들을 기준으로한 텍스트로 연도, 분기, 또는 월 단위로 분류된다.
     *
     * 년도 수가 2 이상, 월 수가 7 이상이어야 연도별로 분류된다.
     *
     * 년도 당 월 수가 7 이상이어야 분기별로 분류된다.
     *
     * 총 일 수가 10 이상이고 월 수가 4 이상이어야 월별로 분류된다.
     *
     * `false` 시 트리 형태가 아닌 리스트 형태로 항목마다 필터 탭이 만들어진다.
     *
     * {@link FilterAutomatingOptions.dateCategoryCallback } 을 지정하여 사용자 지정의 분류를 할 수 있다.
     *
     * @defaultValue `true`
     */
    dateCategorize?: boolean;
    /**
     * 수를 분류할 것인지의 여부
     *
     * @remarks
     * `true` 시 중복제거된 아이템이 16개 이상인 경우, 최대값과 최소값의 차를 기준으로 4개에서 8개 사이의 구간으로 분류 되어진다.
     * 아이템이 15개 이하거나 `false` 시 트리 형태가 아닌 리스트 형태로 항목마다 필터 탭이 만들어진다.
     * {@link FilterAutomatingOptions.numberCategoryCallback } 을 지정하여 사용자 지정의 분류를 할 수 있다.
     *
     * @defaultValue `true`
     */
    numberCategorize?: boolean;
    /**
     * 텍스트를 분류할 것인지의 여부
     *
     * @remarks
     * `true` 시 아이템이 16개 이상인 경우에 문자열의 첫 문자를 기준으로 숫자, 알파벳 대문자, 알파벳 소문자, 유니코드, 그 외로 분류 되어진다.
     * 아이템이 15개 이하거나 `false` 시 트리 형태가 아닌 리스트 형태로 항목마다 필터 탭이 만들어진다.
     * {@link FilterAutomatingOptions.textCategoryCallback } 을 지정하여 사용자 지정의 분류를 할 수 있다.
     *
     * @defaultValue `false`
     */
    textCategorize?: boolean;
    /**
     * 날짜를 분류하기 위한 콜백
     * @remarks
     * 반환 값 및 설명은 {@link FilterCategory} 참조
     *
     * @eventProperty
     */
    dateCategoryCallback?: CategoryCallback;
    /**
     * 수를 분류하기 위한 콜백
     * @remarks
     * 반환 값 및 설명은 {@link FilterCategory} 참조
     *
     * @eventProperty
     */
    numberCategoryCallback?: CategoryCallback;
    /**
     * 문자열을 분류하기 위한 콜백
     * @remarks
     * 반환 값 및 설명은 {@link FilterCategory} 참조
     *
     * @eventProperty
     */
    textCategoryCallback?: CategoryCallback;
    /**
     * 항목에 표시되는 연도 형식
     *
     * @defaultValue `'YYYY년도'`
     */
    dateYearFormat?: string;
    /**
     * 항목에 표시되는 분기 형식
     *
     * @defaultValue `'Q분기'`
     */
    dateQuarterFormat?: string;
    /**
     * 항목에 표시되는 월 형식
     *
     * @defaultValue `'M월'`
     */
    dateMonthFormat?: string;
    /**
     * 항목에 표시되는 일 형식
     *
     * @defaultValue `'YYYY-MM-DD'`
     */
    dateDayFormat?: string;
    /**
     * Column의 lookupDisplay가 true이면 value 대신 label을 표시한다.
     *
     * @defaultValue `false`
     */
    lookupDisplay?: boolean;

}

/**
 * @public
 *
 * 필터 콜백
 *
 * @remarks
 * {@link ColumnFilter.callback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `ds` - Provider 컨트롤
 *
 * `dataRow` - 행의 인덱스
 *
 * `level` - 수준
 *
 * `field` - 필드명
 *
 * `filter` - {@link ColumnFilter} 객체
 *
 * `value` - 값
 *
 * [반환값] - 필터링 결정 여부
 *
 * @example
 * ```js
 * const f = function(ds, dataRow, level, field, filter, value) {
 *      let res = isMatched(value, filter.criteria);
 *      return res;
 * }
 * ```
 */
export declare type FilterCallback = (ds: LocalDataProvider | LocalTreeDataProvider, dataRow: number, level: number, field: number, filter: ColumnFilter, value: any) => boolean;

/**
 * 사용자 지정 자동필터링 생성 시 카데고리 분류 모델
 *
 * @remarks
 * {@link CategoryCallback} 에서 반환되어야 하는 모델의 형태이다.
 *
 * 실제 {@link FilterAutomatingOptions} 의 category callback 들을 설정할 때 사용된다.
 *
 * @example
 *
 * ```js
 * // Date 일 경우
 * [
 *     {
 *         text: "2019년도",
 *         childs: [
 *             {
 *                 text: "2사분기",
 *                 childs: [
 *                     {
 *                         text: "6월",
 *                         childs: [
 *                             {text: "2019-06-11", year: 2019, month: 5, day: 11},
 *                             {text: "2019-06-12", year: 2019, month: 5, day: 12},
 *                             {text: "2019-06-18", year: 2019, month: 5, day: 18},
 *                             {text: "2019-06-27", year: 2019, month: 5, day: 27},
 *                             {text: "2019-06-30", year: 2019, month: 5, day: 30}
 *                         ],
 *                         year: 2019,
 *                         quarter: 1,
 *                         month: 5
 *                     }
 *                 ],
 *                 year: 2019,
 *                 quarter: 1
 *             },
 *             {
 *                 text: "3사분기",
 *                 childs: [
 *                     {
 *                         text: "7월",
 *                         childs: [
 *                             {text: "2019-07-03", year: 2019, month: 6, day: 3},
 *                             {text: "2019-07-07", year: 2019, month: 6, day: 7},
 *                             {text: "2019-07-17", year: 2019, month: 6, day: 17},
 *                             {text: "2019-07-21", year: 2019, month: 6, day: 21}
 *                         ],
 *                         year: 2019,
 *                         quarter: 1,
 *                         month: 6
 *                     },
 *                     {
 *                         text: "8월",
 *                         ...
 *                     }
 *                 ],
 *                 year: 2019,
 *                 quarter: 2
 *             },
 *             {
 *                 text: "4사분기",
 *                 childs: [
 *                     {
 *                         text: "10월",
 *                         childs: [
 *                             ...
 *                         ],
 *                         year: 2019,
 *                         quarter: 3,
 *                         month: 9
 *                 }
 *                 ],
 *                 year: 2019,
 *                 quarter: 3
 *             },
 *         ],
 *         year: 2019,
 *     },
 *     {
 *         text: '2020년도',
 *         ...
 *     }
 * ]
 *
 * [
 *     {text: "2019-06-11", year: 2019, month: 5, day: 11}
 *     {text: "2019-06-12", year: 2019, month: 5, day: 12}
 *     {text: "2019-06-18", year: 2019, month: 5, day: 18},
 *         ...
 *     {text: "2021-12-27", year: 2021, month: 12, day: 27}
 * ]
 *
 * // Text 일 경우
 *
 * [
 *     {text: "A ~ C", values: [
 *         "Adrian", "Adrienne", "Aladdin", "Alden", "Alea", "Alexa", "Amber",
 *         "Amy", "Arsenio", "Beatrice", "Benedict", "Benjamin", "Blaze", "Brennan",
 *     ]},
 *     {text: "D ~ F", values: [...]},
 *     {text: "G ~ I", values: [...]},
 *     {text: "J ~ L", values: [...]}
 * ]
 *
 * [
 *     {text: "Adrian", value: "Adrian"},
 *     {text: "Adrienne", value: "Adrienne"},
 *     {text: "Aladdin", value: "Aladdin"},
 *     {text: "Alden", value: "Alden"},
 *     {text: "Alea", value: "Alea"}
 * ]
 *
 * // Number 일 경우
 * [
 *     {text: "0 ~ 25", values: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]},
 *     {text: "25 ~ 50", values: [...]},
 *     {text: "50 ~ 75", values: [...]},
 *     {text: "75 ~ 100", values: [...]}
 * ]
 *
 * [
 *     {text: "0 ~ 1", values: [0]},
 *     {text: "1 ~ 2", values: [1]},
 *     {text: "2 ~ 3", values: [2]},
 *     {text: "3 ~ 4", values: [3]},
 *     {text: "4 ~ 5", values: [4]},
 *     {text: "5 ~ 6", values: [5]},
 *     {text: "6 ~ 7", values: [6]},
 *         ...
 *     {text: "99 ~ 100", values: [99]}
 * ]
 * ```
 */
export declare interface FilterCategory {
    /**
     * 필터 선택 상자의 아이템들에 표시되는 텍스트
     */
    text: string;
    /**
     * 하위 그룹의 아이템
     */
    childs?: FilterCategory[];
    /**
     * 빈 값의 아이템인지의 여부
     */
    empty?: boolean;
    /**
     * 값
     *
     * @remarks
     * {@link FilterAutomatingOptions.textCategoryCallback} 을 설정할 때 사용된다.
     */
    value?: any;
    /**
     * 값들
     *
     * @remarks
     * {@link FilterAutomatingOptions.textCategoryCallback}, 또는 {@link FilterAutomatingOptions.numberCategoryCallback} 을 설정할 때 사용된다.
     */
    values: any[];
    /**
     * 연도 정보
     *
     * @remarks
     * {@link FilterAutomatingOptions.dateCategoryCallback} 을 설정할 때 사용된다.
     */
    year?: number;
    /**
     * 분기 정보
     *
     * @remarks
     * {@link FilterAutomatingOptions.dateCategoryCallback} 을 설정할 때 사용된다.
     *
     * `0`부터 `3`까지 각각 1, 2, 3, 4분기를 의미한다.
     */
    quarter?: number;
    /**
     * 월 정보
     *
     * @remarks
     * {@link FilterAutomatingOptions.dateCategoryCallback} 을 설정할 때 사용된다.
     *
     * `0`부터 `11`까지 각각 1, 2, ..., 12월를 의미한다.
     */
    month?: number;
    /**
     * 일 정보
     *
     * @remarks
     * {@link FilterAutomatingOptions.dateCategoryCallback} 을 설정할 때 사용된다.
     */
    day?: number;
}

/**
 * 컬럼 필터링과 관련된 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFilteringOptions({enabled: false});
 * ```
 */
export declare interface FilteringOptions {
    /**
     * 필터 핸들이나 Indicator Head를 클릭으로 필터 상자 표시 가능 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
    /**
     * 필터 핸들의 표시 방법
     *
     * @defaultValue {@link HandleVisibility.VISIBLE}
     */
    handleVisibility?: HandleVisibility;
    /**
     * 필터링 전에 commit 할 건지의 여부
     *
     * @defaultValue `true`
     */
    commitBeforeFiltering?: boolean;
    /**
     * TreeView 에서 검색된 데이터 행의 부모 행도 표시할지의 여부
     *
     * @defaultValue `true`
     */
    includeParentItem?: boolean;
    /**
     * 필터 선택 상자에 대한 설정 모델
     *
     * @remarks
     * {@link FilterSelectorOptions} 모델을 따른다.
     */
    selector?: FilterSelectorOptions;
    /**
     * 자동 필터링에 대한 설정 모델
     *
     * @remarks
     * {@link FilterAutomatingOptions} 모델을 따른다.
     */
    automating?: FilterAutomatingOptions;
    /**
     * toast 관련 설정
     *
     * @remarks
     * {@link ToastOptions} 모델을 따른다.
     *
     * @defaultValue `{visible: false, message: "Filtering..."}`
     */
    toast?: ToastOptions;
}

/**
 * @public
 *
 * 데이터 수정 이후 필터 동작 모드
 *
 * @remarks
 * {@link GridView.filterMode} 에서 사용된다.
 *
 * @example
 * ```js
 * gridView.filterMode = 'explicit';
 * ```
 */
export declare enum FilterMode {
    /**
     * 자동
     */
    AUTO = "auto",
    /**
     * 데이터 수정이후 명시적으로 필터링을 수행해야 필터링됨
     */
    EXPLICIT = "explicit"
}

/**
 * @public
 * {@link GridHeader}영역 아래 사용자가 입력한 값을 이용해서 filtering을 할수 있는 입력창을 표시한다.
 *
 * @remarks
 * {@link DataColumn.valueType}에 따라 조건을 선택후 입력창에 값을 입력하면 {@link FilterPanel.filterDelay}에 지정된 시간이후 filter가 적용된다.
 *
 */
export declare interface FilterPanel {
    /**
     * filterPanel이 보여질지 여부
     *
     * @defaultValue `false`
     */
    visible?: boolean;
    /**
     * filterPanel의 높이를 지정한다.
     * data행이 여러줄로 이루어진 경우 filterPanel도 동일한 형태로 표시되고 filterPanel의 높이는 data행의 줄수 * minRowHeight 또는 height중 큰 값으로 적용.
     * @defaultValue `0`
     */
    height?: number;
    /**
     * 행의 최소 높이를 지정한다.
     *
     * @defaultValue `23`
     */
    minRowHeight?: number;
    /**
     * 사용자 입력이 끝나고 지정된 시간이후에 filter를 적용한다.
     *
     * @defaultValue `500`
     */
    filterDelay?: number;
    /**
     * 대소문자 구분 여부
     * @defaultValue `true`
     */
    ignoreCase?: boolean;
    /**
     * 입력창에 입력된 값과 data의 앞뒤 공백을 지우고 filter를 적용한다.
     *
     * @defaultValue `true`
     */
    trimData?: boolean;
    /**
     * filterPanel에 입력창을 보여줄지 여부
     *
     * @remarks
     * `false`이면 {@link DataColumn.showInlineFilter}가 `true`인 컬럼만 입력창이 표시된다.
     *
     * @defaultValue `true`
     */
    showInput?: boolean;
    /**
     * 데이타 편집중에 filter입력창에 focus가 가면 commit할것인지 여부
     *
     * @remarks
     * `false`이면 편집을 완료해야 filter입력창에 focus를 줄수 있다.
     *
     * @defaultValue `true`
     */
    beforeCommit?: boolean;
    /**
     * {@link ValueType}이 `text`인 컬럼이 사용할 filterOperator를 입력한다.
     *
     * @remarks
     *
     * 사용할 filterOperator를 지정하거나 팝업에 표시되는 값을 변경한다.
     *
     * {@link InlineFilterOperator}에 없는 값을 입력하면 무시된다.
     *
     * @example
     * ```js
     * var textOperators = {
     *   constains: "값을 포함하고 있는 Data",
     *   notContains: "값을 포함하지 않는 Data"
     * }
     *
     * gridView.filterPanel.textOperators = textOperators;
     * ```
     */
    textOperators?: {
        [key: string]: string;
    };
    /**
     * {@link ValueType}이 `number`인 컬럼이 사용할 filterOperator를 입력한다.
     *
     */
    numberOperators?: {
        [key: string]: string;
    };
    /**
     * {@link ValueType}이 `date`인 컬럼이 사용할 filterOperator를 입력한다.
     *
     */
    dateOperators?: {
        [key: string]: string;
    };
    /**
     * keyboard의 `up`key와 `down`key를 이용해서 data와 filterPanel이동여부
     *
     * @remarks
     * `true`이면 filterPanel에서 keyboard의 `down`key를 이용해서 data영역으로 이동하거나 또는 data의 첫행에서 `up`key로 filterPanel로 이동할수 있다.
     *
     * @defaultValue `true`
     */
    crossWhenKeyBoard?: boolean;
    /**
     * filterPanel에 입력된 text을 지우고 filter를 비활성화 한다.
     *
     * @remarks
     * `column`을 지정하면 지정된 column의 text만 지운다.
     *
     * @param column - string
     */
    clearInput?(column?: string): void;
}

/**
 * 컬럼 필터의 선택 상자에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFilteringOptions({
 *      selector: {
 *          showButtons: false
 *      }
 * });
 * ```
 */
export declare interface FilterSelectorOptions {
    /**
     * 컬럼 필터의 선택 상자의 푸터 버튼 표시 여부
     *
     * @defaultValue `false`
     */
    showButtons?: boolean;
    /**
     * 필터 검색 상자 표시 여부
     *
     * @defaultValue `true`
     */
    partialSearch?: boolean;
    /**
     * 필터의 선택 상자의 확인 버튼의 문구
     *
     * @defaultValue `'확인'`
     */
    acceptText?: string;
    /**
     * 필터의 선택 상자의 취소 버튼의 문구
     *
     * @defaultValue `'취소'`
     */
    cancelText?: string;
    /**
     * 전체 선택 탭의 문구
     *
     * @defaultValue `'(전체선택)'`
     */
    allCheckText?: string;
    /**
     * 자동 필터 생성 시 값 없음 필터 탭의 문구
     *
     * @defaultValue `'(값 없음)'`
     */
    emptyFilterText?: string;
    /**
     * 검색 박스의 placeholder
     *
     * @defaultValue `'검색...'`
     */
    searchPlaceholder?: string;
    /**
     * 검색 후 전체 선택 대신에 보여지는 문구
     *
     * @defaultValue `'(조회 전체 선택)'`
     */
    searchedCheckText?: string;
    /**
     * 필터창의 class
     *
     * @defaultValue `rg-filter-selector`
     */
    style?: string;
    /**
     * 필터를 활성화 하였을 때 창 닫힘 여부
     *
     * @remarks
     * {@link FilterSelectorOptions.showButtons | showButtons} 가 `false` 일 경우, 필터를 선택 하였을 때 창이 닫힌다.
     * {@link FilterSelectorOptions.showButtons | showButtons} 에 `true`로 설정하여 확인 / 취소 버튼이 생겼을 경우에는 확인 / 취소 버튼 동작 시 창이 닫힌다.
     *
     */
    closeWhenClick?: boolean;
    /**
     * 필터 전체 초기화 버튼 유무
     *
     * @defaultValue `true`
     */
    filterReset?: boolean;
    /**
     * 필터 전체 초기화 텍스트
     *
     * @defaultValue `'전체 초기화'`
     */
    filtersResetText?: string;
    /**
     * 컬럼 필터 선택 초기화 텍스트
     *
     * @defaultValue `'초기화'`
     *
     */
    filterResetText?: string;
    /**
     * 필터 text를 `title`로 추가 여부
     *
     * @defaultValue `false`
     *
     * @remarks
     * 필터의 text를 element의 title로 추가해서 mouse over시 tooltip이 보여지도록 한다.
     */
    textToTitle?: boolean;
    /**
     * 필터 검색시 대소문자 구분 여부
     *
     * @defaultValue `false`
     *
     * @remarks
     * `true`이면 대소문자를 구분하지 않고 검색한다.
     */
    searchIgnoreCase?: boolean;
    /**
     * 필터 검색후 검색된 필터 활성화 여부
     *
     * @remarks
     * 필터 검색후 `enter`를 입력했을때 검색된 필터를 활성화 시킨다.
     *
     * @defaultValue `false`
     */
    activeWhenEnter?: boolean;
    /**
     * 필터선택 창의 최대 너비
     *
     * @remarks
     *
     * 필터선택 창의 최대너비를 지정한다.
     * `0`인 경우 적용되지 않는다.
     */
    maxWidth?: number;
    /**
     * 필터 너비
     *
     * @remarks
     * 0 인경우 style 파일에 지정된 너비 적용
     * -1 인 경우 filter Text너비를 계산해서 적용
     * -2 인 경우 컬럼의 너비를 적용
     * 0 이상인 경우 지정된 너비 적용.
     *
     * @defaultValue `0`
     */
    width?: number;
    /**
     * 필터 선택창의 최소너비.
     * width가 0인경우 적용되지 않는다.
     *
     */
    minWidth?: number;
}

/**
 * 그리드의 고정 행 및 컬럼 영역에 대한 설정 모델
 *
 * @remarks
 * 그리드 위쪽에 하나 이상의 행을 수직 스크롤링에서 제외할 수 있다.
 *
 * 하나 이상의 최상위 컬럼을 수평 스크롤에서 제외할 수 있다.
 *
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFixedOptions({colCount: 2});
 * ```
 */
export declare interface FixedOptions {
    /**
     * 왼쪽 고정 컬럼의 개수
     *
     * @remarks
     * 최상위 컬럼 단위로 지정
     *
     * @defaultValue `0`
     */
    colCount?: number;
    /**
     * 오른쪽 고정 컬럼의 개수
     *
     * @remarks
     * 최상위 컬럼 단위로 지정
     *
     * @defaultValue `0`
     *
     */
    rightCount?: number;
    /**
     * 위쪽 고정 행의 개수
     *
     * @defaultValue `0`
     *
     */
    rowCount?: number;
    /**
     * 오른쪽 고정 컬럼의 위치
     *
     * @remarks
     * `true`일 경우 컨테이너 오른쪽에, `false`일 경우 맨 오른쪽 컬럼 뒤에 고정
     *
     * @defaultValue `true`
     */
    rightFixed?: boolean;
    /**
     * 고정 행의 필터링 불가 여부
     *
     * @defaultValue `true`
     */
    exceptFromFiltering?: boolean;
    /**
     * 고정 행의 정렬 불가 여부
     *
     * @defaultValue `true`
     */
    exceptFromSorting?: boolean;
    /**
     * 고정 컬럼의 수정 가능 여부
     *
     * @remarks
     * `false` 시 다른 속성들과 상관 없이 고정된 컬럼을 수정 불가
     *
     * @defaultValue `true`
     */
    editable?: boolean;
    /**
     * 고정 행의 수정 가능 여부
     *
     * @remarks
     * false 시 다른 속성들과 상관 없이 고정된 행을 수정 불가
     *
     * @defaultValue `true`
     */
    rowEditable?: boolean;
    /**
     * 고정 컬럼의 너비 변경 가능 여부
     *
     * @remarks
     * false시 다른 속성들과 상관 없이 사용자가 고정 컬럼의 너비를 변경 불가
     *
     * @defaultValue `false`
     */
    resizable?: boolean;
    /**
     * 고정 행의 높이 변경 가능 여부
     *
     * @remarks
     * false시 다른 속성들과 상관 없이 사용자가 고정 행의 높이를 변경 불가
     *
     * @defaultValue `false`
     */
    rowResizable?: boolean;
    /**
     * 고정 컬럼의 위치 변경 가능 여부
     *
     * @remarks
     * false시 다른 속성들과 상관 없이 사용자가 고정 컬럼의 위치를 변경할 수 없다.
     * 고정 컬럼 그룹에 포함된 컬럼들은 그룹 내에서 이동 가능하다.
     * 최상위 컬럼에만 해당된다.
     *
     * @defaultValue `false`
     */
    movable?: boolean;
    /**
     * 왼쪽 고정 컬럼 구분 바의 너비
     *
     * @defaultValue `3`
     */
    colBarWidth?: number;
    /**
     * 오른쪽 고정 컬럼 구분 바의 너비
     *
     * @defaultValue `3`
     */
    rightBarWidth?: number;
    /**
     * 고정 행 구분 바의 높이
     *
     * @defaultValue `3`
     */
    rowBarHeight?: number;
}

/**
 * columnGroup이 있을때 왼쪽화살표 또는 오른쪽 화살표를 입력했을때 focus이동 방식
 */
export declare enum FocusMoveStep {
    /**
     * 최상위 그룹단위로 이동한다.
     */
    GROUP = "group",
    /**
     * 셀단위로 이동한다.
     */
    CELL = "cell"
}

/**
 * @public
 *
 * focus를 layer형태로 표시하거나 테두리만 표시한다.
 *
 * {@link DisplayOptions.focusType} 에서 설정 가능하다.
 */
declare const enum FocusType {
    /**
     * 선택된 셀을 덮는 layer형태로 표시한다.
     */
    LAYER = "layer",
    /**
     * 선택된 셀의 테두리만 line으로 표시한다.
     */
    LINE = "line"
}

/**
 * 데이터 필드 값의 변환 형식에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFormatOptions({booleanFormat: 'wrong:correct'});
 * ```
 */
export declare interface FormatOptions {
    /**
     * 텍스트 형식의 값일 때 변환 서식
     *
     * @remarks
     * 세미콜론(;)으로 구분하여 왼쪽에는 String.prototype.replace의 첫 번째 매개변수, 오른쪽에는 두 번째 매개변수와 같은 타입으로 지정
     * 예) `'([A-Za-z]*); Mr\. \$1'`
     *
     */
    textFormat?: string;
    /**
     * 날짜 형식의 값일 때 변환 서식
     *
     * @remarks
     * 예) `'yy-M-dd'`
     *
     */
    datetimeFormat?: string;
    /**
     * 숫자 형식의 값일 때 변환 서식
     *
     * @remarks
     * 예) `'#,##0.###'`
     *
     */
    numberFormat?: string;
    /**
     * Boolean 형식의 값일 때 변환 서식
     *
     * @remarks
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
}

/**
 * {@link FormView} 의 푸터 영역에 관한 설정 모델
 *
 * @remarks
 * {@link FormView.setModel} 로 설정가능하다.
 */
export declare interface FormFooter {
    /**
     * 좌측 하단에 위치한 Popup Menu 의 이름
     *
     * @remarks
     * {@link GridBase.addPopupMenu} 로 추가한 Popup Menu 를 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.addPopupMenu("menuForm", [
     *     {
     *         label: "Grid",
     *         callback: function () {
     *             form.visible = false;
     *         }
     *     }, {
     *         label: "Delete Row",
     *         callback: function () {
     *             form.deleteRow();
     *         }
     *     }, {
     *         label: "Add Row",
     *         callback: function () {
     *             form.appendRow();
     *         }
     *     }
     * ]);
     *
     * form.setModel({
     *      footer: {
     *          popupMenu: "menuForm"
     *      },
     *      ...
     * })
     * ```
     */
    popupMenu?: string;
}

/**
 * {@link FormView} 의 아이템 설정 모델
 *
 * @remarks
 * 문자열로 설정하면 {@link FormItemObject.column} 으로 설정하여 FromItem 을 생성한다.
 *
 * @example
 * ```js
 * items:[{
 *        header: "이름",
 *        column: "KorName"
 *    },
 *    {
 *        header: "Address",
 *        template: "<span>Good!<br>121212</span>"
 *    },
 *    "Email" // 문자열로 설정
 * }]
 * ```
 */
export declare type FormItem = string | FormItemObject;

/**
 * {@link FormView} 의 오브젝트 형식의 아이템 설정 모델
 *
 * @remarks
 * {@link FormItem} 에 포함된다.
 *
 * @example
 * ```js
 * {
 *      items: [{
 *               header: "이름",
 *               column: "KorName"
 *           },
 *           {
 *               header: "성별",
 *               column: "SexLabel"
 *           },
 *           ...
 *      }]
 * }
 * ```
 */
export declare interface FormItemObject {
    /**
     * 해당 아이템이 표시될 때의 헤더 텍스트
     *
     * @remarks
     * 설정하지 않을 시 `column` (컬럼명) 으로 설정
     */
    header?: string;
    /**
     * 해당 아이템의 값을 표시하기 위한 컬럼명
     *
     * @remarks
     * 이 값을 지정하면 {@link FormItemObject.template} 을 사용할 수 없다.
     *
     * {@link FormModel.items} 설정 시 문자열만으로 설정 가능하다.
     *
     * @example
     * ```js
     * {
     *     header: "성별",
     *     column: "SexLabel"
     * }
     * ```
     */
    column?: string;
    /**
     * 해당 아이템의 값을 표시하기 위한 html 템플릿 형식
     *
     * @remarks
     * 이 값을 지정하면 {@link FormItemObject.column} 을 사용할 수 없다.
     *
     * @example
     * ```js
     * {
     *     header: "성별",
     *     template: "<span>Good!<br>121212</span>"
     * }
     * ```
     */
    template?: string;
}

/**
 * {@link FormView} 의 화면 구성을 생성하기 위한 설정 모델
 *
 * @example
 * ```js
 * {
 *      footer: {
 *          popupMenu: "menuForm"
 *      },
 *      items: [{
 *          header: "이름",
 *          column: "KorName"
 *      },
 *      {
 *          header: "성별",
 *          column: "SexLabel"
 *      },
 *      ...
 *      ]
 * }
 * ```
 */
export declare interface FormModel {

    /**
     * 화면에 배치되는 푸터 영역 모델
     */
    footer?: FormFooter;

    /**
     * 화면에 배치되는 아이템들의 모델
     *
     * @remarks
     * 오브젝트 또는 문자열 형태로 설정 가능 하다.
     */
    items?: FormItem[];
}

/**
 * {@link FormView} 에 관한 설정 모델
 */
export declare interface FormOptions {
    /**
     * modal 스타일로 FormView 를 보여줄 것인지의 여부
     *
     * @defaultValue `false`
     */
    modal: boolean;
    /**
     * modal 의 padding 간격
     *
     * @remarks
     * 4개 일 경우: `top`, `right`, `bottom`, `left` 순서대로 지정된다.
     *
     * 3개 일 경우: `top`, `left / right`, `bottom` 순서대로 지정된다.
     *
     * 2개 일 경우: `top / bottom`, `left / right` 순서대로 지정된다.
     *
     * 1개 일 경우: `top / bottom/ left / right` 의 간격을 지정한다.
     *
     * @defaultValue `'10%'`
     *
     * @example
     * ```js
     * // 4개
     * "50% 30 25% 40"
     * // 3개
     * "50% 30 25% "
     * // 2개
     * "50% 30"
     * // 1개
     * "50%"
     * ```
     */
    modalPadding: string;
    /**
     * modal 의 불투명도
     *
     * @remarks
     * 0 부터 1 사이의 값이다.
     */
    modalOpacity: number;
    /**
     * 값 수정후 save 나 cancel 시 자동으로 화면으로 닫히게 할지의 여부
     *
     * @defaultValue `false`
     */
    autoClose: boolean;
    /**
     * form 화면에서 편집 가능 여부
     *
     * @defaultValue `true`
     */
    editable: boolean;
    /**
     * 아이템 크기 조정 가능 여부
     *
     * @defaultValue `true`
     */
    itemResizable: boolean;
    /**
     * Label 의 최소 너비
     *
     * @defaultValue `60`
     */
    minLabelWidth: number;
    /**
     * focus 표시를 보이게 할지의 여부
     *
     * @defaultValue `true`
     */
    focusVisible: boolean;
    /**
     * 스크롤 바의 너비
     *
     * @defaultValue `9`
     */
    scrollBarWidth: number;
    /**
     * Swipe 할 때 커밋할 것인지의 여부
     *
     * @defaultValue `false`
     */
    commitWhenSwipe: boolean;

    /**
     * 저장 버튼을 클릭하면 호출된다.
     *
     * @defaultValue `null`
     *
     */
    commitCallback: FormViewButtonCallback;
    /**
     * 취소 버튼을 클릭하면 호출된다.
     *
     * @defaultValue `null`
     */
    cancelCallback: FormViewButtonCallback;
}

/**
 * @public
 *
 * {@link FormView} 의 FormValueItem 을 렌더링하기 위한 렌더러
 *
 * [상위 클래스]
 *
 * {@link CellRenderer}
 */
export declare interface FormTemplateRenderer extends CellRenderer {
    /**
     * 입력되는 html 템플릿 형태의 문자열
     *
     * @remarks
     * `valueCallback` 이 지정되지 않았을 경우 반영된다.
     */
    template?: string;
    /**
     * 결과물
     */
    output?: string;
    /**
     * 렌더링 시 표시되는 값을 지정하기 위한 콜백
     *
     * @eventProperty
     * @example
     * ```js
     * item.renderer = {
     *     type:"formHtml",
     *     template: "<img src='images/realgrid-logo.png' height='20'/><span>${value}-${value:unitprice}-</span><span style='color: red;font-weight: bold;'>${xxx}</span>",
     *     valueCallback: function (form, item, field) {
     *     if (field == "xxx") {
     *         return "1234";
     *     }
     * }
     * ```
     */
    valueCallback?: RealizeFormValueCallback;
}

/**
 * 모바일에 최적화 된 화면 모델
 *
 * @remarks
 * {@link GridBase.formView} 로 접근 할 수 있다.
 *
 * @example
 * ```js
 * let form = gridView.formView;
 * form.visible = true;
 * form.options.modal = true;
 * form.options.modalPadding = "10% 8%";
 * form.options.autoClose = true;
 *
 * let formModel = {
 *      items:[{
 *             header: "이름",
 *             column: "KorName"
 *         },
 *         {
 *             header: "성별",
 *             column: "SexLabel"
 *         },
 *         {
 *             header: "주문일",
 *             column: "OrderDate"
 *         },
 *         {
 *             header: "Address",
 *             template: "<span>Good!<br>121212</span>"
 *         },
 *         "Email"
 *      }]
 * }
 * form.setModel(formModel);
 * ```
 */
export declare interface FormView {
    /**
     * FormView 표시 여부
     *
     * @remarks
     * `true` 지정 시 FormView 를 해당 그리드 위에 표시한다.
     *
     * @defaultValue `false`
     */
    visible: boolean;
    /**
     * 현재 화면을 보여주고 있는 페이지 (그리드에서의 행)
     *
     * @example
     * ```js
     * // 첫번째 페이지로 돌아가기
     * formView.currentRow = 0;
     * ```
     */
    currentRow: number;
    /**
     * 해당 FormView 의 설정 정보
     *
     * @remarks
     * {@link FormOptions} 의 속성을 가져오거나 설정할 수 있다.
     */
    options: FormOptions;
    /**
     * 화면 구성을 설정한다.
     *
     * @example
     * ```js
     * form.setModel({
     *     items: [
     *         {
     *             header: "이름",
     *             column: "KorName"
     *         },
     *         {
     *             header: "성별",
     *             column: "SexLabel"
     *         },
     *         {
     *             header: "주문일",
     *             column: "OrderDate"
     *         },
     *         {
     *             header: "납입금",
     *             column: "SaveCost"
     *         },
     *         {
     *             header: "만기금액",
     *             column: "SaveMaturity"
     *         }
     *     ]
     * });
     * ```
     */
    setModel(value: FormModel): any;
}

/**
 * formView의 저장 또는 취소 버튼을 클릭했을때 실행되는 콜백
 *
 * @remarks
 * {@link FormOptions.commitCallback} 또는 {@link FormOptions.cancelCallback}에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `itemIndex` - 보여지고 있는 행의 itemIndex
 *
 * `item` - 선택된 행의 itemModel
 *
 * [반환값] - false를 return하면 버튼의 기본동작을 실행하지 않는다.
 * @example
 * ```js
 * grid.formOptions.commitCallback = function(grid, itemIndex, item) {
 *   var value = item.getRowObject.column;
 *   if (!isValid(value)) { // value 검증
 *     return false;
 *   }
 * }
 * ```
 */
declare type FormViewButtonCallback = (grid: GridBase, itemIndex: number, item: GridItem) => boolean;

/**
 * {@link CellRenderer.ariaLabelCallback} 에서 사용되는 콜백 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `model` - 그리드의 셀
 *
 * [반환값] - 스크린 리더가 읽을 문자열.
 *
 * @example
 * ```js
 * const f = function(grid, model) {
 *      var s = model.value;
 *      var date = grid.getValue(model.item.index, "date")
 *      s += (date.getTime() > Date.now() - 60*60*24*7*1000) ? " 신규" : "";
 *      return s;
 * }
 *
 * column.renderer = {
 *      type: 'text',
 *      ariaLabelCallback: f
 * }
 * ```
 */
export declare type GetAriaLabelCallback = (grid: GridBase, model: GridCell) => string;

/**
 * 이미지 렌더링 할 때 이미지의 alt 텍스트 설정 또는 링크 셀 렌더링 할 때 HTML Anchor Element의 title 텍스트를 설정을 위한 콜백 형식
 *
 * @remarks
 * {@link ImageCellRenderer.titleCallback} 또는 {@link LinkCellRenderer.titleCallback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `model` - 그리드의 셀
 *
 * [반환값] - alt 텍스트 또는 title 텍스트
 *
 * @example
 * ```js
 * const f = function(grid, model) {
 *      return 'catimage'
 * }
 * ```
 */
export declare type GetCellTitleCallback = (grid: GridBase, model: GridCell) => string;

/**
 * 렌더링 시 체크 값을 결정하는 콜백 형식
 *
 * @remarks
 * {@link CheckCellRenderer.getCheckedCallback} 에서 사용한다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `itemIndex` - 아이템의 순서
 *
 * `column` - 컬럼 객체
 *
 * `value` - 값
 *
 * [반환값] - 체크 여부
 *
 * @example
 * ```js
 * const f = function(grid, itemIndex, column, value) {
 *      if (typeof value === "number") {
 *          return value % 2 === 1;
 *      }
 *      else if (typeof value ==="boolean") {
 *          return value;
 *      }
 *      else {
 *          return Boolean(v);
 *      }
 * }
 * ```
 */
export declare type GetCheckedCallback = (grid: GridBase, itemIndex: number, column: DataColumn, value: any) => boolean;

/**
 * linkRenderer의 a tag에 class를 추가
 *
 * @remarks
 * {@link LinkCellRenderer}의 a tag에 class를 추가하는 경우 사용한다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `model` - 그리드의 셀
 *
 * [반환값] - string
 *
 * @example
 * ```js
 * const callback = function (grid, model) {
 *   let cls = "";
 *   model.value.indexOf("새글") > 0 && (cls += " new");
 *   model.value.indexOf("비밀글") > 0 && (cls += " lock");
 *   // link에 새글/비밀글 icon을 background형태로 추가하는 경우
 * }
 *
 * ```
 *
 */
export declare type GetClassCallback = (grid: GridBase, model: GridCell) => string;

/**
 * 이미지를 렌더링을 위해 이미지의 경로를 지정하는 콜백 형식
 *
 * @remarks
 * {@link ImageCellRenderer.imageCallback} 또는 {@link IconCellRenderer.iconCallback} 에서 사용된다.
 *
 * [프로퍼티 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `model` - 그리드의 셀
 *
 * [반환값] - 이미지 경로
 *
 * @example
 * ```js
 * const f = function(grid, model) {
 *      const base = '/images/';
 *      if (jpgSet.indexOf(model.value)){
 *          return base + model.value + '.jpg';
 *      }
 *      else base + 'default.jpg';
 * }
 * ```
 */
export declare type GetImageCallback = (grid: GridBase, model: GridCell) => string;

/**
 * {@link LinkCellRenderer.urlCallback} 에서 사용되는 콜백 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `model` - 그리드의 셀
 *
 * [반환값] - Url 주소
 *
 * @example
 * ```js
 * ...
 *      "renderer" : {
 *          "type": "link",
 *          "urlCallback": function (grid, cell) {
 *              return "http://realgrid.com";
 *          },
 *      }
 * ...
 * ```
 */
export declare type GetLinkUrlCallback = (grid: GridBase, model: GridCell) => string;

/**
 * 도형 렌더러에서 도형의 종류를 지정하기 위한 {@link ShapeCellRenderer.shapeCallback} 에서 사용하는 콜백 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `model` - 그리드의 셀
 *
 * [반환값] - 도형 종류, {@link PolygonShape} 또는 'ellipse' 이다.
 *
 * @example
 * ```js
 * const f = function(grid, model) {
 *      if (model.value) {
 *          return 'ellipse';
 *      }
 *      else {
 *          return 'minus';
 *      }
 * }
 * ```
 */
export declare type GetShapeCallback = (grid: GridBase, model: GridCell) => string;

/**
 * {@link TemplateCellRenderer.callback} 에 사용되는 콜백 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `model` - 그리드의 셀
 *
 * `width` - 셀의 너비
 *
 * `height` -  셀의 높이
 *
 * [반환값] - string type 의 template 형식
 *
 * @example
 * ```js
 * const f = function (grid, model, width, height) {
 *     return "<img src='images/realgrid-logo.png' height='" + height / 2 + "'></img>" + "<div>" + model.value + "</div>";
 * }
 *
 * column.renderer = {
 *     type: "html",
 *     callback: f
 * }
 * ```
 */
export declare type GetTemplateCallback = (grid: GridBase, model: GridCell, width: number, height: number) => string;

/**
 * @public
 * GridBase는 {@link GridView}와 {@link TreeView}의 기반 클래스(Base Class)이다.
 *
 * @remarks
 * GridBase 의 모든 속성과 method 는 이를 상속한 하위 클래스들에서만 호출할 수 있다.
 *
 * [하위 클래스]
 *
 * {@link GridView}
 *
 * {@link TreeView}
 *
 * @warning GridBase 로 직접 설정하거나 호출할 수 없다.
 */
export declare abstract class GridBase {





    constructor(container: string | HTMLDivElement, accessibility?: boolean, waiOptions?: WaiOptions);

    /**
     * 현재 그리드의 합계를 계산하는 방식
     *
     * @remarks
     * 그리드에 설정되어 있는 {@link SummaryMode} 를 반환한다.
     * 값 할당으로 변경할 수 있다.
     *
     * @example
     * ```js
     * gridView.summaryMode = "aggregate";
     * ```
     */
    get summaryMode(): SummaryMode;
    set summaryMode(value: SummaryMode);
    /**
     * 그리드에 설정되어 있는 삭제된 행들의 숨김 여부
     *
     * @remarks
     * 값 할당으로 변경할 수 있다.
     *
     * @example
     * ```js
     * gridView.hideDeletedRows = true;
     * ```
     */
    get hideDeletedRows(): boolean;
    set hideDeletedRows(value: boolean);
    /**
     * 데이터 수정 이후 정렬 동작 모드
     *
     * @remarks
     * 그리드에 설정되어 있는 {@link SortMode} 를 반환한다.
     * 값 할당으로 변경할 수 있다.
     *
     * @example
     * ```js
     * gridView.sortMode = "explicit";
     * ```
     */
    get sortMode(): SortMode;
    set sortMode(value: SortMode);
    /**
     * 실행취소 기능 사용 가능 여부
     * @remarks
     * 값 할당으로 변경할 수 있다.
     *
     * @example
     *
     * ```js
     * gridView.undoable = false
     * ```
     */
    get undoable(): boolean;
    set undoable(value: boolean);
    /**
     * 현재상태에서 실행취소 가능 여부
     *
     * @example
     *
     * ```js
     * gridView.undoing = false
     * ```
     */
    get undoing(): boolean;
    /**
     * 현재상태에서 재실행 가능 여부
     *
     * @example
     *
     * ```js
     * gridView.redoing = false
     * ```
     */
    get redoing(): boolean;
    /**
     * 그리드가 마우스/키보드 이벤트에 대하여 반응안함 상태
     *
     * @remarks
     * 값 할당으로 변경할 수 있다.
     *
     * @example
     * ```js
     * gridView.disabled = true;
     * ```
     */
    get disabled(): boolean;
    set disabled(value: boolean);
    /**
     * 스크롤바의 너비를 변경
     *
     * @defaultValue `16`
     *
     * @example
     * ```js
     * gridView.scrollBarWidth = 24;
     * ```
     */
    get scrollBarWidth(): number;
    set scrollBarWidth(value: number);
    /**
     * 스크롤바의 높이를 변경
     *
     * @defaultValue `16`
     *
     * @example
     * ```js
     * gridView.scrollBarHeight = 24;
     * ```
     */
    get scrollBarHeight(): number;
    set scrollBarHeight(value: number);
    /**
     * 그리드의 고정 행 및 컬럼에 대한 설정 모델
     *
     * @remarks
     * {@link FixedOptions} 객체를 반환한다.
     * FixedOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.fixedOptions.colCount = 2;
     * ```
     */
    get fixedOptions(): FixedOptions;
    /**
     * 그리드 수준에서 관리되는 표시 정보들에 대한 설정 모델
     *
     * @remarks
     * {@link DisplayOptions} 객체를 반환한다.
     * DisplayOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.displayOptions.columnResizable = true;
     * ```
     */
    get displayOptions(): DisplayOptions;
    /**
     * 데이터 필드 값의 변환 형식에 대한 설정 모델
     *
     * @remarks
     * {@link FormatOptions} 객체를 반환한다.
     * FormatOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.formatOptions.datetimeFormat = 'yyyy-mm-dd';
     * ```
     */
    get formatOptions(): FormatOptions;
    /**
     * 데이터 편집에 대한 설정 모델
     *
     * @remarks
     * {@link EditOptions} 객체를 반환한다.
     * EditOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.editOptions.deletable = true;
     * ```
     */
    get editOptions(): EditOptions;
    /**
     * 편집기에 대한 설정 모델
     *
     * @remarks
     * {@link EditorOptions} 객체를 반환한다.
     * EditorOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.editorOptions.yearDisplayFormat = "{Y}년";
     * ```
     */
    get editorOptions(): EditorOptions;
    /**
     * 클립보드에 복사하는 것에 대한 설정 모델
     *
     * @remarks
     * {@link CopyOptions} 객체를 반환한다.
     * CopyOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.copyOptions.singleMode = true;
     * ```
     */
    get copyOptions(): CopyOptions;
    /**
     * 클립보드의 데이터를 붙여 넣는 것에 대한 설정 모델
     *
     * @remarks
     * {@link PasteOptions} 객체를 반환한다.
     * PasteOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.pasteOptions.enabled = false;
     * ```
     */
    get pasteOptions(): PasteOptions;
    /**
     * 데이터 정렬에 대한 설정 모델
     *
     * @remarks
     * {@link SortingOptions} 객체를 반환한다.
     * SortingOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.sortingOptions.style = 'reverse';
     * ```
     */
    get sortingOptions(): SortingOptions;
    /**
     * 데이터 필터링에 대한 설정 모델
     *
     * @remarks
     * {@link FilteringOptions} 객체를 반환한다.
     * FilteringOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.filteringOptions.enabled = false;
     * ```
     */
    get filteringOptions(): FilteringOptions;
    /**
     * 모바일 관련 설정 모델
     *
     * @remarks
     * {@link MobileOptions| mobileOptions} 를 반환한다.
     * MobileOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.mobileOptions.longTapDuration = false;
     * ```
     */
    get mobileOptions(): MobileOptions;
    /**
     * 데이터 drag and drop 과 관련 된 설정 모델
     *
     * @remarks
     * {@link DataDropOptions| dataDropOptions} 를 반환한다.
     * DataDropOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.dataDropOptions.dropMode = 'copy';
     * ```
     */
    get dataDropOptions(): DataDropOptions;
    /**
     * 그리드 모바일 화면인 {@link FormView} 에 대한 설정 모델
     *
     * @example
     * ```js
     * gridView.formOptions.autoClose = true;
     * ```
     */
    get formOptions(): FormOptions;
    /**
     * 그리드의 인디케이터에 관한 설정 모델
     *
     * @remarks
     * {@link RowIndicator} 객체를 반환한다.
     * RowIndicator 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.rowIndicator.displayValue = 'row';
     * ```
     */
    get rowIndicator(): RowIndicator;
    /**
     * 그리드의 상태바에 관한 설정 모델
     *
     * @remarks
     * {@link StateBar} 객체를 반환한다.
     * StateBar 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.stateBar.mark = 'image';
     * ```
     */
    get stateBar(): StateBar;
    /**
     * 그리드의 체크바에 관한 설정 모델
     *
     * @remarks
     * {@link CheckBar} 객체를 반환한다.
     * CheckBar 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.checkBar.visibleOnly = true;
     * ```
     */
    get checkBar(): CheckBar;
    /**
     * 그리드의 헤더 영역에 관한 설정 모델
     *
     * @remarks
     * {@link GridHeader} 객체를 반환한다.
     * GridHeader 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.header.showTooltip = true;
     * ```
     */
    get header(): GridHeader;
    /**
     * 첫번째 푸터에 관한 설정 모델
     *
     * @remarks
     * {@link GridFooter} 객체를 반환한다.
     * GridFooter 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.footer.styleName = 'custom-footer-1';
     * ```
     */
    get footer(): GridFooter;
    /**
     * 푸터들에 관한 설정 모델
     *
     * @remarks
     * {@link GridFooter} 의 콜렉션 객체를 반환한다.
     * {@link GridFooterCollection} 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.footers.visible = false;
     * ```
     */
    get footers(): GridFooterCollection;
    /**
     * 그리드 헤더 영역에 표시되는 첫번째 Header Summary에 대한 설정 모델
     *
     * @remarks
     * {@link HeaderSummary} 객체를 반환한다.
     * HeaderSummary 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.headerSummary.visible = false;
     * ```
     */
    get headerSummary(): HeaderSummary;
    /**
     * 그리드 헤더 영역에 표시되는 Header Summary 에 대한 컬렉션 설정 모델
     *
     * @remarks
     * {@link HeaderSummary} 의 콜렉션 객체를 반환한다.
     * {@link HeaderSummaryCollection} 의 속성을 가져온다.
     *
     * @example
     * ```js
     * gridView.headerSummaries.visible = false;
     * ```
     */
    get headerSummaries(): HeaderSummaryCollection;
    /**
     *
     */
    get filterPanel(): FilterPanel;
    /**
     * 그리드의 모바일 전용 화면 모델
     *
     * @example
     * ```js
     * form = gridView.formView;
     * ```
     */
    get formView(): FormView;
    /**
     * form view와 grid view 사이에 활성 상태가 변경될 때 발생한다.
     */
    onViewActivated: (grid: GridBase, active: boolean) => void;
    /**
     * 그리드의 focus cell 의 위치 변경을 결정하는 콜백
     *
     * @remarks
     * 변경된 후에는 {@link GridBase.onCurrentChanged | onCurrentChanged} 를 호출한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `oldIndex` - 변경 전 셀 위치정보
     *
     * `newIndex` - 변경 되는 셀 위치정보
     *
     * [반환값] - callback 함수에서 명시적으로 `false`를 반환하면 current가 변경되지 않음
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCurrentChanging =  function (grid, oldIndex, newIndex) {
     *      console.log(oldIndex);
     *      console.log(newIndex);
     *      // return false; 를 하는 경우 위치 변경이 되지 않는다.
     * };
     * ```
     */
    onCurrentChanging: (grid: GridBase, oldIndex: CellIndex, newIndex: CellIndex) => boolean;
    /**
     * 그리드의 focus cell 의 위치 변경을 알리는 콜백
     *
     * @remarks
     * 변경되기 직전에는 {@link GridBase.onCurrentChanging | onCurrentChanging} 을 호출
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `newIndex` - 변경된 셀 위치정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCurrentChanged =  function (grid, newIndex) {
     *      console.log(newIndex);
     * }
     * ```
     */
    onCurrentChanged: (grid: GridBase, newIndex: CellIndex) => void;
    /**
     * 데이터 행의 위치가 변경됨을 알리는 콜백
     *
     * @remarks
     * {@link GridBase.onCurrentChanged | onCurrentChanged }의 경우 선택된 cell의 itemIndex가 변경되는 경우 발생된다.
     * 그러나 {@link GridBase.onCurrentRowChanged | onCurrentRowChanged } 의 경우 선택된 cell의 데이터 행의 index가 변경되는 경우에 발생한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `oldRow` - 변경 전 데이터 행의 위치
     *
     * `newRow` - 변경 후 데이터 행의 위치, `-1`인 경우 신규행이거나 또는 `dataProvider`가 비워진 경우이다.
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onCurrentRowChanged =  function (grid, oldRow, newRow) {
     *      console.log("oldRow => ", oldRow, "newRow => ", newRow);
     * };
     * ```
     */
    onCurrentRowChanged: (grid: GridBase, oldRow: number, newRow: number) => void;
    /**
     * 셀 편집을 완료하고 다른 셀로 이동할때 Javascript를 통한 사용자 검증 결과를 결정하는 콜백
     *
     * @remarks
     * 해당 컬럼 값에 문제가 있다면 검증 에러와 에러 메시지를 그리드에 반환값으로 전달한다.
     *
     * `level`과 `message` 값을 포함하는 오브젝트를 그리드에 전달하면 검증에 실패한 것으로 판단한다.
     *
     * {@link ValidationError} 형태로 반환해야 한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `column` - 컬럼 오브젝트
     *
     * `inserting` - `true`: 열 추가 중, `false`: 열 수정 중
     *
     * `value` - 입력된 필드의 값
     *
     * `itemIndex` - 셀편집된 행의 순서
     *
     * `dataRow` - 셀편집된 행의 고유 번호.
     *
     * [반환값] - {@link ValidationError}
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onValidateColumn =  function (grid, column, inserting, value, itemIndex, dataRow) {
     *      if (column.name != "Knock Knock") {
     *          return {
     *              level: 'warning';
     *              messsage: "It's a dad joke! Do not " + JSON.stringify(column);
     *          }
     *      }
     * };
     * ```
     */
    onValidateColumn: (grid: GridBase, column: GridColumn, inserting: boolean, value: any, itemIndex: number, dataRow: number) => ValidationError;
    /**
     * Javascript를 통한 행 단위 사용자 검증 결과를 결정하는 콜백
     *
     * @remarks
     * 해당 행의 값들에 문제가 있다면 검증 에러와 에러 메시지를 그리드에 반환값으로 전달한다.
     *
     * `level`과 `message` 값을 포함하는 오브젝트를 그리드에 전달하면 검증에 실패한 것으로 판단한다.
     *
     * {@link ValidationError} 형태로 반환해야 한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 검증하는 행의 순서
     *
     * `dataRow` - 검증하는 행의 고유 번호
     *
     * `inserting` - true: 열 추가 중, false: 열 수정 중
     *
     * `values` - 입력된 필드들의 값
     *
     * [반환값] - {@link ValidationError}
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onValidateRow =  function (grid, itemIndex, dataRow, inserting, values) {
     *      if (dataRow % 2 === 0) {
     *          return {
     *              level: 'info';
     *              messsage: "even!";
     *          }
     *      }
     * };
     * ```
     */
    onValidateRow: (grid: GridBase, itemIndex: number, dataRow: number, inserting: boolean, values: any[]) => ValidationError;
    /**
     * validation 실패시 발생하는 콜백
     *
     * @remarks
     * 콜백함수에서 별도의 에러 처리가 가능하고, err 객체를 return 하면 자체 Validation 메세지가 표시되고 그 외의 경우 표시되지 않는다.
     *
     * `level`과 `message` 값을 포함하는 오브젝트를 그리드에 전달하면 검증에 실패한 것으로 판단한다.
     *
     * {@link ValidationError} 형태로 반환해야 한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 검증하는 행의 인덱스
     *
     * `column` - 컬럼 오브젝트
     *
     * `error` - 검증 결과
     *
     * [반환값] - {@link ValidationError}
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onValidationFail = function (grid, itemIndex, column, err) {
     *     console.log("onValidationFail:" + itemIndex + "," + JSON.stringify(column) + "," + JSON.stringify(err));
     *     if (column.name != "Mortal") {
     *         var editValue = grid.getEditValue();
     *         err.message = "입력된 "+editValue+" 는 잘못된 값입니다";
     *         return err;
     *     }
     * }
     * ```
     *
     */
    onValidationFail: (grid: GridBase, itemIndex: number, column: GridColumn, error: ValidationError) => ValidationError;
    /**
     * 사용자의 컬럼 헤더 체크박스를 클릭을 알리는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `column` - 컬럼 오브젝트
     *
     * `checked` - 체크 여부
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onColumnCheckedChanged =  function (grid, col, chk) {
     *      console.log(col.name + "was checked as: " + chk);
     * };
     * ```
     */
    onColumnCheckedChanged: (grid: GridBase, column: GridColumn, checked: boolean) => void;
    /**
     * 추가한 팝업메뉴 항목의 클릭을 알리는 콜백
     *
     * @remarks
     * MenuItem에 {@link PopupMenuItem.callback | callback} 이 지정된 경우 호출되지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `item` - MenuItem 객체
     *
     * `clickData` - 클릭 된 아이템의 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onMenuItemClicked =  function (grid, item, clickData) {
     *      console.log(item.label + "was clicked.");
     * };
     * ```
     */
    onMenuItemClicked: (grid: GridBase, item: PopupMenuItem, clickData: ClickData) => void;
    /**
     * 좌표와 함께 ContextMenu 표시를 결정하는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `x` - ContextMenu 가 호출된 x좌표값
     *
     * `y` - ContextMenu 가 호출된 y좌표값
     *
     * `clickData` - 클릭 된 아이템의 정보
     *
     * [반환값] - `false`를 반환하면 컨텍스트 메뉴가 표시되지 않는다. 또 menuName을 return하는 경우 해당 menu가 표시된다.
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onContextMenuPopup =  function (grid, x, y, clickData) {
     *      console.log(clickData);
     * };
     * ```
     */
    onContextMenuPopup: (grid: GridBase, x: number, y: number, clickData: ClickData) => boolean | string;
    /**
     * {@link GridBase.setContextMenu | setContextMenu()} 를 통해 추가한 컨텍스트 메뉴 항목 클릭을 알리는 콜백
     *
     * @remarks
     * MenuItem에 callback이 지정된 경우 호출되지 않는다.
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `item` - 클릭된 메뉴 항목의 정보
     *
     * `clickData` - 클릭 된 아이템의 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onContextMenuItemClicked =  function (grid, item, clickData) {
     *      console.log(clickData);
     * };
     * ```
     */
    onContextMenuItemClicked: (grid: GridBase, item: PopupMenuItem, clickData: ClickData) => void;
    /**
     * 사용자가 데이터 셀 내부의 action 버튼을 클릭했을 때 호출한다.
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 데이터 셀이 포함된 아이템의 위치정보
     *
     * `column` - 데이터 셀에 연결된 컬럼
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCellButtonClicked =  function (grid, index, col) {
     *      console.log(index);
     * };
     * ```
     */
    onCellButtonClicked: (grid: GridBase, index: CellIndex, column: GridColumn) => void;
    /**
     * 사용자가 키보드나 스크롤 바 등을 조작하여 그리드에 마지막 행이 표시될 때 호출되는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onScrollToBottom =  function (grid) {
     *     var data = {"SearchKey":"searchData"},
     *     $.ajax({
     *         url:"/loadData.do",
     *         data: data,
     *         type:"post",
     *         async:false,
     *         success: function (data, textStatus) {
     *             grid.fillJsonData(data.dataList, {fillMode:"append"});
     *         }
     *     })
     * });
     * ```
     */
    onScrollToBottom: (grid: GridBase) => void;
    /**
     * 수직 스크롤 바의 위치가 변경됨을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 스크롤 중일때 그리드 상단에 표시되는 itemIndex 값
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onTopIndexChanged = function (grid, idx) {
     *      console.log(idx + "was changed!");
     * }
     * ```
     */
    onTopIndexChanged: (grid: GridBase, itemIndex: number) => void;
    /**
     * gridView.topIndex가 변경될때 호출되는 콜백
     *
     * @remarks
     *
     * 스크롤할때 사용자가 지정한 값만큼 이동할때 사용한다.
     * 페이지에 보여지는 값 이상을 return하지 말아야 한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `currentTop` - 변경되기전 topIndex
     *
     * `delta` - 변경값
     *
     * `focusing` - 포커스 변경에 의해서 topIndex가 변경되는 경우 `true`
     *
     * `adjust` - 그리드 내부에서 위치를 조정하는 경우 `true`
     *
     * [반환값] - `number`를 return하면 해당 값만큼 topIndex를 이동한다.
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * var userSetTopItem = false;
     * grid.onTopIndexChanging = function(_grid, current, delta, focusing, adjust) {
     * // mergeCell을 block처럼 사용하는 경우 스크롤도 block단위로 이동하기 위해서 사용한다.
     * // setTopItem의 경우 이벤트에서는 구분할수 없기 때문에 외부에서 구분할수 있는 값을 주어야 한다.
     * // rowGrouping된 경우는 아래 코드를 그대로 사용할수는 없다.
     *
     *     var fcnt = _grid.fixedOptions.rowCount;
     *     // 첫행으로 이동하거나 마지막행으로 이동되는 경우 또는 그리드 내부에서 위치를 보정하는 경우 'null'을 return하면 원래 이동하려는  delta값 만큼 이동한다.
     *     if (current + delta + _grid.fullItemCount() + fcnt >= _grid.getItemCount() || current + delta === 0 || (adjust && !focusing)) {
     *         console.log(current, delta, `scroll bottom or Top or adjust = ${adjust}`);
     *         return;
     *     }
     *
     *     var top = current + delta;  // 그리드가 이동하려는 topIndex
     *     var items = _grid.getMergedItems(top + fcnt, "merge컬럼", true, true);  // 이동할 block의 items
     *     var curItems = _grid.getMergedItems(current + fcnt, "merge컬럼", true, true);  // 현재 top block의 items
     *
     *     if (delta < 0 || top === items[0] + fcnt || userSetTopItem) {  // 위로 스크롤하거나 fixedRow가 있으면서 최상단으로 이동 또는 사용자가 setTopItem을 했을때
     *         top = items[0]; // 블록의 첫번째 행이 topIndex
     *     } else { // 아래쪽으로 스크롤 했을때
     *         top = items[0] === curItems[0] ? items[items.length - 1] + 1 : top = items[0]
     *     }
     *
     *     return top - current - fcnt;
     * }
     *
     * function setTop(index) {
     *     userSetTopItem = true;
     *     grid.setTopItem(index);
     *     userSetTopItem = false;
     * }
     * ```
     */
    onTopIndexChanging: (grid: GridBase, currentTop: number, delta: number, focusing: boolean, adjust: boolean) => number;
    /**
     * 수평 스크롤 바의 위치가 변경됨을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `pos` - 스크롤 중일때 그리드 왼쪽 위치
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onLeftPosChanged = function (grid, pos) {
     *      console.log(pos + " was changed!");
     * }
     * ```
     */
    onLeftPosChanged: (grid: GridBase, pos: number) => void;
    /**
     * 사용자가 Ctrl+Del 키를 누르거나 {@link GridBase.deleteSelection | deleteSelection() } 으로 삭제할 때, 실제 삭제를 결정하는 콜백
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `rows` - 삭제하려는 행들의 데이터 행 순서들의 배열
     *
     * [반환값] - null이 아닌 값을 반환하면 지정 텍스트를 표시하고 삭제를 취소한다.
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onRowsDeleting = function (grid, rows) {
     *      console.log('Deleted: ' + rows.join());
     * }
     * ```
     */
    onRowsDeleting: (grid: GridBase, rows: number[]) => boolean;
    /**
     * 사용자가 Insert 키를 눌러 새로운 행을 삽입하거나, 마지막 행에서 아래 화살표를 눌러 행을 추가하는 것을 결정하는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 행 삽입 위치의 순서
     *
     * `dataRow` - 행 삽입 위치의 고유 id
     *
     * [반환값] - 행 추가를 금지 시킬 때 사용자에게 표시할 메시지
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onRowInserting = function (grid, itemIndex, dataRow) {
     *      console.log('Inserted: ' + dataRow + ' at ' + itemIndex);
     * }
     * ```
     */
    onRowInserting: (grid: GridBase, itemIndex: number, dataRow: number) => boolean;
    /**
     * 사용자가 마우스나 키보드로 선택 영역을 변경했을때 기존 선택 영역이 제거 되었음을 알리는 콜백
     *
     * @remarks
     * 기존 선택영역이 없는 경우 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSelectionCleared = function (grid) {
     *      console.log('Selection cleared');
     * }
     * ```
     */
    onSelectionCleared: (grid: GridBase) => void;
    /**
     * 사용자가 마우스나 키보드로 선택 영역의 크기를 변경했음을 알리는 콜백
     *
     * @remarks
     * 변경 중인 선택 영역의 정보는 {@link GridBase.getSelectionData | getSelectionData} 함수로 알 수 있다.
     * {@link DisplayOptions.selectionStyle | GridBase.displayOptions.selectionStyle} 이 {@link SelectionStyle.NONE} 인 경우 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * `selection` - 선택 영역 정보
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSelectionChanged = function (grid) {
     *      console.log('Selection changed!');
     * }
     * ```
     */
    onSelectionChanged: (grid: GridBase, selection: Selection) => void;
    /**
     * 선택 영역이 새로 추가됨을 알리는 콜백
     * @deprecated
     * 2.6.0 버전 이후 제거될 예정
     *
     * @remarks
     * 변경 중인 선택 영역의 정보는 {@link GridBase.getSelectionData | getSelectionData} 함수로 알 수 있다.
     * {@link Selection.style | GridBase.getSelection().style} 이 {@link SelectionStyle.NONE} 인 경우 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `selection` - 선택 영역 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSelectionAdded = function (grid, selection) {
     *      console.log(selection);
     * }
     * ```
     */
    onSelectionAdded: (grid: GridBase, selection: Selection) => void;
    /**
     * 사용자가 마우스로 선택 영역 변경 완료를 알리는 콜백
     * @deprecated
     * 2.6.0 버전 이후 제거될 예정
     *
     * @remarks
     * 변경된 선택 영역의 정보는 {@link GridBase.getSelection | getSelection} 함수로 알수 있고 선택영역의 데이터는 {@link GridBase.getSelectionData | getSelectionData} 함수로 알 수 있다.
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * `selection` - 선택 영역 정보
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onSelectionEnded = function (grid) {
     *      let cells = grid.getSelectionData();
     *      console.log(cells);
     * }
     * ```
     */
    onSelectionEnded: (grid: GridBase, selection: Selection) => void;
    /**
     * Cell 별로 열리는 Editor 의 표시를 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 편집기가 열리려는 셀의 위치정보
     *
     * `props` - {@link CellEditor | 셀 편집기} 설정 정보
     *
     * `attrs` - 내부 편집기 element attributes. 사용자가 임의로 지정할 수 있는 값들.
     *
     * [반환값] - false 를 return하면 Editor가 표시되지 않는다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onShowEditor = function (grid, index, props, attrs) {
     *      console.log("onShowEditor:" + index.itemIndex + "," + index.column);
     *      if (index.column == "OrderID") {
     * 	        props.textCase = 'upper';
     *      }
     * }
     * ```
     */
    onShowEditor: (grid: GridBase, index: CellIndex, props: any, attrs: any) => boolean;
    /**
     * 편집이 완료되고 편집기가 사라진 것을 알리는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 편집된 셀의 위치정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onHideEditor = function (grid, index) {
     *      console.log("onHideEditor:" + index.itemIndex + "," + index.column);
     * }
     * ```
     */
    onHideEditor: (grid: GridBase, index: CellIndex) => void;
    /**
     * 아이템이 사용자의 Key 입력 등으로 값이 변경되었음을 알리는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 현재 focus 된 셀의 위치정보
     *
     * `value` - 편집 중인 셀의 데이터 값
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditChange = function (grid, index, value) {
     *      console.log("grid.onEditChange driven, " + index.column + ' at ' + index.dataRow + ' was replaced by value: ' + value);
     * }
     * ```
     */
    onEditChange: (grid: GridBase, index: CellIndex, value: any) => void;
    /**
     * 셀 편집이 완료되었을 때 셀의 위차와 편집결과를 갖고 있는 콜백
     *
     * @remarks
     * DropDownCellEditor, SearchCellEditor, MultiCheckCellEditor의 경우 editResult.text에는 labels에 해당하는 값이 출력되고 editResult.value에는 values에 해당하는 값이 출력된다.
     *
     * DateCellEditor의 경우에는 editResult.text에는 editor의 datetimeFormat으로 Formatting된 값이 출력되고 editResult.value에는 Date객체가 출력된다.
     *
     * 다른 Editor의 경우 text와 value에 동일한 값이 출력된다.
     *
     * {@link EditResult} 의 형태로 출력된다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 편집된 셀의 위치정보
     *
     * `editResult` - 편집된 셀의 text와 value를 속성으로 갖는 단순한 객체, 셀 편집기의 종류에 따라 출력되는 값이 달라진다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onGetEditValue = function (grid, index, editResult) {
     *      console.log(editResult);
     * }
     * ```
     */
    onGetEditValue: (grid: GridBase, index: CellIndex, editResult: Object) => void;
    /**
     * 사용자 입력이 셀에 반영함을 결정하는 콜백
     *
     * @remarks
     * 편집 중인 셀에서 다른 셀로 이동하거나 또는 {@link GridBase.commitEditor | commitEditor()} 를 호출하면 발생한다.
     * {@link GridBase.setValue | setValue()} 등 사용자 코드로 변경될때는 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 변경된 셀의 위치 정보
     *
     * `oldValue` - 편집전 셀의 데이터 값
     *
     * `newValue` - 편집후 셀의 데이터 값
     *
     * [반환값] - `false` 를 반환 시 셀에 반영되지 않는다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditCommit = function (grid, index, oldValue, newValue) {
     *      if (newValue === '') {
     *          return false;
     *      }
     *      console.log(oldValue + 'was changed to ' + newValue);
     * }
     * ```
     */
    onEditCommit: (grid: GridBase, index: CellIndex, oldValue: any, newValue: any) => boolean;
    /**
     * 사용자가 편집중 ESCAPE 키를 입력하거나 {@link GridBase.cancel | cancel()} 이 호출되어 편집이 취소됨을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 편집이 취소된 데이터 셀의 위치정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditCommit = function (grid, index) {
     *      console.log("Edit Cannceled at " + index.column);
     * }
     * ```
     */
    onEditCanceled: (grid: GridBase, index: CellIndex) => void;
    /**
     * 사용자가 행 편집을 취소했음을 알리는 콜백
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 편집이 취소된 행의 순서
     *
     * `state` - 편집 취소된 행의 상태
     *
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onItemEditCanceled = function (grid, itemIndex, state) {
     *      console.log(state);
     * }
     * ```
     */
    onItemEditCanceled: (grid: GridBase, itemIndex: number, state: string) => void;
    /**
     * 사용자가 행 편집을 취소를 결정하는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 편집이 취소된 행의 순서
     *
     * `state` - 편집 취소된 행의 상태이다. updating, inserting, appending 이 반환된다.
     *
     * [반환값] - 기본값: `true`, `false` 를 반환하면 행 편집 취소가 취소된다. (계속 편집 상태)
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onItemEditCancel = function (grid, itemIndex, state) {
     *      console.log(state);
     *      if (itemIndex % 5 === 0) {
     *          return false;
     *      }
     * }
     * ```
     */
    onItemEditCancel: (grid: GridBase, itemIndex: number, state: string) => boolean;
    /**
     * 검색을 했음을 알리는 콜백
     *
     * @remarks
     * {@link SearchCellEditor}에서 {@link SearchCellEditor.searchLength | searchLenght} 와 {@link SearchCellEditor.searchDelay | searchDelay} 조건이 만족하면 발생한다. 또는 Ctrl+Enter 키 또는 Enter 키를 입력시 발생한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 변경된 셀 위치정보
     *
     * `text` - 셀에 입력된 값
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditSearch = function (grid, index, text) {
     *      console.log(text + ' was searched!');
     * }
     * ```
     *
     */
    onEditSearch: (grid: GridBase, index: CellIndex, text: string) => void;
    /**
     * {@link SearchCellEditor} 에서 버튼을 클릭했음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 클릭된 셀 위치정보
     *
     * `text` - 셀에 입력된 값
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSearchCellButtonClick = function (grid, index, text) {
     *      console.log(text + ' button was clicked!');
     * }
     * ```
     *
     */
    onSearchCellButtonClick: (grid: GridBase, index: CellIndex, text: string) => void;
    /**
     * 수정이나 추가 중인 편집 아이템의 한 필드값이 편집 완료되었음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 편집 중인 행의 순서
     *
     * `row` - 편집 중인 행의 고유 번호
     *
     * `field` - 방금 편집된 필드의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCellEdited = function (grid, itemIndex, row, field) {
     *      console.log('Edit done! at ' + itemIndex + ', ' + field);
     * }
     * ```
     *
     */
    onCellEdited: (grid: GridBase, itemIndex: number, row: number, field: number) => void;
    /**
     * 사용자 입력으로 변경된 값이 행에 반영되었음을 알리는 콜백
     *
     * @remarks
     * {@link PasteOptions.noEditEvent | pasteOptions.noEditEvent} 가 `true` 면 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 변경된 행의 순서
     *
     * `row` - 변경된 행의 고유 번호
     *
     * `field` - 변경된 필드의 인덱스
     *
     * `oldValue` - 편집전 셀의 데이터 값
     *
     * `newValue` - 편집후 셀의 데이터 값
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditRowChanged = function (grid, itemIndex, dataRow, field, oldValue, newValue) {
     *     let v = grid.getValue(itemIndex, field);
     *     console.log("onEditRowChanged, " + field + ": " + oldValue + " => " + newValue);
     * };
     * ```
     */
    onEditRowChanged: (grid: GridBase, itemIndex: number, row: number, field: number, oldValue: any, newValue: any) => void;
    /**
     * 그리드 셀에 붙여넣기 했음을 알리는 콜백
     *
     * @remarks
     * 여러 행을 붙여넣기 할때는 {@link GridBase.onRowsPasted | onRowsPasted} 참조
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 변경된 행의 순서
     *
     * `row` - 변경된 행의 고유 번호
     *
     * `fields` - 필드의 인덱스들
     *
     * `oldValues` - 편집전 셀의 데이터 값들
     *
     * `newValues` - 편집후 셀의 데이터 값들
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditRowPasted = function (grid, itemIndex, row, fields, oldValues, newValues) {
     *     console.log('Row pasted!: {' + newValues.join() + '}');
     * };
     * ```
     */
    onEditRowPasted: (grid: GridBase, itemIndex: number, row: number, fields: number[], oldValues: any[], newValues: any[]) => void;
    /**
     * 여러 행을 붙여넣기 했음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `items` - 붙여넣기된 행들의 그리드에서의 순서
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onRowsPasted = function (grid, items) {
     *     console.log('Rows pasted!: ' + items.join());
     * };
     * ```
     *
     */
    onRowsPasted: (grid: GridBase, items: number[]) => void;
    /**
     * 셀에 붙여넣기를 결정하는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 클릭된 데이터 셀의 위치정보
     *
     * `value` - 붙여넣기 중인 데이터 값
     *
     * [반환값] - `false`를 반환하면 그 셀에는 붙여넣기가 되지 않는다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCellPasting = function (grid, index, value) {
     *      if (value === 'hello') {
     *          return false;
     *      }
     * };
     * ```
     */
    onCellPasting: (grid: GridBase, index: CellIndex, value: any) => boolean;
    /**
     * 사용자가 checkBar의 체크박스를 클릭하거나 checkItem을 호출하여 체크를 변경했음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 체크된 데이터 행의 순서
     *
     * `checked` - 체크가 되었으면 `true`, 해제되었으면 `false`가 출력
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onItemChecked = function (grid, itemIndex, checked) {
     *     console.log('Checked as ' + checked + ' at ' + itemIndex);
     * };
     * ```
     */
    onItemChecked: (grid: GridBase, itemIndex: number, checked: boolean) => void;
    /**
     * 사용자가 checkBar의 Header를 클릭하여 전체선택, 해제를 하거나 또는 checkAll `true` / `false` 을 입력하여 전체선택, 해제를 했음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `checked` - 체크가 되었으면 true, 해제가 되었으면 false가 출력
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onItemAllChecked = function (grid, checked) {
     *     console.log('All checked as ' + checked);
     * };
     * ```
     */
    onItemAllChecked: (grid: GridBase, checked: boolean) => void;
    /**
     * 그리드에 발생한 에러창을 클릭했음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `error` - 에러 메세지
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onErrorClicked = function (grid, error) {
     *     console.log(error);
     * }
     * ```
     */
    onErrorClicked: (grid: GridBase, error: string) => void;
    /**
     * 정렬을 결정하는 콜백
     *
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `fields` - 정렬하는 필드의 목록
     *
     * `direction` - 각 필드에 대한 정렬 방식 목록
     *
     * [반환값] - `false` 를 반환하면 정렬은 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSorting = function (grid) {
     *      if (fields.length > 5) {
     *          return false;
     *      }
     * }
     * ```
     */
    onSorting: (grid: GridBase, fields: number[], directions: string[]) => boolean;
    /**
     * 정렬했음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSortingChanged = function (grid) {
     *     console.log('Sorted! ');
     * }
     * ```
     *
     */
    onSortingChanged: (grid: GridBase) => void;
    /**
     * 필터링을 결정하는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * [반환값] - 기본값: `true`, 필터링 실행 여부를 지정한다. `false` 를 반환하면 필터링은 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onFiltering = function (grid) {
     *      return false;
     * }
     * ```
     */
    onFiltering: (grid: GridBase) => boolean;
    /**
     * 컬럼에 필터들이 설정되어 있고, 그 필터의 상태가 변경되었음을 알리는 콜백
     *
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `column` - 필터링된 컬럼 정보
     *
     * `filter` - 해당 필터의 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onFilteringChanged = function (grid, column, filter) {
     *      console.log('Filter changed!');
     * }
     * ```
     */
    onFilteringChanged: (grid: GridBase, column: GridColumn, filter: ColumnFilter) => void;
    /**
     * Wheel Event가 발생했음을 알리는 콜백
     *
     * @remarks
     * Mouse Wheel을 돌리면 발생한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `event` - WheelEvent
     *
     * [반환값] - Wheel Event를 무시하려면 false 를 반환한다/
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onWheel = function (grid, event) {
     *      console.log('You wheeled... ' + "event);
     * }
     * ```
     */
    onWheel: (grid: GridBase, event: WheelEvent) => boolean;
    /**
     * 키 입력을 결정하는 콜백
     *
     * @remarks
     * KeyDown 될 때 발생한다.
     * 키를 입력하고 있는 동안 계속 발생된다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `event` - KeyboardEvent
     *
     * [반환값] - 키 입력을 금지할때 false 를 반환한다/
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onKeyDown = function (grid, event) {
     *      console.log('You pressed... ' + "event);
     * }
     * ```
     */
    onKeyDown: (grid: GridBase, event: KeyboardEvent) => boolean;
    /**
     * 키가 입력되고 있음을 알리는 콜백
     *
     * @remarks
     * KeyPress 될 때 발생한다.
     * 키를 입력하고 있는 동안 계속 발생된다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `event` - KeyboardEvent
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onKeypross = function (grid, event) {
     *      console.log('You are pressing... ' + event);
     * }
     * ```
     */
    onKeyPress: (grid: GridBase, event: KeyboardEvent) => void;
    /**
     * 키를 입력하였음을 알리는 콜백.
     *
     * @remarks
     * KeyUp 될 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `event` - KeyboardEvent
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onKeyUp = function (grid, event) {
     *      console.log('You pressed... ' + "event);
     * }
     * ```
     */
    onKeyUp: (grid: GridBase, event: KeyboardEvent) => void;
    /**
     * 데이터 셀의 툴팁이 표시되었음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤.
     *
     * `index` - 마우스 포인터가 위치한 영역의 셀 위치정보
     *
     * `value` - 마우스 포인터가 위치한 데이터
     *
     * [반환값] - 툴팁에 표시할 값. 아무것도 return 하지 않으면 Tooltip이 표시되지 않는다.
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onShowTooltip = function (grid, index, value) {
     *      if (index % 7 === 0) {
     *              return '7-multiple Row!'
     *      }
     * }
     * ```
     */
    onShowTooltip: (grid: GridBase, index: CellIndex, value: any) => any;
    /**
     * 컬럼 헤더의 툴팁이 표시되었음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `column` - 툴팁이 표시될 컬럼 GroupHeader이면 해당 Group의 첫번째 Column
     *
     * `value` - 툴팁에 표시될 값. 기본값으로 컬럼헤더 text가 전달된다.
     *
     * `layout` - 툴팁이 표시될 컬럼의 layout
     *
     * [반환값] - 툴팁에 표시할 값. 아무것도 return 하지 않으면 Tooltip이 표시되지 않는다.
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onShowHeaderTooltip = function (grid, column, value, layout) {
     *     return 'header-tooltip: ' + value;
     * }
     * ```
     */
    onShowHeaderTooltip: (grid: GridBase, column: GridColumn, value: any, layout: CellLayoutItem) => any;
    /**
     *
     * @deprecated
     * 컬럼의 속성 중 width, displayIndex, visible 속성값이 변경되었음을 알리는 콜백
     * {@link GridBase.onLayoutPropertyChanged}로 대체
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `column` - 변경된 컬럼의 정보
     *
     * `property` - 컬럼의 displayWidth, displayIndex, visible 속성 중 변경된 것
     *
     * `value` - 변경된 값이 전달된다.
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onColumnPropertyChanged = function (grid, column, property, newValue, oldValue) {
     *
     *         console.log(column + "s props werer changed!");
     * }
     * ```
     */
    onColumnPropertyChanged: (grid: GridBase, column: GridColumn, property: string, newValue: any, oldValue: any) => void;
    /**
     *
     * Layout의 속성 중 displayWidth, displayIndex, visible 속성값이 변경되었음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `layout` - 변경된 layout의 정보
     *
     * `property` - 컬럼의 displayWidth, displayIndex, visible 속성 중 변경된 것
     *
     * `newValue` - 변경후 값이 전달된다.
     *
     * `oldValue` - 변경전 값이 전달된다.
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onLayoutPropertyChanged = function (grid, layout, property, newValue, oldValue) {
     *
     *         console.log(layout + "s props werer changed!");
     * }
     * ```
     */
    onLayoutPropertyChanged: (grid: GridBase, layout: CellLayoutItem, property: string, newValue: any, oldValue: any) => void;
    /**
     * 그리드가 선택되었음을 알리는 콜백
     *
     * @remarks
     * grid를 전역변수에 저장해서 사용하는 것이 좋다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onGridActivated = function (grid) {
     *      alert('Selected!');
     * }
     * ```
     */
    onGridActivated: (grid: GridBase) => void;
    /**
     * control + c 키로 복사하기를 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `selection` - 선택 영역 정보
     *
     * `event` - 이벤트 정보 ({@link https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent| ClipboardEvent})
     *
     * [반환값] - `false`를 반환하면 복사하기가 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCopy = function(grid, selection, event) {
     *      let data = JSON.stringify(grid.getSelectionData());
     *      if (data) {
     *      	data = 'onCopy\r\n' + data;
     *      	if (window.clipboardData) {
     *      		window.clipboardData.setData("Text", data);
     *      	} else {
     *      		event.clipboardData.setData('text/plain', data);
     *      	}
     *      }
     *      return false;
     * }
     * ```
     */
    onCopy: (grid: GridBase, selection: Selection | Selection[], event: ClipboardEvent) => boolean;
    /**
     * 그리드에 붙여넣기를 결정하는 콜백
     *
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 셀 위치정보
     *
     * `event` - 이벤트 정보 ({@link https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent| ClipboardEvent})
     *
     * [반환값] - `false`를 반환하면 붙여넣기가 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onPaste = function (grid, index, event){
     *     console.log("Pasting Starts!");
     * }
     * ```
     */
    onPaste: (grid: GridBase, index: CellIndex, event: ClipboardEvent) => boolean;
    /**
     * 그리드에 붙여넣기 했음을 알리는 콜백
     *
     * @remarks
     * 입력 편집기가 표시된 상태에서는 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onPasted = function (grid){
     *     console.log("Pasted!");
     * }
     * ```
     */
    onPasted: (grid: GridBase) => void;
    /**
     * 사용자가 checkBar의 체크박스를 클릭하거나 checkItem을 호출하여 체크를 변경했음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `items` - 체크된 데이터 행의 순서
     *
     * `checked` - `true`: 체크, `false`: 해제
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onItemsChecked = function (grid, items, checked){
     *     console.log(items.join() + ' are checked as ' + checked);
     * }
     * ```
     */
    onItemsChecked: (grid: GridBase, items: number[], checked: boolean) => void;
    /**
     * 그리드 셀이 클릭되었음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `clickData` - 클릭된 셀 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCellClicked = function (grid, clickData) {
     *      console.log(clickData);
     * }
     * ```
     */
    onCellClicked: (grid: GridBase, clickData: ClickData) => void;
    /**
     * 그리드 셀이 더블 클릭되었음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `clickData` - 클릭된 셀 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCellDblClicked = function (grid, clickData) {
     *      console.log(clickData);
     * }
     * ```
     */
    onCellDblClicked: (grid: GridBase, clickData: ClickData) => void;
    /**
     * 그리드 셀에 포함된 엘리먼트가 클릭되었음을 알리는 콜백
     *
     * @remarks
     * 이 이벤트 내에서 클릭을 처리했다면 반드시 `false`를 리턴해야 element의 기본 동작을 실행하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 클릭된 데이터 셀의 위치정보
     *
     * `clickData` - 클릭된 셀 정보
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onCellItemClicked = function (grid, index, clickData) {
     *      console.log(clickData);
     *      return true;
     * }
     * ```
     */
    onCellItemClicked: (grid: GridBase, index: CellIndex, clickData: ClickData) => boolean;
    /**
     * CommandStack이 바뀌었음을 알리는 콜백
     *
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `undoable` - 뒤로
     *
     * `redoable` - 앞으로
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCommandStackChanged =  function (grid, undoable, redoable) {
     *      if (undoable === true) {
     *          console.log('You can undo now!');
     *      }
     * };
     * ```
     */
    onCommandStackChanged: (grid: GridBase, undoable: boolean, redoable: boolean) => void;
    /**
     * dataProvider.setRows()를 실행한 이후 그리드 refresh가 완료된 후 발생하는 콜백
     *
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onDataLoadComplated =  function (grid) {
     *      console.log("Grid DataLoadComplated")
     * };
     * ```
     */
    onDataLoadComplated: (grid: GridBase) => void;
    /**
     * 그룹 Layout 펼치기를 결정하는 콜백
     *
     * @remarks
     * `false`를 return 하면 펼치기가 취소된다.
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `layout` - 펼칠 그룹 layout
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     *
     * ```js
     * gridView.onLayoutExpanding = function(grid, layout) {
     *     if (layout.name === "group0") {
     *         return false;
     *     }
     * }
     * ```
     */
    onLayoutExpanding: (grid: GridBase, layout: CellLayoutGroupItem) => boolean;
    /**
     * 그룹 Layout이 펼쳐졌음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     * `grid` - GridBase 컨트롤
     *
     * `layout` - 펼칠 그룹 layout
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     *
     * ```js
     * gridView.onLayoutExpanded = function(grid, layout) {
     *     console.log("Layout Expanded => " + layout.name)
     * }
     * ```
     */
    onLayoutExpanded: (grid: GridBase, layout: CellLayoutGroupItem) => void;
    /**
     * 그룹 Layout 접기를 결정하는 콜백
     *
     * @remarks
     * `false`를 return 하면 접기가 취소된다.
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `layout` - 접는 그룹 layout
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     *
     * ```js
     * gridView.onLayoutCollapsing = function(grid, layout) {
     *     if (layout.name === "group0") {
     *         return false;
     *     }
     * }
     * ```
     */
    onLayoutCollapsing: (grid: GridBase, layout: CellLayoutGroupItem) => boolean;
    /**
     * 그룹 Layout이 접혔음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     * `grid` - GridBase 컨트롤
     *
     * `layout` - 접힌 그룹 layout
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     *
     * ```js
     * gridView.onLayoutCollapsed = function(grid, layout) {
     *     console.log("Layout Collapsed => " + layout.name)
     * }
     * ```
     */
    onLayoutCollapsed: (grid: GridBase, layout: CellLayoutGroupItem) => void;
    /**
     * alert 창에 입력된 메시지를 표시한다.
     *
     * @param message - 입력된 메세지
     * @example
     *
     * ```
     * gridView.ping("테스트");
     * ```
     */
    ping(message: any): void;
    /**
     * 그리드를 내부적으로 새로 그린다.
     *
     * @example
     * ```
     * gridView.refresh()
     * ```
     */
    refresh(force?: boolean): void;
    /**
     * 그리드와 관련된 속성들이 변경될 때마다 update lock 을 걸어 내부적인 변경 처리 호출을 지연시킨다.
     *
     * @remarks
     * {@link GridBase.endUpdate | endUpdate()} 와 같이 사용한다.
     *
     * @example
     *
     * ```js
     * gridview.beginUpdate();
     * try {
     *     gridview.displayOptions( { ... });
     *     gridview.selectOptions( { ... });
     * ...
     * } finally {
     *     gridview.endUpdate();
     * }
     * ```
     */
    beginUpdate(): void;
    /**
     * update lock 을 풀고 그리드를 다시 그린다.
     *
     * @remarks
     * {@link GridBase.beginUpdate | beginUpdate()} 와 같이 사용한다.
     *
     * @param force - beginUpdate() 의 호출 여부에 상관없이 그리드를 다시 그린다.
     *
     * @example
     * {@link GridBase.beginUpdate | beginUpdate()} 참조
     */
    endUpdate(force: boolean): void;
    /**
     * 그리드가 표시된 상태면 `true` 를 반환한다.
     *
     * ```js
     * let visible = gridView.isVisible();
     * ```
     */
    isVisible(): boolean;
    /**
     * 그리드를 표시하거나 감춘다.
     *
     * @param value - `true`: 그리드 표시, `false`: 그리드 감추기
     *
     * @example
     * ```js
     * gridView.setVisible(false);
     * ```
     */
    setVisible(value: boolean): void;
    /**
     * 그리드에 현재 표시된 Grid Item 개수를 반환한다.
     *
     * @remarks
     * rowGroup의 header, footer가 있는 경우 itemCount에 포함된다.
     *
     * @example
     * ```js
     * let count = gridView.getItemCount();
     * ```
     */
    getItemCount(): number;
    /**
     * 지정한 그리드 행의 고유 번호를 반환한다.
     *
     * @param itemIndex - 행의 순서
     *
     * @example
     * ```js
     * let row = gridView.getDataRow(0);
     * ```
     */
    getDataRow(itemIndex: number): number;
    /**
     * 지정한 그리드 행들의 고유 번호들을 반환한다.
     *
     * @param items - 행의 순서의 배열
     *
     * @example
     * ```js
     * let rows = gridView.getRowsOfItems([0, 2, 4, 6]);
     * ```
     */
    getRowsOfItems(items: number[]): number[];
    /**
     * 행의 고유 번호로 행의 순서를 반환한다.
     *
     * @param dataRow - 행의 고유 번호
     *
     * ```
     * let answerRow = gridView.getItemIndex(42);
     * ```
     */
    getItemIndex(dataRow: number): number;
    /**
     * 입력된 데이터 행들의 고유번호들로 행들의 순서들을 반환한다.
     *
     * @param rows - 행의 고유 번호의 배열
     *
     * @example
     * let harshadRows = getItemsOfRows([10, 12, 18, 142857]);
     *
     */
    getItemsOfRows(rows: number[]): number[];
    /**
     * 그리드의 칼럼위치를 최초상태로 되돌린다.
     *
     * @example
     * ```js
     * gridView.restoreColumns();
     * ```
     *
     */
    restoreColumns(): void;
    /**
     * 그리드에 연결되어 있는 DataProvider를 반환한다.
     * @example
     * ```js
     * let ds = gridView.getDataSource();
     * ```
     */
    getDataSource(): LocalDataProvider | LocalTreeDataProvider;
    /**
     * 그리드에 Data Provider를 연결한다.
     *
     * @param dataProvider - DataProvider 객체.
     *
     * @example
     * ```js
     * let dataProvider = new RealGrid.LocalDataProvider();
     * gridView = new RealGrid.GridView("realgrid");
     * gridView.setDataSource(dataProvider);
     * ```
     */
    setDataSource(dataProvider: LocalDataProvider | LocalTreeDataProvider): void;
    /**
     * 그리드 옵션 정보를 반환한다.
     *
     * @remarks
     * {@link GridOptions} 의 모델로 반환한다.
     *
     * @returns - {@link GridBase.setOptions | setOptions} 와 다르게 그리드 수준의 정보만을 반환한다.
     *
     * @example
     * ```js
     * let options = gridView.getOptions();
     * ```
     */
    getOptions(): GridOptions;
    /**
     * 그리드 옵션 정보를 재설정한다.
     *
     * @remarks
     * 그리드 수준의 정보만을 반환하는 {@link GridBase.getOptions | getOptions } 와 달리 이 method를 통해 하위 구성 요소 및 다른 실행 정보들을 동시에 재설정할 수 있다.
     * {@link GridOptions} 의 모델로 설정한다.
     *
     * @param options - 설정 정보
     * @example
     * ```js
     * let options =  {
     *     summaryMode: 'aggregate',
     *     displayOptions: {
     *         columnResizable : false
     *     }
     * };
     * gridView.setOptions(options);
     * ```
     */
    setOptions(options: GridOptions): void;
    /**
     * 그리드 고정 영역에 관한 설정 정보들을 {@link FixedOptions} 의 모델로 반환한다.
     *
     * @example
     * ```js
     * let fixed = gridView.getFixedOptions();
     * fixed.colCount = 1;
     * gridView.setFixedOptions(fixed);
     * ```
     */
    getFixedOptions(): FixedOptions;
    /**
     * 그리드 고정 영역에 관한 정보를 {@link FixedOptions} 의 모델로 설정한다.
     *
     * @param options - {@link FixedOptions} 모델과 같은 설정 정보. 변경하고자 하는 값들만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setFixedOptions({colCount: 2});
     * ```
     */
    setFixedOptions(options: FixedOptions): void;
    /**
     * 그리드 표시와 관련된 설정 정보들을 {@link DisplayOptions} 의 모델로 반환한다.
     *
     * @example
     * ```js
     * let display = gridView.getDisplayOptions();
     * display.rowHeight = 20;
     * gridView.setDisplayOptions(display);
     * ```
     */
    getDisplayOptions(): DisplayOptions;
    /**
     * 그리드 표시 정보를 {@link DisplayOptions} 모델로 설정한다.
     *
     * @param options - {@link DisplayOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     * ```js
     * gridView.setDisplayOptions({rowResizable: true});
     * ```
     */
    setDisplayOptions(options: DisplayOptions): void;
    /**
     * 그리드의 {@link FormatOptions} 를 반환한다.
     *
     * @example
     * ```js
     * let format = gridView.getFormatOptions();
     * format.booleanFormat = 'X:O';
     * gridView.setFormatOptions(format);
     * ```
     */
    getFormatOptions(): FormatOptions;
    /**
     * 그리드의 {@link FormatOptions} 를 설정한다.
     *
     *
     * @param options - {@link FormatOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     * ```js
     * gridView.setFormatOptions({booleanFormat: 'wrong:correct'});
     * ```
     */
    setFormatOptions(options: FormatOptions): void;
    /**
     * 그리드 편집 방식과 관련된 정보들을 {@link EditOptions} 모델로 반환한다.
     * @example
     * ```js
     * let edit = gridView.getEditOptions();
     * edit.editable = true;
     * gridView.setEditOptions(edit);
     * ```
     */
    getEditOptions(): EditOptions;
    /**
     * 그리드 편집 방식과 관련된 정보들을 {@link EditOptions} 모델로 재설정한다.
     *
     * @param options - {@link EditOptions} 모델과 같은 설정 정보. 변경하고자 하는 값들만 전달하면 된다.
     *
     * @example
     * ```js
     * gridView.setEditOptions({editable: false});
     * ```
     */
    setEditOptions(options: EditOptions): void;
    /**
     * 편집기 표시 정보를 {@link EditorOptions} 모델로 반환한다.
     * @example
     * ```js
     * let editor = gridView.getEditorOptions();
     * editor.yearDisplayFormat = '{Y} year';
     * gridView.setEditorOptions(editor);
     * ```
     */
    getEditorOptions(): EditorOptions;
    /**
     * 편집기 표시 정보를 {@link EditorOptions} 모델로 설정한다.
     *
     * @remarks
     * 날자 편집기의 표시형태를 변경하는 경우 달력 팝업이 최초 실행(생성)되기 전에 먼저 설정되어야 한다(한번 실행되고난 후 중간에 변경할 수 없음).
     *
     * @param options - {@link EditorOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setEditorOptions({yearDisplayFormat: "{Y} year"});
     * ```
     */
    setEditorOptions(options: EditorOptions): void;
    /**
     * ctrl+c 를 이용해서 그리드를 복사할때 적용되는 설정을 {@link CopyOptions} 모델로 반환한다.
     *
     * @example
     * ```js
     * let copy = gridView.getCopyOptions();
     * copy.enabled = false;
     * gridView.setCopyOptions(copy);
     * ```
     */
    getCopyOptions(): CopyOptions;
    /**
     * 복사 정보를 {@link CopyOptions} 모델로 설정한다.
     *
     * @param options - {@link CopyOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     * ```js
     * gridView.setCopyOptions({enabled: false});
     * ```
     */
    setCopyOptions(options: CopyOptions): void;
    /**
     * 그리드에 붙여넣기를 할때 적용되는 설정을 {@link PasteOptions} 모델로 반환한다.
     * @example
     * ```js
     * let paste = gridView.getPasteOptions();
     * paste.enabled = false;
     * gridView.setPasteOptions(paste);
     * ```
     */
    getPasteOptions(): PasteOptions;
    /**
     * 그리드에 {@link PasteOptions} 모델로 붙여넣기 정보를 설정한다.
     *
     * @param options - PasteOptions 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setPasteOptions({enabled: false});
     * ```
     */
    setPasteOptions(options: PasteOptions): void;
    /**
     * 그리드 정렬과 관련된 설정 정보들을 {@link SortingOptions} 모델로 반환한다.
     * @example
     * ```js
     * let sorting = gridView.getSortingOptions();
     * sorting.enabled = false;
     * gridView.setSortingOptions(sorting);
     * ```
     */
    getSortingOptions(): SortingOptions;
    /**
     * 그리드 정렬과 관련된 정보들을 {@link SortingOptions} 모델로 설정한다.
     *
     * @remarks
     * {@link ToastOptions} 는 속성으로 직접 접근해서 수정해야한다.
     *
     * @param options - {@link SortingOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     * ```js
     * gridView.setSortingOptions({enabled: false});
     * ```
     */
    setSortingOptions(options: SortingOptions): void;
    /**
     * 그리드 필터링과 관련된 설정 정보들을 {@link FilteringOptions} 모델로 반환한다.
     * @example
     * ```js
     * let filtering = gridView.getFiteringOptions();
     * filtering.enabled = false;
     * gridView.setFiteringOptions(filtering);
     * ```
     */
    getFilteringOptions(): FilteringOptions;
    /**
     * 그리드 필터링과 관련된 정보들을 {@link FilteringOptions} 모델로 설정한다.
     *
     * @remarks
     * {@link FilterSelectorOptions}, {@link FilterAutomatingOptions}, {@link ToastOptions} 는 속성으로 직접 접근해서 수정해야한다.
     *
     * @param options - {@link FilteringOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setFilteringOptions({enabled: false});
     * ```
     */
    setFilteringOptions(options: FilteringOptions): void;
    /**
     * 모바일과 관련된 설정 정보들을 {@link MobileOptions} 모델로 반환한다.
     * @example
     * ```js
     * let mobile = gridView.getMobileOptions();
     * mobile.longTabDuration = 400;
     * gridView.setMobileOptions(mobile);
     * ```
     */
    getMobileOptions(): MobileOptions;
    /**
     * 모바일과 관련된 설정 정보들을 {@link MobileOptions} 모델로 설정한다.
     *
     * @param options - {@link MobileOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setMobileOptions({longTapDuration: 300});
     * ```
     */
    setMobileOptions(options: MobileOptions): void;
    /**
     * 데이터 drag 앤 drop과 관련 된 설정 정보들을 {@link DataDropOptions} 모델로 반환한다.
     *
     * @example
     * ```js
     * let drop = gridView.getDataDropOptions();
     * drop.dropMode = 'copy'
     * gridView.setDataDropOptions(drop);
     * ```
     */
    getDataDropOptions(): DataDropOptions;
    /**
     * 데이터 drag 앤 drop과 관련 된 설정 정보들을 {@link DataDropOptions} 모델로 설정한다.
     *
     * @param options - {@link DataDropOptions} 와 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     * ```js
     * gridView.setDataDropOptions({dropMode: 'copy'});
     * ```
     */
    setDataDropOptions(options: DataDropOptions): void;
    /**
     * {@link FormView}에 대한 설정 정보들을 {@link FormOptions} 모델로 반환한다.
     *
     * @example
     * ```js
     * let formOpts = gridView.getFormOptions();
     * ```
     */
    getFormOptions(): FormOptions;
    /**
     * {@link FormView}에 대한 설정 정보들을 {@link FormOptions} 모델로 설정한다.
     *
     * @param options - {@link FormOptions} 와 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     * ```js
     * gridView.setFormOptions({autoClose: true});
     * ```
     */
    setFormOptions(options: FormOptions): void;
    /**
     * 그리드 인디케이터와 관련된 설정 정보들을 {@link RowIndicator} 모델로 반환한다.
     * @example
     * ```js
     * let indicator = gridView.getRowIndicator();
     * indicator.zeroBase = true;
     * gridView.setRowIndicator(indicator);
     * ```
     */
    getRowIndicator(): RowIndicator;
    /**
     * 그리드 인디케이터와 관련된 설정 정보들을 {@link RowIndicator} 모델로 설정한다.
     *
     * @param value - RowIndicator 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setRowIndicator({zeroBase: true});
     * ```
     */
    setRowIndicator(value: RowIndicator): void;
    /**
     * 그리드 상태바의 설정 정보를 {@link StateBar} 의 모델로 반환한다.
     * @example
     * ```js
     * let stateBar = gridView.getStateBar();
     * stateBar.errorVisible = false;
     * gridView.setStateBar(stateBar);
     * ```
     */
    getStateBar(): StateBar;
    /**
     * 그리드 상태바의 설정 정보를 {@link StateBar} 의 모델로 설정한다.
     *
     * @param value - {@link StateBar} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setStateBar({errorVisible: true});
     * ```
     */
    setStateBar(value: StateBar): void;
    /**
     * 그리드 체크바와 관련된 설정 정보를 {@link CheckBar} 의 모델로 반환한다.
     * @example
     * ```js
     * let checkBar = gridView.getCheckBar();
     * checkBar.exclusive = false;
     * gridView.setStateBar(checkBar);
     * ```
     */
    getCheckBar(): CheckBar;
    /**
     * 그리드 체크바의 설정 정보를 {@link CheckBar} 의 모델로 설정한다.
     *
     * @param value - {@link CheckBar} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setCheckBar({exclusive: true});
     * ```
     */
    setCheckBar(value: CheckBar): void;
    /**
     * 그리드 헤더와 관련된 설정 정보들을 {@link GridHeader} 모델로 반환한다.
     * @example
     * ```js
     * let header = gridView.getHeader();
     * header.sortable = false;
     * gridView.setHeader(header);
     * ```
     */
    getHeader(): GridHeader;
    /**
     * 그리드 헤더의 설정 정보를 {@link GridHeader} 모델로 설정한다.
     *
     * @param value - {@link GridHeader} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setHeader({sortable: false});
     * ```
     */
    setHeader(value: GridHeader): void;
    /**
     * 첫번째 그리드 푸터와 관련된 설정 정보를 {@link GridFooter} 모델로 반환한다.
     * @example
     * ```js
     * let footer = gridView.getFooter();
     * footer.visible = false;
     * gridView.setFooter(footer);
     * ```
     */
    getFooter(): GridFooter;
    /**
     * 첫번째 그리드 푸터의 설정 정보를 {@link GridFooter} 모델로 설정한다.
     *
     * @param value - {@link GridFooter} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setFooter({className: 'custom-footer-1'});
     * ```
     */
    setFooter(value: GridFooter): void;
    /**
     * 그리드 푸터들의 설정 정보들을 {@link GridFooterCollection} 모델로 반환한다.
     *
     * @example
     * ```js
     * let footers = gridView.getFooters()
     * footers[0].visible = false;
     * gridView.setFooters(footers);
     * ```
     */
    getFooters(): GridFooterCollection;
    /**
     * 그리드 푸터들의 설정 정보들을 {@link GridFooter} 의 컬렉션 모델로 설정한다.
     *
     * @param value - GridFooterCollection 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     * ```js
     * // object
     * gridView.setFooters({
     *      visible: false;
     *      items: [
     *          {
     *              styleName: 'custom-footer-1';
     *          },
     *          {
     *              styleName: 'custom-footer-2';
     *          },
     *      ]
     * });
     *
     * // array
     * gridView.setFooters([
     *          {
     *              styleName: 'custom-footer-1';
     *          },
     *          {
     *              styleName: 'custom-footer-2';
     *          },
     *      ]);
     * ```
     */
    setFooters(value: GridFooterCollection | GridFooter[]): void;
    /**
     * 첫번째 그리드 header summary 와 관련된 설정 정보를 {@link HeaderSummary} 모델로 반환한다.
     *
     * @example
     * ```js
     * let headerSummary = gridView.getHeaderSummary();
     * headerSummary.visible = false;
     * gridView.setHeaderSummary(headerSummary);
     * ```
     */
    getHeaderSummary(): HeaderSummary;
    /**
     * 첫번째 그리드 header summary 의 설정 정보를 {@link HeaderSummary} 모델로 설정한다.
     *
     * @param value - {@link HeaderSummary} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setHeaderSummary({styleName: 'custom-hsummary-1'});
     * ```
     */
    setHeaderSummary(value: HeaderSummary): void;
    /**
     * 그리드 header summary 들의 설정 정보들을 {@link HeaderSummaryCollection} 모델로 반환한다.
     *
     * @example
     * ```js
     * let headerSummaries = gridView.getHeaderSummaries()
     * headerSummaries[0].visible = false;
     * gridView.setHeaderSummaries(headerSummaries);
     * ```
     */
    getHeaderSummaries(): HeaderSummaryCollection;
    /**
     * 그리드 header summary 들을 {@link HeaderSummaryCollection} 모델로 설정한다.
     *
     * @param value - {@link HeaderSummaryCollection} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * // object
     * gridView.setHeaderSummaries({
     *      visible: false;
     *      items: [
     *          {
     *              styleName: 'custom-hsumarry-1';
     *          },
     *          {
     *              styleName: 'custom-hsumarry-2';
     *          },
     *      ]
     * });
     *
     * // array
     * gridView.setFooters([
     *          {
     *              styleName: 'custom-hsumarry-1';
     *          },
     *          {
     *              styleName: 'custom-hsumarry-2';
     *          },
     *      ]);
     * ```
     */
    setHeaderSummaries(value: HeaderSummaryCollection | HeaderSummary[]): void;
    /**
     * 필터 판넬의 설정 정보를 {@link FilterPanel} 모델로 설정한다.
     *
     * @param value - {@link FilterPanel} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setFilterPanel({height: 30, visible: true, filterDelay: 500});
     * ```
     */
    setFilterPanel(value: FilterPanel): void;
    /**
     * 셀 스타일을 변경한다.
     *
     * @remarks
     * 컬럼 당 설정을 위해서는 {@link ValueColumn.styleCallback | 컬럼의 styleCallback} 을 사용해야 한다.
     *
     * {@link ColumnFooter | 푸터} 나 {@link ColumnHeaderSummary | header summary} 당 설정을 위해서는 해당 모델의 {@link ColumnSummary.styleCallback | styleCallback} 속성을 사용해야 한다.
     *
     * @param f - 셀 스타일을 특정하기 위한 콜백
     *
     * @example
     * ```js
     * const f = function (grid, cell) {
     *      return {
     *          styleName: 'custom-cell'
     *          editor: 'text'
     *      }
     * }
     * gridView.setCellStyleCallback(f);
     * ```
     */
    setCellStyleCallback(f: CellStyleCallback): void;
    /**
     * 행 스타일을 변경한다.
     *
     * @param f - 행 스타일을 특정하기 위한 콜백
     *
     * @example
     * ```js
     * const f = function(grid, item, fixed) {
     *      if (fixed) {
     *          return 'custom-fixed-row';
     *      }
     *      else {
     *          return 'custom-data-row';
     *      }
     * }
     * gridView.setRowStyleCallback(f)
     * ```
     */
    setRowStyleCallback(f: RowStyleCallback): void;

    /**
     * 하나 이상의 데이터 필드를 기준으로 Grid Item들을 정렬한다.
     *
     * @remarks
     *
     * 정렬은 Item Model 수준에서 실행되고, Data Provider 행들의 실제 위치는 변경되지 않는다.
     *
     * @param fieldNames - 정렬한 필드 이름 목록
     * @param sortDirs - 각 필드에 대한 정렬 방식 목록
     * @param textCases - 대소문자 구분
     *
     * @example
     * ```js
     * gridView.orderBy(['fruit'], ['descending'], ['insensitive']);
     *
     * gridView.orderBy("fruit", "descending");
     * ```
     */
    orderBy(fieldNames: string[] | string, sortDirs?: SortDirection[] | SortDirection, textCases?: SortCase[] | SortCase): void;
    /**
     * 현재 정렬되어 있는 필드들의 정렬 정보를 반환한다.
     *
     * @returns Sort 필드 정보 배열. 배열의 각 항목은 `direction`, `orgFieldName`, `fieldName` 의 정보를 가지고 있다.
     *
     * @example
     * ```js
     * let sFields = gridView.getSortedFields();
     *
     * console.log(sFields[0]);
     * //{
     * // fieldName: "COMPANYNAME"
     * // orgFieldName: "CompanyName"
     * // direction: "descending"
     * //}
     * ```
     */
    getSortedFields(): any[];
    /**
     * 그리드가 focus된다.
     *
     * @example
     * ```js
     * gridView.setFocus();
     * ```
     */
    setFocus(): void;
    /**
     * 해당하는 index 번째의 컬럼을 반환한다.
     *
     * @param index - 그리드에서의 순서
     *
     * @example
     * ```js
     * let col = gridView.getColumn(0);
     * ```
     */
    getColumn(index: number): GridColumn;
    /**
     * 그리드에 설정된 컬럼들을 반환한다.
     *
     * @param vOnly - 기본값: `false`, 표시된 컬럼만 가져올 건지의 여부.
     *
     * @example
     * ```js
     * let cols = gridView.getColumns();
     * ```
     */
    getColumns(): GridColumn[];
    /**
     * 기존에 설정된 컬럼들을 모두 제거하고 새로운 컬럼들로 그리드를 재구성한다.
     *
     * @param columns - {@link GridColumn | GridColumn} 과 같은 오브젝트의 컬럼 설정 정보 배열
     *
     * @example
     * ```js
     *  let cols = [{
     *      "name": "EmployeeID",
     *      "fieldName": "EmployeeID",
     *      "type": "data",
     *      "width": "90",
     *      "header": {
     *          "text": "Employee ID"
     *      }
     *  }, {
     *      "name": "OrderDate",
     *      "fieldName": "OrderDate",
     *      "type": "data",
     *      "width": "130",
     *      "header": {
     *          "text": "Order Date"
     *      }
     *  }]
     *
     *  gridView.setColumns(cols);
     * ```
     */
    setColumns(columns: (ConfigObject | string)[]): void;
    /**
     * 설정된 컬럼들 외에 추가로 컬럼을 설정한다.
     *
     * @param column - 추가할 컬럼 ({@link GridColumn | GridColumn} 과 같은 오브젝트)
     * @param index - 해당 컬럼이 위치할 순서(숨김컬럼 포함). 값을 지정하지 않으면 컬럼의 가장 마지막에 추가된다.
     *
     * @example
     * ```js
     *let col = {
     *      "name": "EmployeeID",
     *      "fieldName": "EmployeeID",
     *      "type": "data",
     *      "width": "90",
     *      "header": {
     *          "text": "Employee ID"
     *      }
     * }
     *
     * gridView.addColumn(col);
     * ```
     */
    addColumn(column: ConfigObject | string, index?: number): GridColumn;
    /**
     * 해당 컬럼을 제거한다.
     *
     * @param column - 제거할 컬럼 이름
     *
     * @example
     * ```js
     * gridView.removeColumn('KorName');
     * ```
     *
     */
    removeColumn(name: string): boolean;
    /**
     * Layout에 컬럼 또는 group을 추가한다.
     *
     * @remarks
     *
     * layout이 설정되지 않은 경우 사용할수 없다. gridView.setColumnLayout을 이용해서 layout상태로 변경한후 사용해야 한다.
     *
     * @param source - 추가할 컬럼명 또는 layout정보
     * @param index - 삽입될 위치
     * @returns 추가된 layout 정보
     *
     * @example
     * ```js
     * gridView.setColumnLayout([]); // 빈 layout을 추가한다.
     *
     * const column1 = gridView.addColumn({fieldName: "field1", name: "col1"});
     * const column2 = gridView.addColumn({fieldName: "field2", name: "col2"});
     * const column3 = gridView.addColumn({fieldName: "field2", name: "col3"});
     * gridView.addLayout(column1); // gridView.addLayout("col1")
     * gridView.addLayout({name: "group0", items: [column2, column3]});
     * ```
     */
    addLayout(source: LayoutItem | string, index?: number): LayoutItem;
    /**
     * layout을 제거한다.
     *
     * layout이 설정되지 않은 경우 사용할수 없다. gridView.setColumnLayout을 이용해서 layout상태로 변경한후 사용해야 한다.
     *
     * @param layout - layout또는 layout의 이름
     *
     * @example
     * ```js
     * gridView.removeLayout("group0");
     * gridView.removeLayout("column");
     * ```
     */
    removeLayout(layout: LayoutItem | string): void;
    /**
     * 컬럼명을 이용해서 컬럼의 layout설정정보를 찾아온다.
     *
     * @param column - 컬럼의 name
     * @returns column의 layout설정정보
     * @example
     * ```js
     * let layout = gridView.layoutByName("column");
     * ```
     */
    layoutByColumn(column: string): CellLayoutColumnItem;
    /**
     * layout의 이름을 이용해서 layout설정정보를 찾아온다.
     *
     * @param name - layout의 이름
     * @returns 컬럼 또는 Group의 layout설정정보
     * @example
     * ```js
     * let group = gridView.layoutByName("group");
     * group.direction = "vertical"
     * ```
     */
    layoutByName(name: string): LayoutItem;
    /**
     * 그리드에 설정된 컬럼들을 반환한다.
     *
     * @param columnsOnly - 기본값: `false`, false면 반환 시 컬럼 그룹들을 포함
     * @param visibleOnly - 기본값: `false`, false면 반환 시 숨긴 컬럼들을 포함
     * @returns 컬럼 이름 배열
     *
     * @example
     *
     * ```js
     * let onlyColsNames = gridView.getColumnNames(true, false);
     * ```
     */
    getColumnNames(columnsOnly?: boolean, visibleOnly?: boolean): string[];
    /**
     * 컬럼 이름으로 컬럼 설정 정보를 반환한다.
     *
     * @param name - 컬럼 이름
     * @returns 컬럼이 존재하지 않는 경우 `null`
     *
     * @example
     * ```js
     * let col = gridView.columnByName('colName');
     * ```
     */
    columnByName(name: string): DataColumn;
    /**
     * 필드 이름으로 지정되는 데이터필드에 연결되어 있는 첫 번째 컬럼 정보를 반환한다.
     *
     * @param fieldName - 필드이름
     * @returns 컬럼 설정 정보나 컬럼이 존재하지 않는 경우 `null`
     *
     * @example
     * ```js
     * let col = gridView.columnByField('fieldName');
     * ```
     */
    columnByField(fieldName: string): DataColumn;
    /**
     * 입력된 tag값을 가지는 컬럼을 가져온다.
     *
     * @remarks
     * 같은 tag를 갖는 컬럼이 하나 이상 존재하면 그 중 첫번째 컬럼을 반환한다.
     * 해당하는 컬럼이 존재하지 않으면 null을 반환한다.
     *
     * @param tag - 컬럼에 지정한 tag
     * @returns 컬럼 설정 정보나 컬럼이 존재하지 않는 경우 `null`
     *
     * @example
     * ```js
     * let col = gridView.columnByTag('tag');
     * ```
     */
    columnByTag(tag: any): GridColumn;
    /**
     * 입력된 tag값을 가지는 컬럼들을 배열로 가져온다.
     *
     * @param tag - 컬럼에 지정한 tag
     * @returns 컬럼 배열, 입력된 tag를 가지는 컬럼이 존재하지 않는 경우 `null`
     *
     * @example
     * ```js
     * let cols = gridVeiw.columnsByTag('tag');
     * ```
     */
    columnsByTag(tag: any): GridColumn[];
    /**
     * 해당 컬럼의 속성을 반환한다.
     *
     * @param column - 컬럼의 이름 또는 컬럼 객체
     * @param prop - 속성 이름
     * @returns `prop`에 입력된 속성명의 값이다.
     *
     * @example
     * ```js
     * let colRenderer = getColumnProperty('colName', 'renderer');
     * ```
     */
    getColumnProperty(column: string | GridColumn, prop: string): any;
    /**
     * 그리드에 설정된 컬럼의 특정 속성 정보를 변경한다.
     *
     * @remarks
     * editor 속성 안에 있는 속성을 변경하려는 경우 editor 전체를 다시 지정해야 한다.
     *
     * `values`, `labels`를 변경하는 경우 {@link GridBase.setColumnProperty | setColumnProperty()} 로 변경할 수 없으며 {@link GridBase.setColumn | setColumn()} 으로 컬럼을 재지정해야 한다.
     *
     * @param column - 컬럼의 이름 또는 컬럼 객체
     * @param prop - 속성 이름
     * @param value - 변경 값
     *
     * @example
     * ```js
     * gridView.setColumnProperty('colName', 'editor', {
     *      type: 'text'
     * });
     * ```
     */
    setColumnProperty(column: string | GridColumn, prop: string, value: any): void;
    /**
     * 그리드에 설정된 컬럼의 정보를 변경한다.
     *
     * @remarks
     * 컬럼 정보를 재설정하기 위해서는 먼저 {@link GridBase.columnByName | columnByName} 등으로 먼저 기존 설정 정보를 가져와야 한다.
     *
     * @param value - 변경할 정보. 컬럼의 이름 또는 {@link GridColumn} 과 같은 모델의 오브젝트.
     *
     * @example
     * ```js
     * let col = {
     *      name: 'existed column'
     * }
     * col.editor = {
     *     type: 'text'
     * }
     * gridView.setColumn(col);
     * ```
     */
    setColumn(value: ConfigObject): void;
    /**
     * 현재 보여지고 있는 컬럼들을 반환한다.
     *
     * @example
     * ```js
     * let displayCols = gridView.getDisplayColumns();
     * ```
     */
    getDisplayColumns(): GridColumn[];
    /**
     * 그리드의 컬럼 레이아웃을 설정한다.
     *
     * @remarks
     * `string` 으로 입력할 경우 미리 등록되어 있는 레이아웃으로 설정한다.
     *
     * @param layout - 변경할 레이아웃 정보
     *
     * @example
     * ```js
     * layout = [{
     *         "OrderID",
     *         {
     *             name: "companyGroup",
     *             items: [
     *                 "Country",
     *                 50,
     *                 50,
     *                 {
     *                     column: "CompanyName",
     *                     cellSpan: 2
     *                 },
     *                 50,
     *                 50
     *             ],
     *             header: {
     *                 text: "Company Group",
     *                 visible: true
     *             }
     *         }
     *     }
     * ];
     * gridView.setColumnLayout(layout)
     * ```
     */
    setColumnLayout(layout: string | (string | LayoutItem)[]): void;
    /** @deprecated */
    /**
     * 해당 컬럼의 레이아웃 정보를 반환한다.
     * @param column - 정보를 얻고자 하는 컬럼의 이름 또는 컬럼 오브젝트
     *
     * @returns - {@link CellLayoutColumnItem} 오브젝트
     *
     * @example
     *
     * ```js
     * let layout = gridView.getLayoutByColumn('OrderID');
     * ```
     */
    getLayoutByColumn(column: string | GridColumn): CellLayoutColumnItem;
    /**
     * 현재 화면의 레이아웃 정보를 반환한다.
     *
     * @example
     * ```js
     * let layouts = gridView.saveColumnLayout();
     * ```
     */
    saveColumnLayout(): LayoutInfo[];
    /**
     * 컬럼 그룹들을 모두 제거하고 데이터 값을 표시하는 컬럼들만 일렬로 배치한다.
     *
     * @param sortProp - 컬럼 순서 정렬을 지정하기 위한 정보
     *
     * @example
     * ```js
     * gridView.linearizeColumns();
     * ```
     */
    linearizeColumns(sortProps?: string[]): void;
    /**
     * 컬럼 레이아웃들을 미리 등록한다.
     *
     * @remarks
     * 등록한 layout은 {@link GridBase.setColumnLayout}을 이용해서 그리드에 적용한다.
     *
     * @param layouts - 컬럼 레이아웃 배열
     *
     * @example
     * ```js
     * let layouts =
     *    [{ "name": "layout1", // 등록하려는 layout정보의 이름.
     *       "items": ["text1", "text2"] // 컬럼 또는 그룹의 설정 정보
     *     },
     *     { "name": "layout2",
     *       "items": [{
     *           name: "group1", // CellLayoutGroupItem의 이름.
     *           type: "group",
     *           items:[...]}]
     *     }
     * ...
     * ];
     * ```
     */
    registerColumnLayouts(layouts: {
        name: string;
        items: (string | LayoutItem)[];
    }[]): void;
    /**
     * 셀의 너비를 글자 길이에 맞게 변경한다.
     *
     * @remarks
     * GroupLayout의 하위 그룹이 있는 경우 자동으로 변경할수 없다.
     * grid.displayOptions.refreshMode 가 "visibleOnly"인 경우 화면에 표시되지 않는 컬럼의 너비는 조정되지 않는다.
     *
     * @param layout - layout이름 또는 column
     * @param maxWidth - 최대 너비
     * @param minWidth - 최소 너비
     * @param includeHeaderText - header text 포함여부 defalut `true`
     *
     * @example
     * ```js
     * gridView.fitLayoutWidth('layout1')
     * ```
     */
    fitLayoutWidth(layout: string | LayoutItem, maxWidth?: number, minWidth?: number, includeHeaderText?: boolean): number;
    /**
     * 행 높이를 지정한 높이로 변경한다.
     *
     *
     * @param itemIndex - 높이 변경할 행의 순서
     * @param height - 기본값: `0`, 행 높이. `0`으로 지정시 {@link DisplayOptions | displayOptions}.minRowHeight, maxRowHeight 에 맞게 행 높이가 변경된다.
     * @param refresh - 기본값: `true`, 변경한 행 높이를 바로 화면에 반영할 것인지의 여부
     *
     * @example
     * ```js
     * gridView.setRowHeight(2, 40);
     * ```
     */
    setRowHeight(itemIndex: number, height?: number, refresh?: boolean): void;
    /**
     * 행 높이를 반환한다.
     *
     * @param itemIndex - 높이를 반환할 행의 인덱스
     * @example
     * ```js
     * gridView.getRowHeight(2);
     * ```
     */
    getRowHeight(itemIndex: number): number;
    /**
     * 변경 적용한 개별 행 높이를 초기값으로 되돌린다.
     *
     * @param all - `true`: 전부, `false`: `setRowHeight()` 로 바꾼것만 미포함
     * @example
     * ```js
     * gridView.clearRowHeights(true);
     * ```
     */
    clearRowHeights(all: boolean): void;
    /**
     * 현재 focus 된 셀의 위치정보를 반환한다.
     *
     * ```js
     * console.log(JSON.stringify(grid.getCurrent()));
     * ```
     */
    getCurrent(): CellIndex;
    /**
     * focus cell 의 위치를 지정한다.
     *
     * @remarks
     * 행의 경우 itemIndex, dataRow 중 하나 지정할 수 있고, 컬럼의 경우 column(컬럼명), fieldIndex, fieldName 중 하나로 지정할 수 있다.
     *
     * 단, 중복 적용될 경우 뒤부터 순서대로 우선 적용된다.
     *
     * @param current - 셀 위치정보
     * @param select - 선택 영역 초기화 여부
     *
     * @example
     *
     * ```js
     * gridView.setCurrent({ itemIndex: 1, column: '행정구역별' });
     * ```
     */
    setCurrent(current: CellIndex, select?: boolean): void;
    /**
     * focus cell 의 위치를 첫번째 행, 첫번째 열로 초기화한다.
     *
     * @example
     * ```js
     * gridView.resetCurrent();
     * ```
     */
    resetCurrent(): void;
    /**
     * focus를 제거한다.
     *
     * @example
     * ```js
     * gridView.clearCurrent();
     * ```
     */
    clearCurrent(): void;
    /**
     * (x, y) 좌표에 해당하는 셀의 위치정보를 반환한다.
     *
     * @param x - x 좌표
     * @param y - y 좌표
     * @returns 셀 위치정보, {@link CellIndex} 또는 존재하지 않을 경우 `null` 을 반환한다.
     *
     * @example
     * ```js
     * console.log(gridView.mouseToIndex(10, 10));
     * ```
     */
    mouseToIndex(x: number, y: number): ConfigObject;
    /**
     * 그리드에서 지정한 셀의 좌표값을 반환한다.
     *
     * @param itemIndex - 행의 순서
     * @param column - 컬럼 이름이나 컬럼 객체
     * @returns 좌표값, 보이지 않는 영역에 있을 경우 `null` 을 반환한다.
     *
     * @example
     * ```js
     * let bounds = gridView.getCellBounds(3, '행정구역별');
     *
     * // {x, y, width, height} 반환
     * ```
     */
    getCellBounds(itemIndex: number, column: string | GridColumn, outer?: boolean): object;
    /**
     * HTMLElemnt가 속한 셀의 위치정보를 반환한다.
     *
     * @remarks customRenderer에서 사용자가 생성한 element가 속해있는 셀의 index를 찾기위해 사용.
     *
     * @param element - HTMLElement
     * @returns element가 속한 Cell의 index
     */
    getIndexOfElement(element: HTMLElement): CellIndex;
    /**
     * 그리드 컬럼에 필터를 설정한다.
     *
     * @remarks
     * 사용가능한 Operator와 variables는 Expression 참조
     *
     * @param column - 설정 될 컬럼의 이름 또는 컬럼 객체
     * @param filters - 필터 객체의 배열, {@link ColumnFilter} 의 배열
     *
     * @example
     * ```js
     * let filters = [{
     *          name: "전",
     *          criteria: "value = '전'"
     *      }, {
     *          name: "답",
     *          criteria: "value = '답'"
     *      }, {
     *          name: "'임야' or '공장용지'",
     *          criteria: "(value = '임야') or (value = '공장용지')"
     *      }, {
     *          name: "대지: value > '대지'",
     *          criteria: "value > '대지'"
     *      }];
     *
     * gridView.setColumnFilters('지목', filters);
     * ```
     */
    setColumnFilters(column: string | DataColumn, filters: ColumnFilter[]): void;
    /**
     * 컬럼에 등록된 필터들을 제거한다.
     * column.autoFilter가 true인 경우 적용되지 않는다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     *
     * @example
     * ```js
     * gridView.clearColumnFilters();
     * ```
     */
    clearColumnFilters(column: string | DataColumn): void;
    /**
     * 컬럼에 하나 이상의 필터를 등록한다.
     * column.autoFilter가 true인 경우 적용되지 않는다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param filters - 등록할 필터 객체의 배열, {@link ColumnFilter} 의 배열
     * @param overwrite - 기본값: `false`, overwrite가 `false` 시 중복된 이름의 필터가 있을 경우 에러를 발생시킨다.
     *
     * @example
     *
     * ```js
     * gridView.addColumnFilters('행정구역별', [{
     *          name: "전",
     *          criteria: "value = '전'"
     *      }, {
     *          name: "답",
     *          criteria: "value = '답'"
     *      }])
     * ```
     *
     */
    addColumnFilters(column: string | DataColumn, filters: ColumnFilter[], overwrite?: boolean): void;
    /**
     * 컬럼에 등록되어 있는 필터들 중 `filterNames`에 포함된 필터명을 갖는 필터들을 제거한다.
     * column.autoFilter가 true인 경우 적용되지 않는다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param filterNames - 제거할 필터의 이름 또는 필터들의 이름의 배열
     *
     * @example
     *
     * ```js
     * gridView.removeColumnFilters('행정구역별', ['전']);
     * ```
     */
    removeColumnFilters(column: string | DataColumn, filterNames: string | string[]): void;
    /**
     * 컬럼에 등록된 필터들 중, `filterNames` 에 포함된 필터명을 갖는 필터들을 적용시키거나 해제한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param filterNames - 적용 또는 해제할 필터의 이름 혹은 필터들의 이름의 배열
     * @param active - `true`: 적용, `false`: 해제.
     *
     * @example
     *
     * ```js
     * gridView.activateColumnFilters('행정구역별', ['전'], true);
     * ```
     *
     */
    activateColumnFilters(column: string | DataColumn, filterNames: string | string[], active: boolean): void;
    /**
     * 컬럼에 등록된 모든 필터들을 적용 또는 해제한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param active - `true`: 적용, `false`: 해제.
     *
     * @example
     *
     * ```js
     * gridView.activateAllColumnFilters('행정구역별', true);
     * ```
     */
    activateAllColumnFilters(column: string | DataColumn, active: boolean): void;
    /**
     * 그리드의 모든 컬럼에 등록된 필터들을 해제한다.
     *
     * @example
     *
     * ```js
     * gridView.resetFilters();
     * ```
     */
    resetFilters(): void;
    /**
     * 컬럼에 등록된 필터들 중, `filterNames` 에 포함된 필터명을 갖는 필터들을 숨기거나 표시한다.
     * column.autoFilter가 true인 경우 적용되지 않는다.
     *
     * @remarks
     * 활성화 된 필터를 숨기는 경우 활성화 된 상태로 숨긴다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param filterNames - 필터의 이름 혹은 필터들의 이름의 배열
     * @param hide - 기본값: `true`, `true`: 숨김, `false`: 보여줌.
     *
     * @example
     *
     * ```js
     * gridView.hideColumnFilters('행정구역별', ['전']);
     * ```
     */
    hideColumnFilters(column: string | DataColumn, filterNames: string | string[], hide?: boolean): void;
    /**
     * 컬럼에 등록된 모든 필터를 숨기거나 보여준다.
     * column.autoFilter가 true인 경우 적용되지 않는다.
     *
     * @remarks
     * 활성화 된 필터를 숨기는 경우 활성화 된 상태로 숨긴다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param hide - 기본값: `true`, `true`: 숨김, `false`: 보여줌.
     *
     * @example
     * ```js
     * gridView.hideAllColumnFilters('행정구역별');
     * ```
     */
    hideAllColumnFilters(column: string | DataColumn, hide?: boolean): void;
    /**
     * 해당 컬럼의 지정한 필터들을 토글한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param filterNames - 토글할 필터의 이름 혹은 필터들의 이름의 배열
     *
     * @example
     *
     * ```js
     * gridView.toggleColumnFilters('행정구역별', ['전', '답']);
     * ```
     */
    toggleColumnFilters(column: string | DataColumn, filterNames: string | string[]): void;
    /**
     * 해당 컬럼의 지정한 모든 필터들을 토글한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     *
     * @example
     *
     * ```js
     * gridView.toggleAllColumnFilters('행정구역별', ['전']);
     * ```
     */
    toggleAllColumnFilters(column: string | DataColumn): void;
    /**
     * 지정한 컬럼에서 필터 이름에 해당하는 필터를 반환한다.
     *
     * @param column - 지정한 컬럼의 이름 또는 컬럼 객체
     * @param filterName - 필터 이름
     * @returns - {@link ColumnFilter} 와 같은 모델의 필터 오브젝트
     *
     * @example
     *
     * ```js
     * gridView.getColumnFilter('행정구역별', ['전']);
     * ```
     */
    getColumnFilter(column: string | DataColumn, filterName: string): ColumnFilter;
    /**
     * 지정한 컬럼에서 필터들을 반환한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @returns - {@link ColumnFilter} 와 같은 모델의 필터 오브젝트의 배열
     *
     * @example
     *
     * ```js
     * gridView.getColumnFilters('행정구역별');
     * ```
     */
    getColumnFilters(column: string | DataColumn): ColumnFilter[];
    /**
     * 등록된 필터들 중 적용된 필터 또는 해제된 필터의 이름을 반환한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param active - 기본값: true, `true`: 활성화 된 필터 반환, `false`: 해제된 필터 반환
     * @returns 활성화 상태에 해당하는 {@link ColumnFilter} 와 같은 모델의 필터 오브젝트의 배열
     *
     * @example
     * ```js
     * gridView.getActiveColumnFilters('행정구역별');
     * ```
     */
    getActiveColumnFilters(column: string | DataColumn, active?: boolean): ColumnFilter[];
    /**
     * 그리드의 특정 컬럼이 필터링 되어 있는지 여부를 반환한다.
     *
     * @remarks
     *
     * 컬럼을 생략하면 필터링이 되어있는 컬럼이 있으면 `true`를 return하고 없으면 `false`를 return한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @returns 필터링 여부
     *
     * @example
     * ```js
     * gridView.isFiltered('행정구역별');
     * //
     * gridView.isFiltered();
     * ```
     */
    isFiltered(column?: string | DataColumn): boolean;
    /**
     * column.autoFilter가 true인경우 filter목록을 갱신한다.
     *
     * @param columns - 컬럼이름 또는 컬럼 객체의 배열. 입력하지 않는 경우 전체 컬럼.
     * @param applyFilters - active된 filter의 적용 여부.
     *
     * @remarks
     * autoFilter의 목록을 갱신할때 호출한다.
     * 또는 사용자가 filter 아이콘을 클릭하면 자동으로 갱신된다.
     */
    autoFiltersRefresh(columns: string[] | DataColumn[], applyFilters: boolean): void;
    /**
     * 지정한 행의 데이터 값들을 JSON객체로 반환한다.
     *
     * @remarks
     * itemIndex와 연결된 행의 고유번호는 반환되는 객체의 __rowId에 담겨있다.
     *
     * @param itemIndex - 정보를 가져올 행의 순서
     * @returns 입력된 `itemIndex`가 행의 고유 번호와 연결된 행이 아닌경우 `null`이 출력된다.
     *
     * @example
     * ```js
     * gridView.getValues('3');
     * ```
     */
    getValues(itemIndex: number): object;
    /**
     * 지정한 행의 데이터 값들을 각종 포맷이나 정규식이 적용된 형태의 JSON객체로 반환한다.
     *
     * @param itemIndex - 정보를 가져올 행의 순서
     * @param useColumnName - `true`이면 JSON객체의 속성명을 fieldName이 아닌 column.name으로 만든다.
     * @returns 입력된 `itemIndex`가 행의 고유 번호와 연결된 행이 아닌경우 `null`이 출력된다.
     *
     * @example
     * ```js
     * gridView.getDisplayValues(3);
     * ```
     */
    getDisplayValues(itemIndex: number, useColumnName?: boolean): object;
    /**
     * 행 고유 번호로 지정한 행의 데이터 값들을 각종 포맷이나 정규식이 적용된 형태의 JSON객체로 반환한다.
     *
     * @param dataRow - 행의 고유 번호
     * @param useColumnName - `true`이면 JSON객체의 속성명을 fieldName이 아닌 column.name으로 만든다.
     * @returns 입력된 `dataRow`가 존재하지 않을 경우 `null`이 출력된다.
     *
     * @example
     * ```js
     * gridView.getDisplayValuesOfRow(42);
     * ```
     */
    getDisplayValuesOfRow(dataRow: number, useColumnName?: boolean): object;
    getJsonRows(): object[];
    /**
     * 지정한 행의 여러 필드의 값을 수정한다.
     *
     * @param itemIndex - 정보를 가져올 행의 인덱스
     * @param values - 수정할 필드의 데이터 값들
     * @param strict - 기본값: `false`, `true` 일때 필드의 값을 `undefined` 로 지정한 경우 기존의 값을 유지한다.
     *
     * @example
     * ```js
     * gridView.setValues(3, [123, 142, 'happy', 133]);
     * ```
     */
    setValues(itemIndex: number, values: any[] | object, strict?: boolean): void;
    /**
     * 행의 순서와 데이터 필드 인덱스로 지정되는 데이터셀의 값을 반환한다.
     *
     * @remarks
     * 지정한 행이 수정중인 경우 수정된 값을 반환한다. 편집이 완료되지 않은 셀의 값은 가져올수 없다.
     *
     * @param itemIndex - 행의 순서
     * @param field - 필드 인덱스 또는 필드명
     * @returns 데이터 필드의 값
     * @example
     * ```js
     * gridView.getValue(3, 'UnitPrice');
     * ```
     */
    getValue(itemIndex: number, field: string | number): any;
    /**
     * 행의 순서와 데이터 필드 인덱스로 지정되는 데이터 셀의 값을 변경한다.
     *
     * @remarks
     * 그리드가 편집 중인 경우 편집 중인 itemIndex 의 값만 변경할수 있으며 편집이 완료된후 dataProvider에 값이 반영되고 편집중이 아닌경우 dataProvider에 즉시 반영된다.
     *
     * @param itemIndex - 행의 순서
     * @param field - 필드 인덱스 또는 필드명
     * @param value - 필드에 설정할 값
     *
     * @example
     * ```js
     * gridView.setValue(3, 'UnitPrice', 52);
     * ```
     */
    setValue(itemIndex: number, field: string | number, value: any): void;
    /**
     * 그리드가 편집 중일때 현재 수정 중인 셀의 값을 반환한다.
     *
     * @returns 데이터 필드의 값
     *
     * @example
     * ```js
     * gridView.getEditValue();
     * ```
     */
    getEditValue(): any;
    /**
     * focus가 위치한 셀에 값을 설정한다.
     *
     * @param value - 설정하려는 값
     * @param startEdit - 기본값: `false`, `true`: 셀이 편집중이 아닌 경우 값을 설정하고 편집기를 표시. `false`: 값을 설정하지 않음.
     * @param dropdown - 기본값: `true`, `false`: dropdownCellEditor, dateCellEditor등과 같이 dropdown이 되는 editor의 경우 dropdown을 표시하지 않는다.
     *
     * @example
     * ```js
     * gridView.setEditValue('newValue');
     * ```
     */
    setEditValue(value: any, startEdit?: boolean, dropdown?: boolean): void;
    /**
     * 사용자 지정의 렌더러를 등록한다.
     *
     * @param type - 사용자가 지정한 렌더러 종류 (이름)
     * @param renderer - {@link CustomCellRenderer} 객체
     *
     * @example
     * ```js
     * // CustomCellRenderer 모델
     * gridView.registerCustomRenderer("renderer01", {
     *     initContent(parent) {
     *         var span = this._span = document.createElement("span");
     *         parent.append(span);
     *     }
     * }
     * ```
     */
    registerCustomRenderer(type: string, renderer: CustomCellRenderer): void;
    /**
     * 사용자 지정의 렌더러를 등록 해제 한다.
     *
     * @param type - 해제 할 렌더러 종류 (이름)
     *
     * @example
     * ```js
     * gridView.unregisterCustomRenderer('Renderer01');
     * ```
     */
    unregisterCustomRenderer(type: string): void;
    /**
     * 사용자렌더러가 있는지 확인한다.
     * @param type - 등록한 렌더러 이름
     */
    existsCustomRenderer(type: string): boolean;
    /**
     * 모든 사용자 지정의 렌더러를 등록 해제 한다.
     *
     * @example
     * ```js
     * gridView.unregisterAllCustomRenderer('Renderer01');
     * ```
     */
    unregisterAllCustomRenderer(): void;
    /**
     * 그리드에 Popup Menu를 추가한다.
     *
     * @remarks
     * 추가된 메뉴는 데이터셀 등에 연결할 수 있다.
     *
     * @param name - 메뉴 이름
     * @param menuItems - {@link PopupMenuItem} 형식을 따르는 배열, 계층적 구조의 메뉴 정보
     *
     * @example
     * ```js
     * let menu = [{
     *      label: "menu1 입니다.",
     *      children: [{
     *          label: "submenu1 입니다."
     *      }, {
     *          label: "submenu2 입니다."
     *      }]
     *  }, {
     *      label: "menu2 입니다",
     *  }, {
     *      label: "-"
     *  }, {
     *      label: "menu3 입니다",
     *      type: "check",
     *      checked: true,
     *      tag: "check_menu"
     *  }];
     *
     * gridView.addPopupMenu('menu1', menu);
     * ```
     */
    addPopupMenu(name: string, menuItems: (PopupMenu | PopupMenuItem)[]): void;
    /**
     * @public
     * 팝업 메뉴 설정 정보를 반환한다.
     *
     * @remarks
     * contextMenu를 가져오는 경우 `gridContectMenu`를 입력한다.
     *
     * @param name - 메뉴 이름
     * @returns - 메뉴가 존재하지 않는 경우 `null`
     */
    getPopupMenu(name: string): PopupMenu;
    /**
     * 그리드에서 특정 Popup Menu 를 제거한다.
     *
     * @param name - 제거할 Popup Menu 의 이름
     *
     * @example
     * ```js
     * gridView.removePopupMenu('menu1');
     * ```
     */
    removePopupMenu(name: string): void;
    /**
     * 그리드에서 오른쪽 마우스를 클릭했을때 표시되는 컨텍스트 메뉴에 추가할 메뉴 항목들을 지정한다.
     *
     * @remarks
     * 메뉴가 클릭되면 {@link GridBase.onContextMenuItemClicked | onContextMenuItemClicked} 콜백을 호출한다
     *
     * @param menuItems - 메뉴 정보 배열
     *
     * @example
     * ```js
     * let menu = [{
     *      label: "menu1 입니다.",
     *      children: [{
     *          label: "submenu1 입니다."
     *      }, {
     *          label: "submenu2 입니다."
     *      }]
     *  }, {
     *      label: "menu2 입니다",
     *  }, {
     *      label: "-"
     *  }, {
     *      label: "menu3 입니다",
     *      type: "check",
     *      checked: true,
     *      tag: "check_menu"
     *  }];
     *
     * gridView.setContextMenu(menu);
     * ```
     */
    setContextMenu(menuItems: (PopupMenu | PopupMenuItem)[]): PopupMenu;
    /**
     * 현재 선택된 영역 정보를 반환한다.
     *
     * @param index - 선택영역이 여러개인 경우 선택영역의 index
     *
     * @example
     * ```js
     * let sel = gridView.getSelection();
     * console.log("Selection: ", JSON.stringify(sel, function(key, value) { return key.indexOf("Layout") >= 0 ? value.column : value }));
     * ```
     */
    getSelection(index?: number): Selection;
    /**
     * 현재 선택된 영역 정보를 배열형태로 반환한다.
     *
     * @example
     * ```js
     * let sels = gridView.getSelections();
     * console.log("Selection count: ", sels.length);
     * sels.forEach((sels) => {
     *     console.log("Selection: ", JSON.stringify(sel, (key, value) => {return key.indexOf("Layout") >= 0 ? value.column : value}));
     * })
     * ```
     *
     * @returns 선택된 영역 배열
     */
    getSelections(): Selection[];
    /**
     * 그리드에서 선택할 영역을 지정한다.
     *
     * @remarks
     * 기존 선택영역이 있는 경우 제거된다.
     *
     * @param item - {@link Selection} 모델과 같은 설정 정보. 선택하고자 하는 영역의 속성만 전달하면 된다.
     *
     * @example
     * ```js
     * let sel = {
     *      style: "block",
     *      startItem: 2,
     *      startColumn: "지목",
     *      endItem: 3,
     *      endColumn: "단위"
     * }
     * gridView.setSelection(sel);
     * ```
     */
    setSelection(item: Selection): void;
    /**
     * 그리드에서 선택할 영역을 추가한다.
     *
     * @remarks
     * {@link DisplayOptions.selectionMode | selectionMode}가 {@link SelectionMode.EXTENDED | extended}인 경우에만 추가된다.
     *
     * @param item - {@link Selection} 모델과 같은 설정 정보. 선택하고자 하는 영역의 속성만 전달하면 된다.
     *
     * @example
     * ```js
     * let sel = {
     *      style: "block",
     *      startItem: 2,
     *      startColumn: "지목",
     *      endItem: 3,
     *      endColumn: "단위"
     * }
     * gridView.addSelection(sel);
     * ```
     */
    addSelection(item: Selection): void;
    /**
     * 선택 영역을 모두 제거한다.
     *
     * @example
     * ```js
     * gridView.clearSelection();
     * ```
     */
    clearSelection(): void;

    /**
     * 현재 선택 영역 안의 행의 인덱스들을 반환한다.
     *
     * @param dataOnly -  데이터행만 반환한다.
     *
     * @example
     * ```js
     * let selectedItems = gridView.getSelectedItems(true);
     * ```
     */
    getSelectedItems(dataOnly: boolean): number[];
    /**
     * 현재 선택 영역 안의 데이터 행의 고유번호들을 반환한다.
     *
     *  @example
     * ```js
     * let selectedRows = gridView.getSelectedRows();
     * ```
     */
    getSelectedRows(): number[];
    /**
     * 현재 선택 영역 안의 행들을 삭제한다.
     *
     * @remarks
     * {@link EditOptions.deletable} 이 false인 경우 작동하지 않는다.
     *
     * @param force - `true` 시 대화 상자 표시 없이 바로 삭제한다. `editOptions.deletable`이 `false`여도 삭제된다.
     *
     * @example
     * ```js
     * gridView.deleteSelection(true);
     * ```
     */
    deleteSelection(force?: boolean): void;
    /**
     * 선택 영역 안의 셀들의 값을 지운다. 즉, undefined로 값을 변경한다.
     *
     * @remarks
     * {@link EditOptions.erasable}이 false인 경우 작동하지 않는다.
     *
     * @param force - `true`이면 `editOptions.erasable`이 `false`여도 셀의 값을 지운다
     *
     * @example
     * ```js
     * gridView.eraseSelection();
     * ```
     */
    eraseSelection(force?: boolean): void;
    /**
     * 현재 선택 영역에 포함된 셀들의 값을 반환한다.
     *
     * @remarks
     * 선택된 영역이 여러개인경우에도 첫번째 선택영역의 data만 반환한다.
     *
     * @param maxRows - 반환할 최대 행의 개수. 기본값: `-1`. `0`보다 작은 값이면 제한 없이 모든 행을 반환한다.
     * @param index - 선택영역의 index 기본값: `0`
     * @returns 셀 데이터들
     *
     * @example
     * ```js
     * let selData = gridView.getSelectionData();
     * ```
     */
    getSelectionData(maxRows?: number, index?: number): RowObject[];
    /**
     * 현재 선택 영역에 포함된 셀들의 값을 반환한다.
     *
     * @remarks
     * 선택된 영역이 여러개인경우 사용한다.
     *
     * @returns 셀 데이터들
     */
    getSelectionsData(): RowObject[][];
    /**
     * 선택한 영역에 포함된 셀들의 정보를 복사 혹은 반환한다.
     *
     * @remarks
     * 선택된 영역이 여러개인경우 사용할수 없다.
     *
     * @param selection - 선택 영역의 정보, 지정하지 않으면 그리드 전체가 복사된다.
     * @param copy - 기본값: `true`, `true:` 클립보드에 복사, `false`: 반환
     * @returns `copy` 가 `false` 시 반환
     *
     * @example
     * ```js
     * let sel = gridView.getSelection();
     * let copied = gridView.copyToClipBoard(sel);
     * ```
     */
    copyToClipboard(selection: Selection, copy?: boolean): any;
    /**
     * 현재 편집기의 내용을 셀에 반영한다.
     *
     * @remarks
     * 실행 후 {@link GridBase.onEditCommit | onEditCommit}, {@link GridBase.onEditRowChanged | onEditRowChanged}, {@link GridBase.onCellEdited | onCellEditted} 이벤트가 순차적으로 발생한다.
     *
     * @param hideEditor - 기본값: true, Editor의 종료 여부
     *
     * @example
     * ```js
     * gridView.commitEditor();
     * ```
     */
    commitEditor(hideEditor?: boolean, force?: boolean): void;
    /**
     * 편집 중인 행의 편집을 완료하고 DataProvider에 저장한다.
     *
     * @param force - 기본값: `false`, `true`: 입력/편집 중 편집을 취소한 행(RowState 변경은 없고, Indicator 에 편집으로 표시된)을 커밋
     * @returns  데이터 변경이 발생한 경우 `true` 반환
     *
     * @example
     * ```js
     * gridView.commit();
     * ```
     */
    commit(force?: boolean): boolean;
    /**
     * 현재 편집 중인 행의 편집을 취소한다.
     *
     * @remarks
     * 편집 중이 아니라면 아무 일도 하지 않는다.
     * 편집을 완료할 때는 {@link GridBase.commit | commit()} 을 호출해야 한다.
     *
     * @returns 취소 성공 여부
     *
     * @example
     * ```js
     * gridView.cancel();
     * ```
     */
    cancel(): boolean;
    /**
     * 입력값과 관련된 항목을 조회하여 리스트에 표시한다. 부분검색 용도로 사용된다.
     *
     * @param column - 리스트가 표시 될 컬럼 객체 또는 컬럼명
     * @param searchKey - 검색 키 값
     * @param values - 검색된 value 값들
     * @param labels - 검색된 label 값들
     *
     * @example
     * ```js
     * let CustomerNames = ["ALFKI", "ANATR", "ANTON", "AROUT", "BERGS", "BLAUS"];
     * dataProvider.setFields([
     *      {fieldName:"code"},
     *      {fieldName:"codeName"} // 코드 명을 가지고 있는 필드
     * ]);
     * gridView.setColumns([{
     *      fieldName:"code",
     *      name:"code",
     *      editor:{type:"search",searchLength:1, searchDelay:500, useCtrlEnterKey:true, useEnterKey:true },
     *      lookupDisplay:true,
     *      labelField:"codeName"
     * }]);
     *
     * // 마지막 키가 입력되고 searchDelay가 지나면 발생되는 이벤트
     * gridView.onEditSearch = function (grid, index, text) {
     *      console.log("onEditSearch:" + index.itemIndex + "," + index.column + ", " + text);
     *      let values = CustomerNames.filter(function (str) {
     *          return str.indexOf(text) == 0;
     *      });
     *      let labels = CustomerNames.filter(function (str) {
     *          return str.indexOf(text) == 0;
     *      });
     *      console.log(values);
     *      gridView.fillEditSearchItems(index.column, text, values, labels);
     * };
     *
     * // searchEditor에서 선택이 되며 발생되는 이벤트
     * gridView.onGetEditValue = function (grid, index, editResult) {
     *      if (index.column === "code") {
     *          grid.setValue(index.itemIndex, "codeName",editResult.text);
     *      };
     * };
     * ```
     */
    fillEditSearchItems(column: string | GridColumn, searchKey: string, values: string[], labels?: string[]): void;
    /**
     * 셀 편집은 끝났으나 커밋은 하지 않았을 때, 편집 중이면 `true` 를 반환한다.
     *
     * @example
     * ```js
     * let isItemEditing = gridView.isItemEditing();
     * ```
     */
    isItemEditing(): boolean;
    /**
     * isItemEdited?
     */
    /**
     * 셀이 현재 편집중이면 `true` 를 반환한다.
     *
     * @example
     * ```js
     * let isEditing = gridView.isEditing();
     * ```
     */
    isEditing(): boolean;
    /**
     * 현재 위치한 셀에서 그리드의 편집기를 표시한다.
     *
     * @remarks
     * 그리드가 편집 불가 상태(editable: false)라면 편집기는 표시되지 않는다.
     *
     * @example
     * ```js
     * gridView.showEditor();
     * ```
     */
    showEditor(dropdown?: boolean): void;
    /**
     * 현재 그리드에서 열려진 편집기를 닫는다.
     *
     * @example
     * ```js
     * gridView.hideEditor();
     * ```
     */
    hideEditor(): void;
    /**
     * 편집을 취소하고 편집기 창을 닫는다.
     *
     * @example
     * ```js
     * gridView.cancelEditor();
     * ```
     */
    cancelEditor(): void;
    /**
     * 행 수준의 편집 검증 조건의 목록을 설정한다.
     *
     * @param value - {@link EditValidation} 모델과 같은 설정 정보들의 배열 또는 검증식
     *
     * @example
     * ```js
     * // 문자열
     * gridView.setValidations("values['UnitPrice'] > 100");
     *
     * // 오브젝트
     * gridView.setValidations({
     *      message: 'Too expensive!',
     *      criteria: "values['UnitPrice'] > 100"
     * })
     *
     * // 배열
     * gridView.setValidations([{
     *      message: 'Too expensive!',
     *      criteria: "values['UnitPrice'] > 100"
     * }])
     * ```
     */
    setValidations(value: EditValidation[] | EditValidation | string | string[]): void;
    /**
     * 입력시 검증하는 것이 아닌 그리드에 있는 데이터들을 대상으로 일괄로 검증을 수행한다.
     *
     * @remarks
     * column validation을 사용하여 검증을 수행하며 row validation은 하지 않는다.
     *
     * @param itemIndices - 그리드의 행 인덱스들, `null`로 지정하면 그리드 전체 행을 대상으로 검증을 수행
     * @param visibleOnly - 기본값: `true`, `false` 이면 트리 그리드의 접혀있는 노드 등 보이지 않는 행들도 검증 대상에 포함한다. `false`는 전체 행을 체크하는 경우에만 적용한다.
     * @param pageAllItems - `true`이면 현재 페이지가 아닌 전체 행을 대상으로 검증을 수행한다 기본값: `false`,
     * @returns 검증에 실패한 셀 정보들
     *
     * @example
     * ```js
     * gridView.validateCells(null, false);
     * ```
     */
    validateCells(itemIndices: number[], visibleOnly?: boolean, pageAllItems?: boolean): object;
    /**
     * 값 검증에 실패한 셀 정보들을 반환한다.
     *
     * @remarks
     * 이 함수는 {@link GridBase.validateCells | validateCells()} 를 먼저 실행한 후 검증에 실패한 데이터를 수정 후 다시 검증할 때 사용한다.
     * @returns 검증에 실패한 셀 정보들, {@link InvalidCell} 의 배열 형식을 따른다.
     *
     * @param itemIndex - 행의 고유 번호 입력하면 해당하는 행의 셀 정보만 반환한다.
     *
     * @example
     * ```js
     * let invalids = gridView.getInvalidCells();
     * ```
     *
     */
    getInvalidCells(itemIndex?: number): InvalidCell[];
    /**
     * 값 검증에 실행한 셀 정보중 입력한 dataRow에 해당하는 정보를 반환한다.
     *
     * @remarks
     *
     * @param dataRow - 행의 dataRow
     * @returns 검증에 실패한 셀 정보들, {@link InvalidCell} 의 배열 형식을 따른다.
     */
    getInvalidCellsOfRow(dataRow: number): InvalidCell[];
    /**
     * 값 검증에 실패한 셀 정보들을 삭제한다.
     *
     * @remarks
     * 이 함수는  {@link GridBase.validateCells | validateCells()} 를 실행했을때 검증에 실패한 데이터의 목록을 지울때 사용한다.
     *
     * @example
     * ```js
     * gridView.validateCells();
     * gridView.clearInvalidCells();
     * let invalids = gridView.getInvalidCells(); // null
     * ```
     */
    clearInvalidCells(): void;
    /**
     * 그리드가 편집 중인 아이템의 정보를 반환한다.
     *
     * @returns 편집 중인 그리드 아이템의 정보. 편집 중이 아닌 경우 `null` 반환. {@link EditingItemInfo} 형식.
     *
     * @example
     * ```js
     * let eItemInfo = gridView.getEditingItem();
     * ```
     */
    getEditingItem(): EditingItemInfo;
    /**
     * 아이템의 상태값을 반환한다.
     *
     * @param itemIndex - 상태를 가져오려는 아이템의 인덱스
     * @returns 그리드 아이템의 상태값
     *
     * @example
     * ```js
     * let itemStates = gridView.getItemState(3);
     * ```
     */
    getItemState(itemIndex: number): ItemState;
    /**
     * Toast 팝업 창을 표시한다.
     *
     * @param options - 메시지와 메시지 표시여부를 지정, {@link ToastOptions} 와 같은 모델의 오브젝트. 기본적으로 메시지만 지정해도 된다.
     * @param force - 기존 toast 창이 표시되어 있을때 강제로 다시 표시 여부를 지정한다.
     *
     * ```js
     * let config = {
     *      message: 'Toast!'
     * }
     * gridView.showToast(config, true);
     * ```
     */
    showToast(options: ToastOptions, force?: boolean): void;
    /**
     * Toast 팝업 창을 숨긴다.
     *
     * @param action - toast 창을 숨긴 뒤 수행할 콜백함수를 지정한다.
     *
     * @example
     * ```js
     * const f = function () {
     *      console.log('hidden toast!');
     * }
     * gridView.hideToats(f);
     * ```
     */
    hideToast(action: VoidFunction): void;
    /**
     * lookup tree 에서 사용할 lookup source 들을 등록한다.
     *
     * @remarks
     * 기존id에 추가를 원하는 경우는 {@link GridBase.fillLookupData | fillLookupData()} 를 사용한다.
     *
     * @param sources - {@link LookupSource} 오브젝트 배열
     *
     * @example
     * ```js
     * let area1codes = {
     *      id: "area1code",
     *      levels: 1,
     *      keys: ['11', '21'],
     *      values: ['서울특별시', '부산광역시']
     * }
     *
     * let area2codes = {
     *      id:"area2code",
     *      levels:2,
     *      keys: [['11', '11010'], ['11', '11020']],
     *      values: ['종로구', '중구']
     * };
     *
     * gridView.setLookups([area1codes, area2codes]);
     * ```
     */
    setLookups(sources: LookupSource[]): void;
    /**
     * lookup tree에서 사용할 {@link LookupSource} 를 추가 등록한다.
     *
     * @remarks
     *
     * 기존id에 추가를 원하는 경우는 {@link GridBase.fillLookupData | fillLookupData()} 를 사용한다.
     *
     * @param source - {@link LookupSource} 오브젝트
     *
     * @example
     * ```js
     * let area3codes = {
     *      id:"area2code",
     *      levels:3,
     *      keys: [['11', '11010', '1101053'], ['11', '11010', '1101054']],
     *      values: ['사직동', '삼청동']
     * };
     * gridView.addLookupSource(area3codes);
     * ```
     */
    addLookupSource(source: LookupSource): void;
    /**
     * 지정한 룩업 소스를 삭제한다.
     *
     * @param sourceId - 삭제할 LookupSource id
     *
     * @example
     * ```js
     * gridView.removeLookupSource('area1code');
     * ```
     */
    removeLookupSource(sourceId: string): void;
    /**
     * 지정된 lookupsource에 지정된 키가 존재하는지 여부를 반환한다.
     *
     * @param sourceId - LookupSource의 Id.
     * @param keys - 찾을 키 값, 값들.
     *
     * @example
     * ```js
     * gridView.existsLookupData('area1code', ['12']);
     * ```
     */
    existsLookupData(sourceId: string, keys: string | string[]): boolean;
    /**
     * lookupSource에 lookupData를 추가한다.
     *
     * @param sourceId - LookupSource의 id
     * @param data - 설정하고자 하는 {@link LookupData}
     *
     * @example
     * ```js
     * gridView.fillLookupData("lookup1", {keys:[["14"],["15"]], values:["가나다라","일이삼사"]});
     * ```
     */
    fillLookupData(sourceId: string, data: LookupData): void;
    /**
     * 지정된 SourceId에 해당하는 lookup source를 clear한다.
     *
     * @param sourceId - LookupSource의 id
     *
     * @example
     * ```js
     * gridView.clearLookupData('area1code');
     * ```
     */
    clearLookupData(sourceId: string): void;
    /**
     * 지정한 아이템의 인덱스로 체크바의 체크 가능 여부를 반환한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @returns 체크 가능한지의 여부
     *
     * @example
     * ```js
     * let isCheckable = gridView.isCheckable(4);
     * ```
     */
    isCheckable(itemIndex: number): boolean;
    /**
     * 지정한 아이템의 고유 번호로 체크바의 체크 가능 여부를 반환한다.
     *
     * @param dataRow - 아이템의 dataRow
     * @returns 체크 가능한지의 여부
     *
     * @example
     * ```js
     * gridView.isCheckableOfRow(4);
     * ```
     */
    isCheckableOfRow(dataRow: number): boolean;
    /**
     * 지정한 아이템의 체크바의 체크 가능성 여부를 지정한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @param value - 체크 가능한지의 여부
     *
     * @example
     * ```js
     * gridView.setCheckable(4, false);
     * ```
     */
    setCheckable(itemIndex: number, value: boolean): void;
    /**
     * 지정한 행의 체크바의 체크 가능성 여부를 지정한다.
     *
     * @param dataRow - 아이템의 dataRow
     * @param value - 체크 가능한지의 여부
     *
     */
    setCheckableOfRow(dataRow: number, value: boolean): void;
    /**
     * 해당 체크바에 체크가 되어있으면 `true` 를 반환한다.
     *
     * @param itemIndex - 아이템의 인덱스
     *
     * @example
     * ```js
     * gridView.isCheckedItem(4);
     * ```
     */
    isCheckedItem(itemIndex: number): boolean;
    /**
     * 행이 체크되어있는지 여부
     *
     * @param row - 행 고유 번호
     *
     * @example
     * ```js
     * gridView.isCheckedRow(4);
     * ```
     */
    isCheckedRow(row: number): boolean;
    /**
     * 지정된 아이템을 체크하거나 해제한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @param checked - 기본값: `true`, `true`: 체크, `false`: 체크 해제
     * @param exclusive - 기본값: `false`, `true`: 체크된 다른아이템이 있는 경우 모두 해제하고 아이템 인덱스로 입력된 아이템만 체크
     * @param checkEvent - 기본값: `true`, {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * gridView.checkItem(4);
     * ```
     */
    checkItem(itemIndex: number, checked?: boolean, exclusive?: boolean, checkEvent?: boolean): void;
    /**
     * 지정된 데이터 행을 체크하거나 해제한다.
     *
     * @param row - 행 고유 번호
     * @param checked - 기본값: `true`, `true`: 체크, `false`: 체크 해제
     * @param exclusive - 기본값: `false`, `true`: 체크된 다른아이템이 있는 경우 모두 해제하고 row로 입력된 아이템만 체크
     * @param checkEvent - 기본값: `true`, {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * gridView.checkRow(4);
     * ```
     */
    checkRow(row: number, checked?: boolean, exclusive?: boolean, checkEvent?: boolean): void;
    /**
     * 입력된 아이템 배열에 해당하는 아이템을 체크하거나 해제한다.
     *
     * @param itemIndices - 아이템 인덱스 배열
     * @param checked - 기본값: `true`, `true`: 체크, `false`: 체크 해제
     * @param checkEvent - 기본값: `true`,  {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * gridView.checkItems([1,2,3,4]);
     * ```
     */
    checkItems(itemIndices: number[], checked?: boolean, checkEvent?: boolean): void;
    /**
     * 입력된 고유 행 번호들과 연결된 Item을 체크하거나 해제한다.
     *
     * @param rows - 고유 행 번호의 배열
     * @param checked - 기본값: `true`, `true`: 체크, `false`: 체크 해제
     * @param checkEvent - 기본값: `true`, {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * gridView.checkRows([1,2,3,4]);
     * ```
     */
    checkRows(rows: number[], checked?: boolean, checkEvent?: boolean): void;
    /**
     * 그리드의 데이터행을 모두 체크,해제한다.
     *
     * @remarks
     * {@link CheckBar} 의 exclusive에 영향을 받지않는다.
     *
     * @param checked - 기본값: `true`, `true`: 체크, `false`: 체크 해제
     * @param visibleOnly - collapse로 인해 접혀서 보이지 않는 행의 포함여부
     * @param checkableOnly - 체크가능한 행만 체크할 것인지의 여부
     * @param checkEvent - 기본값: true, {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * gridView.checkAll();
     * ```
     */
    checkAll(checked?: boolean, visibleOnly?: boolean, checkableOnly?: boolean, checkEvent?: boolean): void;
    /**
     * CheckBar에 설정된 옵션으로 그리드의 데이터행을 모두 체크 또는 해제한다.
     *
     * @remarks
     * {@link CheckBar} 의 exclusive에 영향을 받지않는다.
     * {@link GridBase.onItemChecked | onItemChecked()} 는 발생하지 않는다.
     * CheckBar|CheckBar.head의 v 표시를 활성 상태로 적용시킨다.
     *
     * @param checked - 기본값: true, true: 체크, false, 해제
     * @param itemChecked - 기본값: true, CheckBar.head의 v표시 활성 여부
     *
     *  @example
     * ```js
     * gridView.setAllCheck();
     * ```
     */
    setAllCheck(checked?: boolean, itemChecked?: boolean): void;
    /**
     * 모든 아이템들이 체크되어있는지 여부를 반환한다.
     *
     * @returns CheckBar|CheckBar.head의 v 표시가 활성 상태이면 true를 반환한다.
     *
     * @example
     * ```js
     * let all = gridView.isAllChecked();
     * ```
     */
    isAllChecked(): boolean;
    /**
     * CheckBar에 적용된 모든 행의 Checkable 상태를 초기화한다.
     *
     * @param clearExpression - CheckBar의 checkableExpression을 clear 실행 여부
     *
     */
    resetCheckables(clearExpression: boolean): void;
    /**
     * CheckBar에 Expression 기준으로 checkable을 적용한다.
     *
     * @example
     * ```js
     * gridView.applyCheckables();
     * ```
     */
    applyCheckables(): void;
    /**
     * CheckBar에 checkableExpression 설정한 후 적용을 한다. 혹은 동시수행 한다.
     *
     * @param expression - 체크 가능 여부의 수식
     * @param apply - 기본값: true, 즉시 적용 여부
     * @example
     * ```js
     * gridView.setCheckableExpression("row % 2 = 1");
     * ```
     */
    setCheckableExpression(expression: string, apply?: boolean): void;
    /**
     * CheckBar에 checkableCallback 설정한 후 적용을 한다. 혹은 동시수행 한다.
     *
     * @param callback - 체크 가능 여부의 콜백
     * @param apply - 기본값: true, 즉시 적용 여부
     *
     * ```js
     * const f = function(dataSource, item) {
     *      console.log("checked!")
     *      return true;
     * }
     * gridView.setCheckableCallback(f);
     * ```
     */
    setCheckableCallback(callback: CheckableCallback, apply?: boolean): void;
    /**
     * 필드의 합계값을 반환한다.
     *
     * @remarks
     * {@link GridBase.summaryMode | summaryMode} 에 따라서 가져올수 있는 값이 다르다.
     *
     * 숫자형 데이터 종류의 필드만 합계값을 가져올수 있다.
     *
     * summaryMode가 {@link SummaryMode.NONE | none}인 경우 미리 계산을 해 놓지 않는다.
     *
     * summaryMode가 {@link SummaryMode.AGGREGATE | aggregate}인 경우 "sum","avg","min",’max","count", "datacount", "dataavg" 를 가져올수 있다.
     *
     * {@link SummaryMode.STATISTICAL | statistical}인 경우 "var","varp","stdev","stdevp"을 추가적으로 가져올수 있다.
     *
     * @param field - 해당 필드명 혹은 인덱스
     * @param type - 기본값: "sum", 다른 속성값은 {@link SummaryType} 참조
     *
     * @example
     *
     * ```js
     * let sum = gridView.getSummary('unitPrice', 'sum');
     * ```
     */
    getSummary(field: string | number, type: SummaryType): number;
    /**
     * itemIndex 에 해당하는 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 형식으로 반환한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModel(3);
     * ```
     */
    getModel(itemIndex: number, extended?: boolean): GridItem;
    /**
     * itemIndex 와 itemType 해당하는 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 형식으로 반환한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @param itemType - {@link ItemType | 아이템 종류} 생략하면 {@link GridBase.getModel}과 동일하다
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModelAs(3, 'row');
     * ```
     */
    getModelAs(itemIndex: number, itemType?: ItemType, extended?: boolean): GridItem;
    /**
     * itemIndex 에 해당하는 그룹 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 형식으로 반환한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let group = gridView.getGroupModel(1);
     * ```
     */
    getGroupModel(itemIndex: number, extended?: boolean): GridItem;
    /**
     * 아이템 모델의 최상위 조상 아이템 모델을 반환한다.
     *
     * @param model - 모델 정보
     * @param extended - 확장 정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * const idx = gridView.getCurrent();
     * const item = gridView.getModel(idx.itemIndex);
     * const root = gridView.getRootModel(item, extended);
     * ```
     */
    getRootModel(model: GridItem, extended?: boolean): GridItem;
    /**
     * 지정한 아이템의 인덱스들에 해당하는 아이템 모델들을 반홚나다.
     *
     * @remarks
     * {@link GridItem} 의 배열 형식으로 반환한다.
     *
     * @param itemIndices - 아이템의 인덱스 배열
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let models = gridView.getModels([1,2,3]);
     * ```
     */
    getModels(itemIndices: number | number[], extended?: boolean): GridItem[];
    /**
     * 행 고유번호에 해당하는 아이템 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 형식으로 반환한다.
     *
     * @param dataRow - 행 고유번호
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let row = gridView.getModelOfRow(1);
     * ```
     */
    getModelOfRow(dataRow: number, extended?: boolean): GridItem;
    /**
     * 행 고유번호들에 해당하는 아이템 모델들을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 배열 형식으로 반환한다.
     *
     * @param dataRows - 행 고유번호 배열
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let rows = gridView.getModelsOfRows([1,2,3]);
     * ```
     */
    getModelsOfRows(dataRows: number | number[], extended?: boolean): GridItem[];
    /**
     * 아이템 모델의 부모 아이템 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 형식으로 반환한다.
     *
     * @param model - 아이템 모델 정보
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModel(3);
     * let parent = gridView.getParentModel(model);
     * ```
     */
    getParentModel(model: GridItem, extended?: boolean): GridItem;
    /**
     * 아이템 모델의 자식 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 형식으로 반환한다.
     *
     * @param parentModel - 아이템 모델 정보
     * @param index - 자식 모델 사이에서의 해당 자식 모델의 인덱스
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModel(3);
     * let child = gridView.getChildModel(model, 2);
     * ```
     */
    getChildModel(parentModel: GridItem, index: number, extended?: boolean): GridItem;
    /**
     * 아이템 모델의 자식 모델들을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 배열 형식으로 반환한다.
     *
     * @param parentModel - 아이템 모델 정보
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModel(3);
     * let childs = gridView.getChildModels(model);
     * ```
     */
    getChildModels(parentModel: GridItem, extended?: boolean): GridItem[];
    /**
     * 아이템 모델의 자손 모델들을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 배열 형식으로 반환한다.
     *
     * @param parentModel - 아이템 모델 정보
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModel(3);
     * let descendants = gridView.getChildModels(model);
     * ```
     */
    getDescendantModels(parentModel: GridItem, extended?: boolean): GridItem[];
    /**
     * 지정한 그룹아이템 모델의 합계 정보를 반환한다.
     *
     * @remarks
     * 숫자형 필드에 대해서만 의미있는 값을 리턴한다.
     *
     * {@link GroupSummary} 형식으로 반환한다.
     *
     * @param model - 아이템 모델 정보
     * @param field - 필드명
     * @param statistical - 기본값: `false`, {@link GridBase.summaryMode | summaryMode}를 {@link SummaryMode.STATISTICAL | statistical}로 할 경우 `true`, {@link SummaryMode.AGGREGATE | aggregate}으로 할 경우 `false`로 한다.
     *
     * @example
     * ```js
     * let group = gridView.getGroupModel(1);
     * let summary = gridView.getGroupSummary(group, 'fieldName', true);
     * ```
     */
    getGroupSummary(model: GridItem, field: string, statistical?: boolean): GroupSummary;
    /**
     * 필드의 중복되지 않은 값들을 반환한다.
     *
     * @remarks
     * filtering, softDeleting에 의해서 감춰진 행을 제외하고 지정된 필드에 해당하는 값들을 중복을 배제하여 정렬상태로 반환한다,
     *
     * @param field - 필드 명 또는 필드 인덱스
     * @param maxCount - 최대 건수, 정렬한 상태에서 위에부터 건수만큼 잘라서 반환한다. 기본값: `-1`
     * @param sortDir - 정렬 방법, 기본값: {@link SortDirection.ASCENDING}
     *
     * @example
     * ```js
     * gridView.getDistinctItemValues('field1');
     * ```
     */
    getDistinctItemValues(field: number | string, maxCount?: number, sortDir?: SortDirection): any[];
    /**
     * 프로그레스 바를 표시한다.
     *
     * @remarks
     * 진척 상태를 알리는 Progress Bar를 화면에 표시한다.
     *
     * 진척 값과 문자열 정보는 {@link GridBase.setProgress | setProgress()}를 통해 설정한다.
     *
     * @example
     * ```js
     * gridView.showProgress();
     * ```
     */
    showProgress(): void;
    /**
     * 프로그레스 바의 상태를 설정한다.
     *
     * @remarks
     * 화면에 표시될 진척의 최소/최대값 현재값, 표시 문자을 설정한다.
     *
     * @param min - 최소 값
     * @param max - 최대 값
     * @param position - 최소 값과 최대 값 사이의 현재 값
     * @param message - Progress Bar 하단에 표시할 문자열, 미 지정시 기본 문자열 출력
     *
     * @example
     * ```js
     * gridView.setProgress(0, 100, 50);
     * ```
     */
    setProgress(min: number, max: number, position: number, message?: string): void;
    /**
     * 프로그레스 바를 닫는다.
     *
     * @example
     * ```js
     * gridView.closeProgress();
     * ```
     */
    closeProgress(): void;
    /**
     * 로딩 애니메이션을 표시한다.
     *
     * @param disabled - true이면 마우스와 키보드의 동작을 막는다.  - 기본값: `false`,
     * @example
     * ```js
     * gridView.showLoading();
     * ```
     */
    showLoading(disabled?: boolean): void;
    /**
     * 로딩 애니메이션을 숨긴다.
     *
     * @example
     * ```js
     * gridView.closeLoading();
     * ```
     */
    closeLoading(): void;
    /**
     * 지정한 필드들의 값에 해당하는 첫번째 행을 찾아 행의 번호를 반환한다.
     *
     * @param options - {@link SearchOptions} 형태의 설정 정보 모델
     *
     * @example
     *
     * ```js
     * function searchItemHandler() {
     *     let values = ["PR20012392", "QF24212112"]
     *     let fields = [ "RequestType", "ServiceCode" ];
     *     let startFieldIndex = fields.indexOf(gridView.getCurrent().fieldName) + 1;
     *     let options = {
     *          fields : fields,
     *          values: values,
     *          startIndex : gridView.getCurrent().itemIndex,
     *          startFieldIndex : startFieldIndex,
     *          wrap : true,
     *          caseSensitive : false,
     *          partialMatch : true
     *     }
     *     let index = gridView.searchCell(options);
     *     gridView.setCurrent(index);
     * }
     * ```
     */
    searchItem(options: SearchOptions): number;
    /**
     * 지정한 필드들의 값에 해당하는 셀을 찾아 {@link CellIndex}를 반환한다.
     *
     * @param options - {@link SearchCellOptions} 형태의 설정 정보 모델
     *
     *
     * @example
     * ```js
     * function searchCellHandler() {
     *     let value = "PR20012392"
     *     let fields = [ "RequestType", "ServiceCode" ];
     *     let startFieldIndex = fields.indexOf(gridView.getCurrent().fieldName) + 1;
     *     let options = {
     *          fields : fields,
     *          value : value,
     *          startIndex : gridView.getCurrent().itemIndex,
     *          startFieldIndex : startFieldIndex,
     *          wrap : true,
     *          caseSensitive : false,
     *          partialMatch : true
     *     }
     *     let index = gridView.searchCell(options);
     *     gridView.setCurrent(index);
     * }
     * ```
     */
    searchCell(options: SearchCellOptions): any;
    /**
     * 그리드 상위 DIV 영역의 크기를 변경했는데 그리드의 크기가 변경되지 않을때 명시적으로 변경한다.
     *
     * @remarks
     * 그리드가 올라갈 element의 크기가 결정되기 전에 그리드가 생성되거나 element의 style.display속성이 none이어서 그리드의 크기가 0 인 경우,
     *
     * 그리드 상위 DIV 영역의 크기를 변경했는데 그리드의 크기가 변경되지 않을때 사용한다.
     *
     * @param callback - 크기가 재설정 된 후 실행될 콜백
     *
     * ```js
     * const f = function() {
     *      console.log('resized1)
     * }
     * gridView.resetSize(f)
     * ```
     */
    resetSize(callback: any): void;
    /**
     * 필터박스 또는 DropDown Editor를 닫는다.
     *
     * @example
     * ```js
     * gridView.closeList();
     * ```
     */
    closeList(): void;
    /**
     * 지정한 설정에 따라 현재 그리드의 모양과 데이터를 외부 문서로 내보낸다.
     *
     * @param options - {@link GridExportOptions} 과 같은 설정 모델.
     *
     * @example
     * ```js
     * gridView.exportGrid({
     *      type: 'csv'
     * })
     * ```
     */
    exportGrid(options: GridExportOptions): void;
    /**
     * 현재를 기준으로 페이지를 이동한다.
     *
     * @param offset - 현재를 기준으로 이동하려는 페이지 수. 이전 페이지는 음수.
     *
     * @example
     * ```js
     * gridView.scrollPage(3);
     * ```
     */
    scrollPage(offset: number): void;
    /**
     * 그리드 맨 위의 지정한 행의 인덱스를 반환한다.
     *
     * @example
     * ```js
     * let topItem = gridView.getTopItem();
     * ```
     */
    getTopItem(): number;
    /**
     * 그리드 맨 위에 지정한 행으로 위치한다.
     *
     * @param itemIndex - 기본값: 0, 그리드 상단에 위치하고자 하는 행의 인덱스
     *
     * @example
     * ```js
     * gridView.setTopItem();
     * ```
     */
    setTopItem(itemIndex?: number): void;
    /**
     * 가장 왼쪽 화면에 표시되고 있는 컬럼의 x 좌표값을 반환한다.
     *
     * @example
     * ```js
     * let leftPos = gridView.getLeftPos();
     * ```
     */
    getLeftPos(): number;
    /**
     * 그리드 왼쪽 경계가 지정한 값에 위치한다.
     *
     * @param position - x좌표 값
     *
     * @example
     * ```js
     * gridView.setLeftPos(10);
     * ```
     */
    setLeftPos(position: number): void;
    /**
     * 그리드 왼쪽 경계에 지정한 컬럼이 위치한다.
     *
     * @param column - 컬럼의 이름 또는 index
     *
     * @example
     * ```js
     * gridView.setLeftCol(10);
     * ```
     */
    setLeftCol(column: string | number): void;
    /**
     * 그리드가 위치한 div를 반환한다.
     *
     * @example
     * ```js
     * let gridContainer = gridView.getContainer;
     * ```
     */
    getContainer(): HTMLDivElement;
    /**
     * 그리드를 해제한다.
     *
     * @example
     * ```js
     * gridView.destory();
     * ```
     */
    destroy(): void;
    /**
     * 화면에 보여지고 있는 아이템중 일부만 보이는 행을 제외한 갯수를 반환한다.
     *
     * @remarks
     * 현재 화면에 `10`개의 행이 보여지고 있지만 마지막행이 일부만 보이는 경우 `9`를 반환한다.
     *
     * @example
     * ```js
     * let totalCount = gridView.fullItemCount();
     * ```
     */
    fullItemCount(): number;
    /**
     * 그리드에 연결되어 있는 datasource를 이전 상태로 되돌린다.
     *
     * @example
     * ```js
     * gridView.undo();
     * ```
     */
    undo(): boolean;
    /**
     * 그리드에 연결되어 있는 datasource를 undo했을 때, 다시 수정 후 상태로 되돌린다.
     *
     * @example
     * ```js
     * gridView.redo();
     * ```
     */
    redo(): boolean;
    /**
     * Command Stack 을 초기화한다.
     *
     * @param all - ?
     *
     * @example
     * ```js
     * gridView.clearCommandStack();
     * ```
     */
    clearCommandStack(all?: boolean): void;



}

/**
 * @remarks
 * 그리드의 셀 관련 모델의 기반 클래스
 *
 * [하위 클래스]
 *
 * {@link StyledCell}
 *
 * {@link ValueCell}
 *
 *  - {@link DataCell}
 */
export declare interface GridCell {
    /**
     * 셀의 위치정보
     *
     * @remarks
     * {@link CellIndex} 와는 다르게 proxy처리되지 않은 내부 객체가 그대로 전달된다.
     */
    index?: CellIndex;
    /**
     * 셀이 위치한 아이템의 정보 모델
     */
    item?: GridItem;
    /**
     * 셀이 참조하는 Column정보
     */
    valueColumn?: ValueColumn;
    /**
     * 셀이 참조하는 DataColumn정보
     */
    dataColumn?: DataColumn;
    /**
     * 화면에 표시되는 text
     *
     * @remarks
     * 그리드 body영역을 제외한 나머지 셀에 표시되는 text
     */
    text?: string;
    /**
     * 참조하고 있는 data
     *
     * @remarks
     * 그리드 body영역에 위치한 셀의 value
     *
     */
    value?: any;
    /**
     * RowGroup관련 셀인 경우 참조하고 있는 item의 level
     * @defaultValue `0`
     */
    level?: number;
}

/**
 * @public
 *
 * 그리드의 셀 종류
 *
 * @remarks
 * {@link ClickData} 등에서 사용된다.
 *
 * @example
 * ```js
 * gridView.onMenuItemClicked =  function (grid, item, clickData) {
 *      console.log(item.label + "was clicked.");
 *      console.log("cellType is: " + clickData.cellType);
 * };
 * ```
 */
export declare const enum GridCellType {
    /**
     * 데이터
     */
    DATA = "data",
    /**
     * 헤더
     */
    HEADER = "header",
    /**
     * 푸터
     */
    FOOTER = "footer",
    /**
     * Summary
     */
    SUMMARY = "summary",
    /**
     * 인디케이터
     */
    INDICATOR = "indicator",
    /**
     * 상태 바
     */
    STATE = "state",
    /**
     * 체크 바
     */
    CHECK = "check",
    /**
     * head
     */
    HEAD = "head",
    /**
     * foot
     */
    FOOT = "foot",
    /**
     * sum
     */
    SUM = "sum",
    /**
     * 고정 바
     */
    FIXED_BAR = "fixedbar",
    /**
     * 그룹 헤더
     */
    GROUP_HEADER = "groupHeader",
    /**
     * 그룹 푸터
     */
    GROUP_FOOTER = "groupFooter",
    /**
     * 그룹 바
     */
    GROUP_BAR = "groupBar",
    /**
     * group head
     */
    GROUP_HEAD = "groupHead",
    /**
     * group foot
     */
    GROUP_FOOT = "groupFoot",
    /**
     * 그룹 패널
     */
    GROUP_PANEL = "groupPanel",
    /**
     * 그룹 컬럼
     */
    GROUP_COLUMN = "groupColumn",
    /**
     * 빈 그리드
     */
    GRID_EMPTY = "gridEmpty",
    /**
     * Column Group의 Header
     */
    LAYOUT_HEADER = "layoutHeader",
    /**
     * filter rowIndicator영역
     */
    FILTER = "filter",
    /**
     * inline-filter body영역
     */
    INLINE_FILTER = "inlineFilter"
}

/**
 * @public
 * 컬럼 정보 모델
 *
 * @remarks
 * 실질적으로 GridColumn의 자손 클래스인 {@link DataColumn} 또는 {@link SeriesColumn} 이 사용된다.
 *
 * [하위 클래스]
 *
 * {@link ValueColumn}
 *
 * - {@link DataColumn}
 *
 * - {@link SeriesColumn}
 */
export declare interface GridColumn {
    /**
     * 컬럼 이름
     */
    name?: string;
    /**
     * 컬럼 표시 여부
     *
     * @remarks
     * `false` 이면 연결된 layout의 visible이 `true` 여도 표시되지 않는다.
     * 즉, layout과 컬럼의 visible이 모두 `true` 여야 한다.
     */
    visible?: boolean;
    /**
     * 컬럼 너비
     */
    width?: number;
    /**
     * 컬럼 그룹 내 너비
     *
     * @remarks
     * 비율로 지정된다.
     *
     * @defaultValue `NaN`
     */
    fillWidth?: number;
    /**
     * 컬럼 너비 조절 가능 여부
     *
     * @defaultValue `true`
     */
    resizable?: boolean;
    /**
     * 컬럼 이동 가능 여부
     *
     * @defaultValue `true`
     */
    movable?: boolean;
    /**
     * 체크 여부
     *
     * @remarks
     *
     * {@link ColumnHeader.checkLocation | column.header.checkLocation}이 `none`이 아닌경우 체크상태가 화면에 표시된다.
     */
    checked?: boolean;
    /**
     * 컬럼 헤더
     */
    header?: ColumnHeader;
    /**
     * 컬럼 푸터 컬렉션 오브젝트
     *
     */
    footers?: ColumnFooterCollection;
    /**
     * 컬럼 푸터 설정
     *
     * @remarks
     * footer가 여러줄인경우 스타일과 expression등을 설정한다.
     *
     * @param footers - 푸터 설정정보 배열
     *
     * @example
     * ```js
     * gridView.setFooters([{styleName:"footer-style1"}, {styleName:"footer-style2"}]);
     * gridView.columnByName("column").setFooters([
     *      {styleName:"footer-cell-style1", expression: "sum"},
     *      {styleName:"footer-cell-style2", expression: "max"}
     * ]);
     * ```
     */
    setFooters(footers: any[]): void;
    /**
     * 컬럼 푸터 (여러 개 있을 경우 첫 번째 아이템)
     */
    footer?: ColumnFooter;
    /**
     * 헤더 Summary 컬렉션 오브젝트.
     *
     */
    headerSummaries?: ColumnHeaderSummaryCollection;
    /**
     * 컬럼 HeaderSummary 설정
     *
     * @remarks
     * headerSummary가 여러줄인 경우 스타일과 expression등을 설정한다.
     *
     * @param summaries - headerSummary 설정정보 배열
     *
     * @example
     * ```js
     * gridView.setHeaderSummaries([{styleName:"summary-style1"}, {styleName:"summary-style2"}]);
     * gridView.columnByName("column").setHeaderSummaries([
     *      {styleName:"summary-cell-style1", expression: "sum"},
     *      {styleName:"summary-cell-style2", expression: "max"}
     * ]);
     * ```
     */
    setHeaderSummaries(summaries: any[]): void;
    /**
     * 헤더 Summary (여러 개일 경우 첫 번째 아이템)
     */
    headerSummary?: ColumnHeaderSummary;
    /**
     * 그룹 푸터 컬렉션 오브젝트.
     */
    groupFooters?: ColumnFooterCollection;
    /**
     * 컬럼 groupFooter 설정
     *
     * @remarks
     * groupFooter가 여러줄인 경우 스타일과 expression등을 설정한다.
     *
     * @param footers - footer 설정정보 배열
     *
     * @example
     * ```js
     * gridView.rowGroup.setFooters([{styleName:"footer-style1"}, {styleName:"footer-style2"}]);
     * gridView.columnByName("column").setGroupFooters([
     *      {styleName:"footer-cell-style1", expression: "sum"},
     *      {styleName:"footer-cell-style2", expression: "max"}
     * ]);
     * ```
     */
    setGroupFooters?(footers: ColumnSummary[]): void;
    /**
     * 그룹 푸터 (여러 개일 경우 첫번째 아이템)
     */
    groupFooter?: ColumnSummary;
    /**
     * 순서
     * @readonly
     */
    index?: number;
    /**
     * 컬럼이 속한 컬럼그룹내에서 컬럼의 표시 텍스트
     * @remarks
     * 읽기만 가능한 값이다.
     * @readonly
     */
    displayText?: string;
    /**
     * 컬럼이 속한 컬럼그룹내에서 컬럼의 표시 너비
     * @remarks
     * 읽기만 가능한 값이다.
     * @readonly
     */
    displayWidth?: number;
    /**
     * 컬럼이 속한 컬럼그룹내에서 컬럼의 표시 순서를 나타낸다.
     * @remarks
     * 읽기만 가능한 값이다.
     * @readonly
     */
    displayIndex?: number;
    /**
     * 레이아웃 아이템 객체
     *
     * @remarks
     * 속성으로 접근하여 설정할 수 있다.
     *
     * @example
     * ```js
     * column.layout.spanCallback = function (grid, layout, itemIndex) {
     *     var value = grid.getValue(itemIndex, layout.column.name);
     *     if (value) {
     *         return value[0] === "B" ? 2 : value[0] === "F" ? 3 : 1;
     *     }
     * };
     * ```
     */
    layout?: CellLayoutColumnItem;
    /**
     * 컬럼 푸터를 가져온다.
     *
     * @param index - 순번
     */
    getFooter(index: number): ColumnFooter;
    /**
     * 컬럼 headerSummary를 가져온다.
     * @param index - 순번
     */
    getHeaderSummary(index: number): ColumnHeaderSummary;
}

/**
 * 그리드 내보내기에 관한 설정 모델
 *
 * @remarks
 * {@link ExportOptions} 를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link ExportOptions}
 */
export declare interface GridExportOptions extends ExportOptions {
    /**
     * 내보내기 시 엑셀 문서의 제목
     */
    documentTitle?: DocumentTitle;
    /**
     * 내보내기 시 엑셀 문서의 부제목
     */
    documentSubtitle?: DocumentTitle;
    /**
     * 내보내기 시 엑셀 문서의 꼬릿말
     */
    documentTail?: DocumentTitle;
    /**
     * 컬럼 그룹을 해제하고 엑셀로 내보내기 할 것인지의 여부
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    linear?: boolean;
    /**
     * 숨겨진 컬럼들도 엑셀로 내보내기 할 것인지의 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    allColumns?: boolean;
    /**
     * 숨겨진 행들도 엑셀로 내보내기 할 것인지의 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     *
     * @defaultValue `true`
     */
    allItems?: boolean;
    /**
     * 체크한 행들만 엑셀로 내보내기 할 것인지의 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @remarks
     * 그룹핑 된 행이나 {@link TreeView} 에서는 지원하지 않는다.
     *
     * @defaultValue `false`
     */
    onlyCheckedItems?: boolean;
    /**
     * 엑셀로 내보내기 시 페이징되어 보이지 않는 데이터를 포함한 모든 데이터를 내보내기 할 것인지의 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    pagingAllItems?: boolean;
    /**
     * 그리드 인디케이터 영역을 포함시킬 것인지의 여부
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라 포함, `'hidden'` 이면 포함 안함, `'visible'` 이면 포함한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     *
     */
    indicator?: string;
    /**
     * 그리드 체크바 영역을 포함시킬 것인지의 여부
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라 포함, `'hidden'` 이면 포함 안함, `'visible'` 이면 포함한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     *
     */
    checkBar?: string;
    /**
     * 그리드 헤더 영역을 포함시킬 것인지의 여부
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라 포함, `'hidden'` 이면 포함 안함, `'visible'` 이면 포함한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     *
     */
    header?: string;
    /**
     * 그리드 푸터 영역을 포함시킬 것인지의 여부
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라 포함, `'hidden'` 이면 포함 안함, `'visible'` 이면 포함한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     *
     */
    footer?: string;
    /**
     * 그리드 Header Summary 영역을 포함시킬 것인지의 여부
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라 포함, `'hidden'` 이면 포함 안함, `'visible'` 이면 포함한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     */
    headerSummary?: string;
    /**
     * 그리드 인디케이터 영역을 내보내기 했을 때, 해당 영역의 값의 표시 방법
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라, `'row'` 이면 행의 고유번호로, `'item'` 이면 1부터 시작하여 표시한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     */
    indicatorValue?: string;
    /**
     * 그리드 체크바 영역을 내보내기 했을 때, 체크 마크 값의 표시 방법
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'v'`
     */
    checkMark?: string;
    /**
     * 행 그룹핑 및 트리 그리드 자료를 내보내기 시 들여쓰기 여부
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `true`
     */
    indenting?: boolean;
    /**
     * 엑셀 내보내기 시 병합 해제 여부
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    separateRows?: boolean;
    /**
     * 컬럼의 lookupDisplay 값을 표시된 값으로의 내보내기 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    lookupDisplay?: boolean;
    /**
     * 행 그룹핑 된 자료를 내보내기 시 엑셀 왼쪽에 위치한 그룹간 묶음선 표시여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `true`
     */
    showLevelOutline?: boolean;
    /**
     * {@link GridFitStyle} 로 적용된 너비로 내보내기 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     *
     */
    applyFitStyle?: boolean;
    /**
     * Dynamic Styles 을 적용하여 내보내기 것인지의 여부
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    applyDynamicStyles?: boolean;
    /**
     * fixed된 컬럼 또는 row가 있는 경우 틀고정 여부
     *
     * @remarks
     * fixed Column 또는 fixed Row가 있으면 엑셀로 내보내기 할때 `틀고정`을 설정한다.
     *
     * @defaultValue `false`
     */
    applyFixed?: boolean;
    /**
     * expandable이 설정된 컬럼을 export할때 expand여부
     *
     * @remarks
     * 화면의 expand상태에 상관없이 접거나 펼친 상태로 export할때 설정한다.
     *
     * @defaultValue `ignore`
     */
    layoutExpand?: ExportLayoutExpand | string;
    /**
     * 엑셀 sheet 명
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    sheetName?: string;
    /**
     * {@link SeriesColumn | 시리즈}컬럼을 내보내기 할 것인지의 여부
     *
     * @remarks
     * `true`로 지정하면 `sparkLine`, `sparkColumn`, `sparkWinLoss` 컬럼들이 내보내기 된다.
     *
     * 스파크 컬럼들이 참조하고 있는 {@link DataColumn}들을 반드시 포함하여 내보내기 해야하며 `DataColumn`의 `name` 속성은 반드시 지정되어 있어야 한다.
     *
     * 또한 `DataColumn`은 참조한 순서대로 표시되어 있어야 한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     *
     */
    exportSeriesColumn?: boolean;
    /**
     * 엑셀로 내보내기 하고자 하는 컬럼의 배열
     *
     * @remarks
     * `visible`이 `false`이지만 내보내기를 하고 싶은 컬럼을 지정한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    showColumns?: string[];
    /**
     * 엑셀로 내보내기 안하고자 하는 컬럼을 배열
     *
     * @remarks
     * `visible`이 `true`이지만 내보내기를 하고 싶지 않은 컬럼을 지정한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    hideColumns?: string[];
    /**
     *
     * 엑셀의 hidden Column
     *
     * @remarks
     * 엑셀로 export되었을때 hidden상태로 내보내기 되는 컬럼을 지정한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    hiddenColumns?: string[];
    /**
     * LinkCellRenderer의 url을 내보내기 할것인지 여부

     * @remarks
     * `true`로 지정하면 url의 HYPERLINK로 내보내기 한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    exportLink?: boolean;
    /**
     * TemplateCellRenderer를 내보내기 할것인지 여부
     *
     * @remarks
     * `true`로 지정하면 TemplateCellRenderer가 renderering한 HTML에서 Tag를 제거한 문자열을 내보내기 한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    exportTemplate?: boolean;
    /**
     * 엑셀로 내보내기 하려는 모양이 화면과 다를때 사용하는 layout
     *
     * @remarks
     * 원하는 layout을 지정하여 excel로 내보내기 한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    exportLayout?: ConfigObject[];
    /**
     * 내보내기를 할 그리드의 GridBase 컨트롤과 내보내기의 대상이 되는 엑셀 sheet 의 이름
     *
     * @remarks
     * 지정하지 않으면 메소드를 호출한 그리드 인스턴스가 GridBase 컨트롤로 지정되어 `'sheet1'` 에 내보내기된다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    exportGrids?: {
        grid: GridBase;
        sheetName: string;
    }[];
    /**
     * 왼쪽 여백컬럼의 수를 지정한다.
     *
     * @remarks
     * 그리드를 출력할때 지정된 컬럼수 이후부터 출력한다.
     */
    xOffset?: number;
    /**
     * 왼쪽 여백컬럼의 너비를 지정한다.
     *
     * @remarks
     * pixel단위로 지정한다.
     *
     * @defaultValue `100`
     */
    xOffsetWidth?: number;
    /**
     * 위쪽 여백행의 수를 지정한다.
     *
     * @remarks
     * 그리드를 출력할때 지정된 행수 이후부터 출력한다.
     */
    yOffset?: number;
    /**
     * 엑셀로 내보내기 할때 sheet에 추가할 attribute
     *
     * @remarks
     * json 형식으로 입력된 값을 sheetView element의 attribute로 추가한다.
     *
     * @example
     * ```js
     * var sheetAttrs = {
     *   showGridLines: "0", // 눈금선 감추기
     *   view: "pageBreakPreview" // 페이지 나누기 미리 보기
     * }
     * gridView.exportGrid({type:"excel", target:"local", sheetAttrs:sheetAttrs})
     * ```
     */
    sheetAttrs?: ConfigObject;
    /**
     * 엑셀로 내보내기 할때 스타일 찾기위한 접두어가 있는 경우 사용
     *
     * @remarks
     * 제공된 스타일에 영역을 제한하기 위한 className이 있는 경우 사용한다.
     */
    stylePrefix?: string;
    /**
     * excel로 export할때 image 포함 여부
     *
     * @remarks
     * `true`이면 imageRenderer, iconRenderer를 이용해서 표시한 image를 excel에 포함한다.
     * displayOptions.rowHeight가 -1인경우 셀의 상단에 표시.
     * IE의 경우 Promise 관련 polyFill을 추가해야 한다.
     *
     * @defaultValue `false`
     */
    exportImage?: boolean;
    /**
     * 사용자 지정 출력
     *
     * @remarks
     * export되는 엑셀파일에 그리드 이외의 내용을 출력할때 사용한다.
     *
     * 그리드가 출력하는 영역은 사용을 자제해야한다.
     *
     * @defaultValue `undefined`
     */
    userCells?: UserExportCell[];
    /**
     * 사용자 출력셀을 만들기 위해 호출되는 callback userCells가 지정되어있으면 callback은 무시된다.
     *
     * @remarks
     * 출력되는 column과 row의 갯수를 참조해서 cell의 위치를 변경할때 사용한다.
     *
     * @defaultValue `undefined`
     */
    userCellsCallback?: UserCellsCallback;
    /**
     * 잠긴 셀의 내용과 워크시트 보호
     *
     * @remarks
     * 다른 사용자가 잠긴 셀을 수정하지 못하도록 시트 보호를 설정한다.
     */
    sheetProtect?: boolean;
    /**
     * 시트 보호를 사용할때 해제 암호를 입력한다.
     *
     * @remarks
     * 영문/숫자/특수문자만 입력해야한다. 한글을 입력하는 경우 시트보호를 해제할수 없다.
     */
    protectPassword?: string;
    /**
     * 시트 보호를 사용할때 허용하거나 잠글 속성을 지정한다.
     */
    protectProperties?: SheetProtectProperties;
}

/**
 * @public
 *
 * 컬럼들의 표시 방식을 조정하는 상수
 *
 * @remarks
 * {@link DisplayOptions.fitStyle} 등에서 쓰인다.
 *
 * @example
 *
 * ```js
 * grid.displayOptions.fitStyle = 'even'
 * ```
 */
export declare enum GridFitStyle {
    /**
     * 조정하지 않고 컬럼 너비대로 표시
     */
    NONE = "none",
    /**
     * 표시한 컬럼들의 전체 너비가 그리드 너비보다 작을 경우 비율에 맞춰 남는 크기를 분배
     */
    EVEN = "even",
    /**
     * 항상 그리드 너비에 맞게 늘리거나 축소 (컬럼의 width를 이용)
     */
    EVEN_FILL = "evenFill",
    /**
     * fillWidth가 설정되었다면 이를 이용하여, 그렇지 않다면 even과 동일한 방식으로 그리드를 채움
     */
    FILL = "fill"
}

/**
 * @public
 *
 * 푸터 영역의 단일 설정 모델
 *
 * @remarks
 *
 * 그리드는 별도의 설정이 없는 경우 하나의 푸터를 자동으로 생성하고 {@link GridBase.footer}는 첫번째 푸터를 반환한다..
 *
 * {@link GridBase.setFooter | setFooter()}를 이용해서 속성을 변경하거나 또는 {@link GridBase.footer}를 이용해서 원하는 속성만 지정한다.
 *
 *  @example
 *
 * ```js
 * gridView.setFooter({styleName: 'custom-footer'});
 * // 또는
 * gridView.footer.styleName = 'custom-footer';
 * ```
 */
export declare interface GridFooter extends GridSummaryObject {
    /**
     * 스타일 클래스 이름
     */
    styleName?: string;
    /**
     * 최소 높이
     *
     * @defaultValue `23`
     */
    minHeight?: number;
    /**
     * 높이
     *
     * @remarks
     * `0`이면 자동으로 계산하여 지정한다. `0` 이상이면 minHeight와 비교하여 더 큰 값으로 지정한다.
     *
     * @defaultValue `0`
     */
    height?: number;
    /**
     * 여러행으로 구성된 footer Row의 TR별 높이를 배열로 지정한다.
     *
     * @remarks
     * heights가 지정되면 height는 무시된다.
     */
    heights?: number[];
    /**
     * 셀 스타일을 지정하기 위한 콜백
     * @eventProperty
     *
     * @remarks
     * `string` 형태의 css 클래스 명 또는 {@link ColumnSummaryStyleObject} 형태로 지정가능하다.
     *
     * @example
     * ```js
     * // 푸터 적용
     * const f = function (grid, cell) {
     *      if (cell.value > 10) {
     *          return {
     *              styleName: 'custom-footer'
     *          }
     *      }
     * }
     * footer.cellStyleCallback = f;
     * ```
     *
     */
    cellStyleCallback?: CellStyleCallback;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * 푸터의 콜렉션 내에서의 순서
     *
     * @readonly
     */
    footerIndex?: number;
}

/**
 * @public
 *
 * 그리드 푸터 영역에 관한 콜렉션 모델
 *
 * @remarks
 *
 * 그리드의 footer를 표시하거나 여러개의 푸터를 생성하고 관리한다.
 *
 * {@link GridBase.footers} 에서 반환되는 객체이다.
 *
 * @example
 * ```js
 * // object
 * gridView.setFooters({
 *      visible: true,
 *      items:[
 *          {
 *              styleName: 'custom-footer-1'
 *          }, {
 *              styleName: 'custom-footer-2'
 *          }
 *      ]
 * })
 * // 또는 array형태로 지정
 * gridView.setFooters([
 *      {
 *          styleName: 'custom-footer-1'
 *      }, {
 *          styleName: 'custom-footer-2'
 *      }
 * ])
 * ```
 */
export declare interface GridFooterCollection {
    /**
     * 표시여부
     *
     * @defaultValue `true`
     */
    visible?: boolean;
    /**
     * 현재 설정된 footer의 갯수를 반환한다.
     *
     * @readonly
     */
    readonly count?: number;
    /**
     * 현재 설정된 footer중 visible이 `true`인 footer의 갯수를 반환한다.
     *
     * @readonly
     */
    readonly visibleCount?: number;
    /**
     * gridFooter를 설정한다.
     */
    items?: GridFooter[];
    /**
     * 해당하는 인덱스의 푸터를 반환한다.
     *
     * @remarks
     * {@link GridFooter}를 반환한다.
     *
     * @param index - footer의 index
     */
    get?(index: number): GridFooter;
    /**
     * 보여지는 순서에 해당하는 푸터를 가져온다.
     *
     * @remarks
     * {@link GridFooter}를 반환한다.
     *
     * @param index - 보여지는 순서 `0`부터 시작한다.
     */
    getVisible?(index: number): GridFooter;
}

/**
 * 헤더 영역의 설정 모델
 *
 * @remarks
 * {@link GridBase.setHeader} 사용시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setHeader({sortable = false});
 * ```
 */
export declare interface GridHeader {
    /**
     * 헤더 행의 최소 높이
     *
     * @defaultValue `21`
     */
    minRowHeight?: number;
    /**
     * 헤더의 최소 높이
     *
     *  @defaultValue `23`
     */
    minHeight?: number;
    /**
     * 헤더의 높이
     *
     * @remarks
     * 1. `0`: 기본 스타일로 tr의 높이를 계산해서 지정(table row의 최소 높이가 됨),
     *    전체 헤더 높이가 커지면 row들이 다 표시되도록 element container의 높이를 보정한다.
     *
     * 2. `0` 초과: 지정한 높이로 전체 높이를 설정, tr 높이는 minRowHeight 높이로 설정한다.
     *    container 높이가 tr들의 높이합보다 큰 경우 배분한다.
     *    container 높이를 보정하지 않는다.
     *
     * 3. `0` 미만: 브라우저가 계산한 높이
     *
     * heights 속성에 각 table row의 높이를 지정할 수 있다.
     *
     * 전체 높이가 minHeight보다 작을 수 없다.
     *
     * 개별 tr의 높이는 minRowHeight보다 작을 수 없다.
     *
     * @defaultValue `0`
     *
     */
    height?: number;
    /**
     * 헤더가 여러줄일때 각행의 높이
     *
     * @remarks
     * 각 table row의 높이를 지정한다.
     *
     * @example
     *
     * ```js
     * gridView.header.heights = [50, 30, 30]
     * ```
     */
    heights?: number[];
    /**
     * 높이 변경 가능 여부
     *
     * @remarks
     * 사용자가 헤더 왼쪽 셀의 위쪽을 마우스 드래깅해서 헤더의 높이를 변경하게 할 것인지의 여부
     *
     * @defaultValue `false`
     */
    resizable?: boolean;
    /**
     * 헤더 테두리와 체크박스나 이미지와의 간격
     *
     * @defaultValue `2`
     */
    itemOffset?: number;
    /**
     * 텍스트와 체크박스나 이미지와의 간격
     *
     * @defaultValue `2`
     */
    itemGap?: number;
    /**
     * 툴팁 표시 여부
     *
     * @remarks
     * 값이 `undefined`인경우 {@link ColumnHeader.showTooltip}이 `true`인 컬럼의 `tooltip`만 표시된다.
     *
     * @defaultValue `false`
     */
    showTooltip?: boolean;
    /**
     * 선택 영역 표시 여부
     *
     * @remarks
     * `true` 시 데이터 선택 영역에 맞춰 관련된 셀들에 선택 영역을 지정한다.
     *
     * @defaultValue `false`
     */
    showSelection?: boolean;
    /**
     * 헤더의 정렬 {@link HandleVisibility | 핸들} 너비
     *
     * @defaultValue `16`
     */
    sortWidth?: number;
    /**
     * 헤더의 정렬 {@link HandleVisibility | 핸들} 높이
     *
     * @defaultValue `16`
     */
    sortHeight?: number;
    /**
     * 헤더의 필터 {@link HandleVisibility | 핸들} 너비
     *
     * @defaultValue `16`
     */
    filterWidth?: number;
    /**
     * 헤더의 필터 {@link HandleVisibility | 핸들} 높이
     *
     * @defaultValue `16`
     */
    filterHeight?: number;
    /**
     * 헤더의 팝업 메뉴 {@link HandleVisibility | 핸들} 너비
     *
     * @defaultValue `16`
     */
    popupWidth?: number;
    /**
     * 헤더의 팝업 메뉴 {@link HandleVisibility | 핸들} 높이
     *
     * @defaultValue `16`
     */
    popupHeight?: number;
    /**
     * 헤더에 popupMenuName이 설정된 경우 팝업 메뉴 핸들을 표시한다.
     * @defaultValue {@link HandleVisibility.VISIBLE}
     */
    showPopupMenu?: HandleVisibility;
    /**
     * 헤더의 체크 박스 너비
     *
     * @defaultValue `16`
     */
    checkWidth?: number;
    /**
     * 헤더의 체크 박스 높이
     *
     * @defaultValue `16`
     */
    checkHeight?: number;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * 스타일 명
     */
    styleName: string;
    /**
     * excel로 export될때 적용될 스타일 명
     */
    exportStyleName?: string;
}

/**
 * 아이템의 정보 모델
 *
 * @remarks
 * {@link GridBase.getModel}, {@link GridBase.getModelAs} 등으로 아이템의 모델을 반환할 때의 형식이다.
 *
 * 아이템의 모델을 반환 할 때, 해당 method 에 `extended` 매개변수가 `true` 냐 `false` 냐에 따라 반환되는 모델의 형식이 다를 수 있다.
 *
 * @example
 * ```js
 * let model = gridView.getModelAs(3, 'row'); // GridItem 모델 반환
 * ```
 */
export declare interface GridItem {
    /**
     * 종류
     */
    type: undefined | 'row' | 'group' | 'tree' | 'footer';
    /**
     * 아이템 id
     */
    id: number;
    /**
     * 부모의 id
     */
    parentId?: number;
    /**
     * 그리드 상에서의 순서
     */
    index: number;
    /**
     * 그리드 상에서의 순서
     *
     * @remarks
     * RealGridJS와 호환성을 위해서 남겨둔 속성
     */
    itemIndex?: number;
    /**
     * 행 고유번호
     */
    dataRow: number;
    /**
     * 체크 여부
     */
    checked: boolean;
    /**
     * 하위 아이템의 개수
     */
    count?: number;
    /**
     * 펼쳐짐 여부
     *
     * @remarks
     * {@link TreeView} 의 아이템일나 그룹 아이템일 때 해당 정보를 얻을 수 있다.
     */
    expanded?: boolean;
    /**
     * 푸터 id
     */
    footerId?: number;
    /**
     * 자신의 부모를 기준으로한 자신의 순서
     *
     * @remarks
     * `extended` 가 `true` 여야 정보를 얻을 수 있다.
     */
    childIndex?: number;
    /**
     * 수준
     *
     * @remarks
     * {@link TreeView} 의 행이라면 트리의 수준이다.
     *
     * `extended` 가 `true` 여야 정보를 얻을 수 있다.
     */
    level?: number;
    /**
     * 그룹아이템일 경우 처음 아이템
     *
     * @remarks
     * `extended` 가 `true` 여야 정보를 얻을 수 있다.
     */
    firstItem?: GridItem;
    /**
     * 그룹아이템일 경우 처음 데이터 아이템
     *
     * @remarks
     * `extended` 가 `true` 여야 정보를 얻을 수 있다.
     */
    firstDataItem?: GridItem;
    /**
     * 그룹아이템일 경우 하위 행들의 인덱스
     *
     * @remarks
     * `extended` 가 `true` 여야 정보를 얻을 수 있다.
     */
    dataRows?: number[];
    /**
     * 행의 상태값
     */
    rowState?: RowState;
}

export declare const gridLicenseCode: string;

export declare const gridLicenseType: string;

/**
 * 그리드의 전체 설정 정보들
 *
 * @remarks
 * {@link GridBase.getOptions} 시 하위 구성 요소를 재설정하는 것이 불가능하다.
 *
 * {@link GridBase.setOptions} 시 하위 구성 요소를 재설정하는 것이 가능하다.
 *
 * 실질적인 사용은 {@link GridView}, {@link TreeView} 에서 한다.
 *
 * @example
 * ```js
 * let options =  {
 *     summaryMode: 'aggregate',
 *     display: {
 *         columnResizable : false
 *     }
 * };
 * gridView.setOptions(options);
 * ```
 */
export declare interface GridOptions {
    summaryMode?: SummaryMode;
    fixed?: FixedOptions;
    display?: DisplayOptions;
    format?: FormatOptions;
    edit?: EditOptions;
    editor?: EditorOptions;
    copy?: CopyOptions;
    paste?: PasteOptions;
    sorting?: SortingOptions;
    filtering?: FilteringOptions;
    dataDrop?: DataDropOptions;
    rowIndicator?: RowIndicator;
    checkBar?: CheckBar;
    stateBar?: StateBar;
    header?: GridHeader;
    footer?: GridFooter;
    footers?: GridFooterCollection;
    headerSummary?: HeaderSummary;
    headerSummaries?: HeaderSummaryCollection;
    /**
     *
     */
    hideDeletedRows?: boolean;
    /**
     *
     */
    sortMode?: SortMode;
}

declare interface GridSummarizer {
    getCount(field: number): number;
    getSum(field: number): number;
    getMax(field: number): number;
    getMin(field: number): number;
    getAvg(field: number): number;
    getVar(field: number): number;
    getVarp(field: number): number;
    getStdev(field: number): number;
    getStdevp(field: number): number;
    getDataAvg(field: number): number;
    getDataCount(field: number): number;
}

/**
 *
 */
declare interface GridSummaryObject {
}

export declare const gridVersion: string;

/**
 * @public
 * GridView 클래스, {@link GridBase} 의 자식 클래스이다.
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link GridBase}
 */
export declare class GridView extends GridBase {


    /**
     * 그리드에 설정되어 있는 행 그룹 모델
     *
     * @remarks
     * {@link RowGroup} 객체를 반환한다.
     * RowGroup 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.rowGroup.mergeMode = true;
     * ```
     */
    get rowGroup(): RowGroup;
    /**
     * 그리드에 설정되어 있는 Group Panel 모델
     *
     * @remarks
     * {@link GroupPanel} 객체를 반환한다.
     * GroupPanel 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.groupPanel.visible = true;
     * ```
     */
    get groupPanel(): GroupPanel;
    /**
     * 데이터 수정 이후 필터의 동작 모드
     *
     * @remarks
     * `'explicit'` 을 사용하면 필터링 된 데이터가 수정되었을 때 명시적으로 필터링을 수행해야 필터링이 된다.
     *
     * @example
     * ```js
     * gridView.filterMode = 'explicit';
     * ```
     */
    get filterMode(): FilterMode;
    set filterMode(value: FilterMode);
    /**
     * 컬럼 간 필터 조건을 or 로 할 것인지의 여부
     *
     * @remarks
     * `true` 로 지정하면 각 컬럼의 필터간 필터링이 or 조건으로 반영되어 표시된다.
     *
     * @example
     * ```js
     * gridView.filterOr = true;
     * ```
     */
    get filterOr(): boolean;
    set filterOr(value: boolean);
    /**
     * 행 그룹핑된 컬럼의 합계를 계산하는 방식
     *
     * @remarks
     * 값 할당으로 변경할 수 있다.
     * {@link SummaryMode} 의 값으로 설정한다.
     *
     * @example
     * ```js
     * gridView.groupSummaryMode = 'aggregate';
     * ```
     */
    get groupSummaryMode(): SummaryMode;
    set groupSummaryMode(value: SummaryMode);
    /**
     * 그리드에 설정되어 있는 행 그룹핑에 관한 설정 정보들
     *
     * @remarks
     * {@link GroupingOptions} 객체를 반환한다.
     * GroupingOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.groupingOptions.linear = true;
     * ```
     */
    get groupingOptions(): GroupingOptions;
    /**
     * 그리드가 Paging 상태일 때, 페이지 이동을 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `page` - 새로 이동하게 될 페이지 인덱스
     *
     * [반환값] - false를 반환하면 페이지 이동이 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onPageChanging = function(grid, page) {
     *      if(page % 2 === 0) {
     *          return true;
     *      }
     *      return false;
     * };
     * ```
     */
    onPageChanging: (grid: GridView, page: number) => boolean;
    /**
     * 그리드가 Paging 상태일 때, 다른 페이지로 이동했음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `page` - 새로 이동한 페이지 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onPageChanged = function(grid, page) {
     *      if(page % 2 === 0) {
     *          console.log('even number changed!')
     *      }
     * };
     * ```
     */
    onPageChanged: (grid: GridView, page: number) => void;
    /**
     * 그리드가 Paging 상태일 때, 변경된 페이지 수와 함께 다른 페이지로 이동했음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `pageCount` - 변경된 페이지 수
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onPageCountChanged = function(grid, pageCount) {
     *      console.log('pageCount: ' + pageCount);
     * };
     * ```
     */
    onPageCountChanged: (grid: GridView, pageCount: number) => void;
    /**
     * 그룹핑을 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `fields` - 그룹핑되는 필드의 인덱스들
     *
     * [반환값] - 그룹핑 실행 여부. false를 반환하면 그룹핑은 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onGrouping = function(grid, fields) {
     *      alert("onGrouping 이벤트가 발생했습니다. false를 반환합니다.");
     *      return false;
     * };
     * ```
     */
    onGrouping: (grid: GridView, fields: number[]) => boolean;
    /**
     * 그룹핑했음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onGrouped = function(grid) {
     *      console.log("I am Grouped!");
     * };
     * ```
     */
    onGrouped: (grid: GridView) => void;
    /**
     * 그룹핑 된 행 펼치기를 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `itemIndex` - 펼칠 그룹 아이템의 itemIndex
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onExpanding = function(grid, itemIndex) {
     *      if (itemIndex % 2 === 0) {
     *          return false;
     *      }
     * };
     * ```
     */
    onExpanding: (grid: GridView, itemIndex: number) => boolean;
    /**
     * 그룹핑 된 행이 펼쳐졌음을 알리는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `itemIndex` - 펼친 그룹 아이템의 id
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onExpanded = function(grid, itemIndex) {
     *      console.log('Expanded at: ' + itemIndex)
     * };
     * ```
     */
    onExpanded: (grid: GridView, itemIndex: number) => void;
    /**
     * 그룹핑 된 행 접기를 결정하는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `itemIndex` - 접을 그룹 아이템의 itemIndex
     *
     * @eventProperty
     * @example
     * ```js
     * gridView.onCollapsing = function(grid, itemIndex) {
     *      if (itemIndex % 2 === 0) {
     *          return false;
     *      }
     * };
     * ```
     */
    onCollapsing: (grid: GridView, itemIndex: number) => boolean;
    /**
     * 그룹핑 된 행이 접힘을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `itemIndex` - 접힌 그룹 아이템의 itemIndex
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCollapsed = function(grid, itemIndex) {
     *      console.log('Collapsed at: ' + itemIndex)
     * };
     * ```
     */
    onCollapsed: (grid: GridView, itemIndex: number) => void;
    /**
     * 그리드의 {@link RowGroup} 을 반환한다.
     * @example
     *
     * ```js
     * let rowGroup = gridView.getRowGroup();
     * rowGroup.levelIndent = false;
     * gridView.setRowGroup(rowGroup);
     * ```
     */
    getRowGroup(): RowGroup;
    /**
     * 그리드의 {@link RowGroup} 을 설정한다.
     *
     * @param value - {@link RowGroup} 모델과 같은 설정정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setRowGroup({levelIndent: false});
     * ```
     */
    setRowGroup(value: RowGroup | ConfigObject): void;
    /**
     * 그리드의 {@link GroupPanel} 을 반환한다.
     *
     * @example
     * ```js
     * let groupPanel = gridView.getGroupPanel();
     * groupPanel.visible = false;
     * gridView.setGroupPanel(groupPanel);
     * ```
     */
    getGroupPanel(): GroupPanel;
    /**
     * 그리드 {@link GroupPanel} 을 설정한다.
     *
     * @param value - {@link GroupPanel} 과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setGroupPanel({visible: false});
     * ```
     */
    setGroupPanel(value: GroupPanel): void;
    /**
     * 그리드 옵션 정보를 반환한다.
     *
     * @remarks
     * {@link GridBase.getOptions} 에 반환되는 모델에 grouping 속성이 추가되어 반환된다.
     *
     * @returns - {@link GridView.setOptions | setOptions()} 와 다르게 GridOptions 에서 선언된 그리드 수준의 정보만을 반환한다.
     * @example
     * ```js
     * let options = gridView.getOptions();
     * ```
     */
    getOptions(): ViewOptions;
    /**
     * 그리드 옵션 정보를 재설정한다.
     *
     * @remarks
     * 그리드 수준의 정보만을 반환하는 {@link GridView.getOptions | getOptions} 와 달리 이 method를 통해 하위 구성 요소 및 다른 실행 정보들을 동시에 재설정할 수 있다.
     *
     * @param options - 설정 정보. GridBase의 {@link GridBase.setOptions | setOptions()}의 value 와 동일한 모델에서 grouping 속성이 추가되었다.
     * ```js
     * let options =  {
     *     summaryMode: 'aggregate',
     *     displayOptions: {
     *         columnResizable : false
     *     },
     *     grouping: {
     *         prompt: 'I am Groop'
     *     }
     * };
     * gridView.setOptions(options);
     * ```
     */
    setOptions(options: ViewOptions): void;
    /**
     * 그리드 행 그룹핑에 관한 설정 정보들을 반환한다.
     *
     * @returns -{@link GroupingOptions} 와 동일한 모델이다.
     *
     * @example
     * ```js
     * let groupingOpts = gridView.getGroupingOptions();
     * groupingOpts.prompt = "I am Groop";
     * gridView.setGroupingOptions(groupingOpts);
     * ```
     */
    getGroupingOptions(): GroupingOptions;
    /**
     * 그리드 행 그룹핑에 관한 설정을 한다.
     *
     * @param value - 설정하고자 하는 정보. {@link GroupingOptions} 와 동일한 모델이다.
     *
     * @example
     *
     * ```js
     * gridView.setGroupingOptions({prompt: "I am Groop"});
     * ```
     *
     */
    setGroupingOptions(value: GroupingOptions): void;
    /**
     * 지정한 필드 목록에 포함된 순서대로 또는 데이터 정렬 후 순서대로 행 그룹핑을 실행한다.
     *
     * @param fieldNames - 필드 이름 목록. 그룹을 해제하려는 경우 빈 배열을 입력해야 한다.
     * @param sorting - 정렬 여부
     * @param sortDirs - 정렬 방식
     *
     * @example
     * ```js
     * // 그룹 설정
     * gridView.groupBy(["field1", "field2"]);
     *
     * // 그룹 해제
     * gridView.groupBy([]);
     * ```
     */
    groupBy(fieldNames: string[], sorting?: boolean, sortDir?: SortDirection): void;
    /**
     * 그리드가 그룹핑되어 있는지 여부를 반환한다.
     *
     * @example
     * ```js
     * let isGrouped = gridView.isGrouped();
     * ```
     */
    isGrouped(): boolean;
    /**
     * 그리드가 mergeMode로 되어 있는지 여부를 반환한다.
     *
     * @returns 그리드의 {@link RowGroup.mergeMode} 의 설정값
     *
     * @example
     * ```js
     * let isMergedGrouped = gridView.isMergedGrouped();
     * ```
     */
    isMergedGrouped(): boolean;
    /**
     * 그룹핑 된 필드의 인덱스들을 반환한다.
     *
     * @example
     * ```js
     * let GFields = gridView.getGroupFields();
     * ```
     */
    getGroupFields(): number[];
    /**
     * 그룹핑 된 필드의 이름들을 반환한다.
     *
     * @param orginal - 기본값: true, true: 지정한 이름으로 반환, false: 대문자로 반환
     * @returns 필드들의 이름들. DataProvider가 연결되어 있지 않으면, 필드들의 인덱스들을 반환한다.
     *
     * @example
     * ```js
     * let GFieldNames = gridView.getGroupFieldNames();
     * ```
     */
    getGroupFieldNames(orginal?: boolean): string[] | number[];
    /**
     * 현재 몇 level로 그룹핑되어 있는지를 반환한다.
     *
     * @returns group level의 깊이
     *
     * @example
     * ```js
     * let Glevels = gridView.getGroupLevels();
     * ```
     */
    getGroupLevels(): number;
    /**
     * 지정한 필드의 그룹 level을 반환한다.
     *
     * @remarks
     * 첫번째 그룹 레벨은 1이다.
     *
     * @param field - 필드명 또는 인덱스
     * @returns 해당 필드로 그룹핑되지 않았다면 `0`을 반환한다, 없는 필드명이 지정됐을 경우 `-1`이 반환된다.
     *
     * @example
     * ```js
     * let Glevel = gridView.getGroupLevel('field1');
     * ```
     */
    getGroupLevel(field: string | number): number;
    /**
     * 자신이 속한 그룹의 인덱스를 반환한다.
     *
     * @param itemIndex - 그리드 상의 인덱스
     * @returns 그룹이 없거나, 그룹이 있을 경우 가장 첫 행의 결과는 `-1`이다.
     *
     * @example
     * ```js
     * let GIndex = gridView.getGroupIndex(2);
     * ```
     */
    getGroupIndex(itemIndex: number): number;
    /**
     * 지정한 인덱스가 그룹 아이템인지의 여부를 반환한다.
     *
     * @param itemIndex - 그리드 상의 인덱스
     *
     * @example
     * ```js
     * let isGroupItem = gridView.isGroupItem(4);
     * ```
     */
    isGroupItem(itemIndex: number): boolean;
    /**
     * 지정한 인덱스의 부모의 표시 여부를 반환한다.
     *
     * @param itemIndex - 그리드 상의 인덱스
     * @returns 해당 아이템이 존재하지 않거나, 해당 아이템의 부모가 존재하지 않으면 `false`를 반환한다.
     *
     * @example
     * ```js
     * let isParentVis = gridView.isParentVisible(2);
     * ```
     */
    isParentVisible(itemIndex: number): boolean;
    /**
     * 지정한 그룹을 펼친다(expand).
     *
     * @remarks
     * 지정한 아이템이 존재하지 않거나, 그룹이 아니라면 아무 일도 일어나지 않는다.
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param itemIndex - 해당 그룹의 그리드 상의 인덱스
     * @param recursive - 그룹에 포함된 자손 그룹의 펼침 여부
     * @param force - 기본값: `false`, 이미 expanded 상태라도 recursive가 true일 때 자손들의 펼침 여부
     * @param level - 기본값: `0`, 0일 때 recursive가 true면 모든 자손을 펼친다.
     *
     * @example
     * ```js
     * gridView.expandGroup(2, true);
     * ```
     */
    expandGroup(itemIndex: number, recursive?: boolean, force?: boolean, level?: number): void;
    /**
     * 지정한 그룹을 접는다(collapse).
     *
     * @remarks
     * 지정한 아이템이 존재하지 않거나, 그룹이 아니라면 아무 일도 일어나지 않는다.
     *
     * @param itemIndex - 해당 그룹의 그리드 상의 인덱스
     * @param recursive - 그룹에 포함된 자손 그룹의 접힘여부. true 일때 이미 collapsed 상태라면 아무일도 하지 않는다.
     * @param force - 기본값: `false`, 이미 collapsed 상태라도 recursive가 true일 때 자손들의 접힘여부.
     *
     * @example
     * ```js
     * gridView.collapseGroup(2, true);
     * ```
     */
    collapseGroup(itemIndex: number, recursive: boolean, force?: boolean): void;
    /**
     * 지정한 그룹의 부모를 펼친다.
     *
     * @remarks
     * 지정한 아이템 또는 그 부모가 존재하지 않거나, 그룹이 아니라면 아무 일도 일어나지 않는다.
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param itemIndex - 해당 그룹의 그리드 상의 인덱스
     * @param recursive - 부모 그룹에 포함된 자손 그룹의 펼침여부
     * @param force - 기본값: `false`, 이미 expanded 상태라도 recursive가 true일 때 부모 그룹의 자손들의 펼침여부
     * @param level - 기본값: `0`, 0일 때 recursive가 true면 모든 자손 expand.
     *
     * @example
     * ```js
     * gridView.expandParent(2, true);
     * ```
     */
    expandParent(itemIndex: number, recursive: boolean, force?: boolean, level?: number): void;
    /**
     * 지정한 그룹의 부모를 접는다(collapse).
     *
     * @remarks
     * 지정한 아이템 또는 그 부모가 존재하지 않거나, 그룹이 아니라면 아무 일도 일어나지 않는다.
     *
     * @param itemIndex - 해당 그룹의 그리드 상의 인덱스
     * @param recursive - 부모 그룹에 포함된 자손 그룹의 접힘여부. true 일때 이미 collapsed 상태라면 아무일도 하지 않는다.
     * @param force - 기본값: `false`, 이미 collapsed 상태라도 recursive가 true일 때 부모 그룹의 자손들의 접힘여부
     *
     * @example
     * ```js
     * gridView.collapseParent(2, true);
     * ```
     */
    collapseParent(itemIndex: number, recursive: boolean, force?: boolean): void;
    /**
     * 루트 그룹을 펼친다.
     *
     * @remarks
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 펼침여부.
     * @param level - 기본값: `undefined`, `undefined`: recursive가 true시 모든 자손 expand.
     *
     * @example
     * ```js
     * gridView.expandAll();
     * ```
     */
    expandAll(recursive?: boolean, level?: number): void;
    /**
     * 루트 그룹을 접는다.
     *
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 접힘여부. `true`일 때 그룹에 포함된 자손 그룹도 접힌 상태가 된다.
     *
     * @example
     * ```js
     * gridView.collapseAll();
     * ```
     */
    collapseAll(recursive?: boolean): void;
    /**
     * 그룹Layout의 expandable이 설정된 경우 그룹Layout을 펼친다.
     *
     * @param recursive - 하위 그룹이 있는 경우 하위 그룹도 펼친다.
     */
    layoutExpandAll(recursive: boolean): void;
    /**
     * 그룹Layout의 expandable이 설정된 경우 그룹Layout을 접는다.
     *
     * @param recursive - 하위 그룹이 있는 경우 하위 그룹도 접는다.
     */
    layoutCollapseAll(recursive: boolean): void;
    /**
     * 그리드에 인덱스로 입력된 데이터행 앞 또는 뒤에 새로운 데이터행을 생성한다.
     *
     * @remarks
     * 그리드가 편집상태이거나 데이터 건수가 없는 경우 추가되지 않는다.
     * itemIndex를 입력하지 않으면 (-1이 입력되면), 이전에 실행된 beginInsertRow의 itemIndex 앞에 추가되거나 실행된적이 없으면 0번째 itemIndex앞에 추가된다.
     * 0 이상의 값을 입력하면 데이터행 앞에 새로운 데이터행을 생성한다.
     *
     * @param itemIndex - 기본값: `-1`, 기준 데이터 행. 이 행 앞에 새로운 데이터행을 생성한다.
     * @param shift - 기본값: `false`, `true`: 데이터 행 뒤에 생성
     *
     * @example
     * ```js
     * gridView.beginInsertRow();
     * ```
     */
    beginInsertRow(itemIndex?: number, shift?: boolean): void;
    /**
     * 그리드 마지막 데이터행 이후에 새로운 데이터행을 추가한다.
     *
     * @example
     * ```js
     * gridView.beginAppendRow();
     * ```
     */
    beginAppendRow(): void;
    /**
     * 입력된 인덱스에 해당하는 데이터 행을 편집상태로 변경한다.
     *
     * @param itemIndex - 행의 인덱스. 지정하지 않으면 focuse 행.
     *
     * @example
     * ```js
     * gridView.beginUpdateRow();
     * ```
     */
    beginUpdateRow(itemIndex?: number): void;
    /**
     * 그리드가 Paging 모드로 실행된다.
     *
     * @param paging - true 시 페이징 모드
     * @param size - 기본값: `10`, 한 페이지에 표시할 행의 개수
     * @param maxCount - 기본값: `-1`, 최대 페이지 개수
     *
     * @example
     * ```js
     * gridView.setPaging(true);
     * ```
     */
    setPaging(paging: boolean, size?: number, maxCount?: number): void;
    /**
     * Paging 모드에서 현재 페이지 번호를 반환한다.
     * @example
     * ```js
     * let currPage = gridView.getPaging();
     * ```
     */
    getPage(): number;
    /**
     * Paging 모드일 때 표시할 페이지를 지정한다.
     *
     * @param page - 페이지 번호
     * @param startItem - 기본값: `-1`, 이 페이지에 표시할 첫번째 행의 인덱스. -1이면 {@link GridView.setPaging | setPaging} 에 지정한 페이지 크기에 따라 결정된다.
     *
     * @example
     * ```js
     * gridView.setPage(4);
     * ```
     */
    setPage(page: number, startItem?: number): void;
    /**
     * Paging 모드일 때 전체 페이지 개수를 반환한다.
     *
     * @example
     * ```js
     * let pageCount = gridView.getPageCount();
     * ```
     */
    getPageCount(): number;
    /**
     * Paging 개수를 변경한다.
     *
     * @param count - 새 페이지 개수
     *
     * @example
     * ```js
     * gridView.setPageCount(20);
     * ```
     */
    setPageCount(count: number): void;
    /**
     * @public
     * 행이 위치한 페이지를 찾는다.
     *
     * @param dataRow - 찾을려고 하는 행의 dataRow
     * @returns 행이 위치한 페이지번호 찾지 못하는 경우 `-1`을 return한다.
     */
    getPageOfDataRow(dataRow: number): number;
    /**
     * 체크된 아이템들의 목록을 배열로 반환한다.
     *
     * @param rowOnly - 기본값: `true`, `true`: 행만 반환, `false`: 그룹푸터 등 비데이터 영역도 반환
     *
     * @example
     * ```js
     * let checkedItems = gridView.getCheckedItems();
     * ```
     */
    getCheckedItems(rowOnly?: boolean): number[];
    /**
     * 체크된 데이터 행들의 목록을 반환한다.
     *
     * @param sort - 기본값: `true`, `true`: 오름차순으로 반환, `false`: 화면에 보이는 순서대로 반환.
     * @param visibleOnly - 기본값: `false`, `true`로 입력하면 collapse 되거나 페이징시 보이지 않는 행들은 제외한다.
     * @param allRows - 기본값: `false`, `true`로 입력하면 페이징 처리시 보이지 않는 페이지들의 체크된 행들도 반환한다.
     *  @example
     * ```js
     * let checkedRows = gridView.getCheckedRows();
     * ```
     */
    getCheckedRows(sort?: boolean, visibleOnly?: boolean, allRows?: boolean): number[];
    /**
     * @remarks
     * merge된 셀에 포함되는 itemIndex를 배열로 가져온다.
     *
     * @param itemIndex - 그리드 행의 itemIndex
     * @param column - column의 이름
     * @param dataOnly - 데이터행만 가져올지 여부 default `true`
     * @param force - `true`이면 merge된 셀이 아니어도 입력된 itemIndex를 포함하는 배열로 return default `true`
     *
     * @returns merge된 셀의 itemIndex 배열
     *
     * @example
     * ```js
     * let mergeItems = gridView.getMergedItems(1, "column", true, true);
     * let mergeDataRows = gridView.getRowsOfItems(mergeItems);
     * ```
     */
    getMergedItems(itemIndex: number, column: string, dataOnly?: boolean, force?: boolean): number[];


}

/**
 * @public
 * 사용자 지정의 groupFooter spanning을 설정하기 위한 콜백
 *
 * @remarks
 * {@link CellLayoutColumnItem} 에서 사용된다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨트롤
 *
 * `layout` - 레이아웃 아이템
 *
 * `itemIndex` - 행의 인덱스
 *
 * `footerIndex` - groupFooter의 index
 *
 */
export declare type GroupFooterCellSpanCallback = (grid: GridBase, layout: CellLayoutColumnItem, itemIndex: number, footerIndex: number) => number;

/**
 * 그리드 그룹 푸터 행의 스타일을 지정하기 위한 콜백
 *
 * @remarks
 * {@link RowGroupFooter.styleCallback}에서 사용되는 형식이다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨트롤
 *
 * `itemIndex` - 푸터의 itemIndex
 *
 * `footerIndex` - 그룹에 푸터가 여러개 있는 경우 footer의 index
 *
 * @example
 * ```js
 * var f = function(grid, itemIndex, footerIndex) {
 *     var dataRow = grid.getGroupModel(itemIndex, true).firstDataItem.dataRow;
 *     var value = grid.getDataSource().getValue(dataRow, "area2name");
 *     return value && value.indexOf("군") >= 0 ? `style-1-${footerIndex}` : undefined;
 * };
 *
 * gridView.rowGroup.setFooters([{styleCallback: f},{styleCallback: f}]);
 * ```
 */
export declare type GroupFooterStyleCallback = (grid: GridBase, itemIndex: number, footerIndex: number) => string;

/**
 * @public
 * 사용자 지정 groupFooterUser span을 설정하기 위한 콜백
 *
 * @remarks
 * {@link CellLayoutColumnItem} 에서 사용된다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨트롤
 *
 * `layout` - 레이아웃 아이템
 *
 * `model` - GroupModel
 *
 * `itemIndex` - 행의 인덱스
 *
 * `footerIndex` - groupFooter의 index
 */
export declare type GroupFooterUserSpanCallback = (grid: GridBase, layout: CellLayoutColumnItem, model: GroupItem, itemIndex: number, footerIndex: number) => UserSpan;

/**
 * 행 그룹핑에 관련된 설정 모델
 *
 * @remarks
 * 행 그룹핑은 데이터 행들을 하나 이상의 지정한 컬럼의 값을 기준으로 구분 시켜 계층적인 구조로 표시한다.
 *
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setGroupingOptions({prompt: "I am Groop"});
 * ```
 */
export declare interface GroupingOptions {
    /**
     * 그룹핑 활성화 여부
     */
    enabled?: boolean;
    /**
     * 패널에 표시될 메시지
     *
     * @defaultValue `'컬럼 헤더를 이 곳으로 끌어다 놓으면 그 컬럼으로 그룹핑합니다.'`
     */
    prompt?: string;
    /**
     * 그룹핑 시 그룹의 펼침 여부
     *
     * @defaultValue `true`
     */
    expandWhenGrouping?: boolean;

    /**
     * 그룹핑 전 커밋 여부
     *
     * @defaultValue `true`
     */
    commitBeforeGrouping?: boolean;
    /**
     * 그룹 펼치기 전 커밋 여부
     *
     * @defaultValue `true`
     */
    commitBeforeExpand?: boolean;
    /**
     * 그룹 접기 전 커밋 여부
     *
     * @defaultValue `true`
     */
    commitBeforeCollapse?: boolean;

    /**
     * toast 관련 설정
     *
     * @defaultValue `{visible: false, message: "Grouping..."}`
     */
    toast?: ToastOptions;
}

/**
 * @public
 * 그룹 아이템의 정보 모델
 *
 * [상위 클래스]
 *
 * {@link GridItem}
 *
 * 콜백의 파라메터로 전달될때만 사용된다.
 */
export declare interface GroupItem extends GridItem {
    /**
     * 자손 dataRow의 건수
     */
    descendantCount?: number;
    /**
     * footer의 건수
     */
    footerCount?: number;
    /**
     * 마지막 데이터 아이템
     */
    lastDataItem?: GridItem;
    /**
     * 그룹에 속해있는 데이터 아이템의 dataRow 배열
     */
    getRows(): number[];
    /**
     * 그룹에 속해있는 데이터의 건수
     *
     * @param field - 필드명 또는 필드 인덱스
     */
    getNumber(field: number | string): number;
    /**
     * 필드의 dataType이 number인 경우 값의 합계
     *
     * @param field - 필드명 또는 필드 인덱스
     */
    getSum(field: number | string): number;
    /**
     *
     * @param field - 필드명 또는 필드 인덱스
     */
    getMax(field: number | string): any;
    /**
     *
     * @param field - 필드명 또는 필드 인덱스
     */
    getMin(field: number | string): any;
    /**
     *
     * @param field - 필드명 또는 필드 인덱스
     */
    getAvg(field: number | string): number;
    /**
     *
     * @param field - 필드명 또는 필드 인덱스
     */
    getVar(field: number | string): number;
    /**
     *
     * @param field - 필드명 또는 필드 인덱스
     */
    getStdev(field: number | string): number;
    /**
     *
     * @param field - 필드명 또는 필드 인덱스
     */
    getStdevp(field: number | string): number;
    /**
     * 값이 없는 행을 제외한 숫자
     *
     * @param field - 필드명 또는 필드 인덱스
     */
    getDataCount(field: number | string): number;
    /**
     * 입력된 필드의 dataType이 `number`인 경우 값이 없는 행을 제외한 나머지 행들의 평균
     *
     * @param field - 필드명 또는 필드 인덱스
     */
    getDataAvg(field: number | string): number;
}

/**
 * @public
 * 설정된 레이아웃이 {@link CellLayoutGroupItem} 모델일 경우, {@link GridBase.saveColumnLayout} 에서 반환되는 오브젝트
 *
 * @remarks
 * {@link LayoutInfo} 의 한 종류이다.
 *
 * @example
 * ```js
 * {
 *    name: "countryGroup"
 *    items: [
 *        {column: "Country", visible: true, width: 100},
 *        {column: "Phone", visible: true, width: 100}
 *    ]
 *    visible: true,
 *    direction: "horizontal",
 *    width: 250,
 *    header: {visible: true, text: "Country Group"}
 * }
 * ```
 */
export declare interface GroupLayoutInfo {
    /**
     * layout 명
     */
    name: string;
    /**
     * 하위 layout 들
     */
    items: (ColumnLayoutInfo | GroupLayoutInfo)[];
    /**
     * 표시 여부
     */
    visible: boolean;
    /**
     * layout 배치 방향
     */
    direction: ColumnLayoutDirection;
    /**
     * 셀 너비
     */
    width: number;
    /**
     * 헤더 레이아웃 정보
     *
     * @remarks
     * [속성 목록]
     *
     * `visible` - 표시 여부
     *
     * `text` - 헤더 텍스트
     */
    header: {
        visible: boolean;
        text: string;
    };
}

/**
 * 그리드 Group Panel 표시 정보들에 대한 설정 정보
 *
 * @remarks
 * {@link GridView.setGroupPanel} 사용 시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setGroupPanel({visible: false});
 * ```
 */
export declare interface GroupPanel {
    /**
     * Group Panel 의 표시 여부
     */
    visible?: boolean;
    /**
     * Group Panel 의 최소 높이
     */
    minHeight?: number;
    /**
     * Group Panel 의 높이
     *
     * @readonly
     */
    height?: number;
}

/**
 * @public
 *
 * 그룹컬럼을 접거나 펼쳤을때 보여질것인가를 결정한다.
 *
 * {@link CellLayoutItem.groupShowMode}에서 설정한다.
 *
 * @remarks
 * 상위 layout의 expand상태에 따라서 보이거나 숨도록 한다.
 */
export declare enum GroupShowMode {
    /**
     * 그룹을 펼쳤을때 보여진다.
     */
    "EXPAND" = "expand",
    /**
     * 그룹을 접었을때 보여진다.
     */
    "COLLAPSE" = "collapse",
    /**
     * 항상 보여진다.
     */
    "ALWAYS" = "always"
}

/**
 * @public
 *
 * {@link GridBase.getGroupSummary} 에서 반환되는 오브젝트 형식
 *
 * @remarks
 * `getGroupSummary` 에 `statistical` 을 `true` 로 하면, `var`, `varp`, `stdev`, `stdevp` 가 추가된다.
 */
export declare interface GroupSummary {
    /**
     * 행 갯수
     */
    count: number;
    /**
     * 합
     */
    sum: number;
    /**
     * 최대값
     */
    max: number;
    /**
     * 최소값
     */
    min: number;
    /**
     * 평균
     */
    avg: number;
    /**
     * 값이 지정되어 잇는 데이터 개수 (null 이 아닌)
     */
    datacount: number;
    /**
     * `datacount` 로 나눈 평균
     */
    dataavg: number;
    /**
     * 표본집단 분산
     */
    var?: number;
    /**
     * 모집단 분산
     */
    varp?: number;
    /**
     * 표본집단 표준편차
     */
    stdev?: number;
    /**
     * 모집단 표준편차
     */
    stdevp?: number;
}

/**
 * @public
 *
 * 핸들의 표시 방법
 *
 * @remarks
 * 소팅(sorting), 필터링(filtering) 시 컬럼 헤더에 표시되는 기능 아이콘을 핸들(Handle)이라고 한다.
 *
 * HandleVisiblity는 {@link SortingOptions }, {@link FilteringOptions } 의 handleVisibility 속성으로 구현되어 있다.
 *
 * @example
 *
 * ```js
 * grid.sortingOptions.handleVisibility = 'visible';
 * ```
 */
export declare enum HandleVisibility {
    /**
     * 표시
     */
    VISIBLE = "visible",
    /**
     * 호버링 된 경우만 표시
     */
    HOVERED = "hovered",
    /**
     * 항상 표시
     */
    ALWAYS = "always",
    /**
     * 숨김
     */
    HIDDEN = "hidden"
}

/**
 * 행 그룹 Header에 표시되는 Text를 return 하는 Callback
 * @remarks
 * {@link RowGroup.headerCallback} 에서 사용되는 형식이다.
 * {@link RowGroup.headerStatement}가 있는 경우 무시된다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨트롤
 *
 * `group` - 그룹 아이템
 *
 *
 * @example
 * ```js
 * gridView.rowGroup.headerStatement = undefined;
 * gridView.rowGroup.headerCallback = function(grid, group) {
 *      var ds = grid.getDataSource()
 *      if (group.level === 1) {
 *          return ds.getOrgFieldName(group.groupField) + " - " + group.firstDataItem.getData(group.groupField) + " - " + group.descendantCount + " rows"
 *      } else if (group.level === 2) {
 *          var sum = group.getSum("number");
 *          return isNaN(sum) ? "합계 없음" : ("합계 => "+ sum.toString());
 *      } else {
 *          return "GroupLevel => "+group.level.toString()
 *      }
 * 	}
 * ```
 */
export declare type HeaderCallback = (grid: GridView, group: GroupItem) => string;

/**
 * @public
 *
 * Header Summary 영역의 단일 설정 모델
 *
 * @remarks
 * 그리드는 별도의 설정이 없는 경우 하나의 summary를 자동으로 생성하고 {@link GridBase.headerSummary}는 첫번째 summary를 반환한다..
 *
 * {@link GridBase.setHeaderSummary | setHeaderSummary()}를 이용해서 속성을 변경하거나 또는 {@link GridBase.headerSummary}를 이용해서 원하는 속성만 지정한다.
 *
 * @example
 *
 * ```js
 * gridView.setHeaderSummary({styleName: 'custom-hsummary-1'});
 * // 또는
 * gridView.headerSummary.styleName = 'custom-hsummary-1';
 * ```
 */
export declare interface HeaderSummary extends GridSummaryObject {
    /**
     * 스타일 클래스 이름
     */
    styleName?: string;
    /**
     * 최소 높이
     *
     * @defaultValue `23`
     */
    minHeight?: number;
    /**
     * 높이
     *
     * @remarks
     * `0`이면 자동으로 계산하여 지정한다. `0` 이상이면 minHeight와 비교하여 더 큰 값으로 지정한다.
     *
     * @defaultValue `0`
     */
    height?: number;
    /**
     * 셀 스타일을 지정하기 위한 콜백
     * @eventProperty
     *
     * @remarks
     * `string` 형태의 css 클래스 명 또는 {@link ColumnSummaryStyleObject} 형태로 지정가능하다.
     *
     * @example
     * ```js
     * // 푸터 적용
     * const f = function (grid, cell) {
     *      if (cell.value > 10) {
     *          return {
     *              styleName: 'custom-summary'
     *          }
     *      }
     * }
     * headerSummary.cellStyleCallback = f;
     * ```
     */
    cellStyleCallback?: CellStyleCallback;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * summary 콜렉션 내에서의 순서
     *
     * @readonly
     */
    summaryIndex?: number;
}

/**
 * @public
 *
 * Header summary 영역에 관한 콜렉션 모델 오브젝트
 *
 * @remarks
 *
 * 그리드의 headerSummary를 표시하거나 여러개의 headerSummary를 생성하고 관리한다.
 *
 * {@link GridBase.headerSummaries} 에서 반환되는 객체다.
 *
 * @example
 * ```js
 * // object
 * gridView.setHeaderSummaries({
 *      visible: true,
 *      items:[
 *          {
 *              styleName: 'custom-headerSummary-1'
 *          }, {
 *              styleName: 'custom-headerSummary-2'
 *          }
 *      ]
 * })
 * // 또는 array형태로 지정
 * gridView.setFooters([
 *      {
 *          styleName: 'custom-headerSummary-1'
 *      }, {
 *          styleName: 'custom-headerSummary-2'
 *      }
 * ])
 * ```
 */
export declare interface HeaderSummaryCollection {
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * 현재 설정된 headerSummary의 갯수를 반환한다.
     *
     * @readonly
     */
    readonly count?: number;
    /**
     * 현재 설정된 headerSummary중 visible이 `true`인 headerSummary의 갯수를 반환한다.
     *
     * @readonly
     */
    readonly visibleCount?: number;
    /**
     * headerSummary를 설정한다.
     */
    items?: HeaderSummary[];
    /**
     * 해당하는 인덱스의 headerSummary를 반환한다.
     *
     * @remarks
     * {@link HeaderSummary}를 반환한다.
     *
     * @param index - headerSummary의 index
     */
    readonly get?: (index: number) => HeaderSummary;
    /**
     * 보여지는 순서에 해당하는 headerSummary를 가져온다.
     *
     * @remarks
     * {@link HeaderSummary}를 반환한다.
     *
     * @param index - 보여지는 순서 `0`부터 시작한다.
     */
    readonly getVisible?: (index: number) => HeaderSummary;
}

/**
 * 공휴일 지정을 위한 설정 모델
 *
 * @remarks
 * {@link GridBase.setEditorOptions} 을 이용하여 지정하거나 {@link EditorOptions.holidays | grid.editorOptions.holidays} 에 직접 지정할 때 사용된다.
 *
 * {@link DateCellEditor} 에서 사용되기도 한다.
 *
 * @example
 * ```js
 * holidays: [
 *      {
 *          type : "date",
 *          dates : ["2020-01-24","2020-01-25","2020-01-26","2020-01-27"],
 *          styleName: "seollal",
 *          tooltips : ["설날1","설날2","설날3","설날4"]
 *      },
 *   ...
 * ]
 * ```
 */
export declare type Holidays = (DateHoliday | DayHoliday)[];

/**
 * @public
 *
 * 아이콘 렌더러
 *
 * @remarks
 * 이미지 아이콘과 텍스트를 같이 표시한다.
 *
 * url을 직접 지정하여 표시할 수도 있다.
 *
 * {@link CellRenderer} 를 상속한다.
 *
 * [제한 사항]
 *
 * 1. iconLocation = RIGHT: 텍스트가 길면 아이콘이 표시되지 않을 수 있다.
 *
 * 2. 자동 높이에서 `TOP_EDGE`, `BOTTOM_EDGE`를 사용할 수 없다.
 *
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'icon';
 *
 * // object type
 * column.renderer = {
 *     "type": "icon",
 *     "iconMap": {
 *         "UPQRK": "images/particles/uquark.png",
 *         "DOWNQRK": "images/particles/dquark.png",
 *         "ELECTRN": "images/particles/e.png",
 *         "ELECNEU": "images/particles/eneutrino.png",
 *     },
 *     "iconHeight": 11
 * },
 * ```
 */
export declare interface IconCellRenderer extends CellRenderer {
    /**
     * 셀 값과 해당 셀 값에 대응시킬 url 의 키-값 쌍
     *
     * @remarks
     * {@link IconCellRenderer.iconCallback} 이 할당되어 있지 않거나 `undefined`를 반환한 경우 적용된다.
     *
     *
     * @example
     * ```js
     * column.renderer = {
     *      type: 'icon'
     *      iconMap: {
     *          value1: 'images/e_equals_mc_square.jpg'
     *      }
     * }
     * ```
     */
    iconMap?: {
        [value: string]: string;
    };
    /**
     * 아이콘 이미지의 렌더링을 위한 콜백
     *
     * @remarks
     * `undefined` 반환 시 해당 콜백에 의한 렌더링이 취소된다.
     *
     * {@link GetImageCallback} 의 형식을 따른다.
     * @eventProperty
     *
     * @example
     *
     * ```js
     * column.renderer = {
     *      "type": "icon",
     *      "iconCallback": function (grid, cell) {
     *          return "images/teraforming/mars.jpg";
     *      }
     * }
     * ```
     */
    iconCallback?: GetImageCallback;
    /**
     * 이미지의 alt 텍스트를 설정하기 위한 콜백
     *
     * @remarks
     * 설정할 alt 텍스트를 반환해야 한다.
     *
     * {@link GetCellTitleCallback} 의 형식을 따른다.
     * @eventProperty
     *
     * @example
     * ```js
     * const f = function(grid, model) {
     *      return 'cat image'
     * }
     * column.renderer = {
     *      type: 'icon',
     *      titleCallback: f
     * }
     * ```
     */
    titleCallback?: GetCellTitleCallback;
    /**
     * 보여줄 아이콘 이미지의 url
     *
     * @remarks
     * {@link IconCellRenderer.iconMap} 이 설정된 경우, 해당 설정된 값은 무시된다.
     */
    iconUrl?: string;
    /**
     * 아이콘 이미지 렌더링을 위해 url 값으로 읽어올 필드의 필드명
     *
     * @remarks
     * {@link IconCellRenderer.iconCallback} 이 할당되어 있지 않거나 `undefined`를 반환한 경우 적용된다.
     *
     * @example
     * ```js
     * column.renderer = {
     *      "type": "icon",
     *      "iconField": "Cats"
     * }
     * ```
     */
    iconField?: string;
    /**
     * 렌더링되는 아이콘의 위치
     */
    iconLocation?: IconLocation;
    /**
     * true이면 스페이스바를 입력했을때 onCellItemClicked 가 실행된다.
     *
     * @defaultValue `false`
     */
    spaceKey?: boolean;
    /**
     * true이면 enterKey를 입력했을때 onCellItemClicked 가 실행된다.
     *
     * @defaultValue `false`
     */
    enterKey?: boolean;
    /**
     * true이면 excel로 이미지를 export한다.
     *
     * @remarks
     * {@link GridExportOptions.exportImage}가 `false`이면 출력되지 않는다.
     *
     * @defaultValue `undefined`
     */
    exportImage?: boolean;
}

/**
 * @public
 *
 * 렌더링하는 아이콘, 체크박스, 도형 등의 위치
 *
 * @remarks
 * {@link IconCellRenderer}, {@link CheckCellRenderer}, {@link ShapeCellRenderer} 에서 사용된다.
 *
 * @example
 * ```js
 * ...
 * "renderer": {
 *          "type": "check",
 *          "checkLocation": "right"
 *      },
 * ...
 * ```
 */
export declare enum IconLocation {
    /**
     * 텍스트 왼쪽에 표시
     */
    LEFT = "left",
    /**
     * 텍스트 오른쪽에 표시
     */
    RIGHT = "right",
    /**
     * 셀 왼쪽 모서리에 표시
     */
    LEFT_EDGE = "leftEdge",
    /**
     * 셀 오른쪽 모서리에 표시
     */
    RIGHT_EDGE = "rightEdge",
    /**
     * 텍스트 위쪽에 표시
     */
    TOP = "top",
    /**
     * 텍스트 아래쪽에 표시
     */
    BOTTOM = "bottom",
    /**
     * 셀 위쪽 모서리에 표시
     */
    TOP_EDGE = "topEdge",
    /**
     * 셀 아래쪽 모서리에 표시
     */
    BOTTOM_EDGE = "bottomEdge",
    /**
     * 셀 중앙에 표시
     */
    CENTER = "center"
}

/**
 * @public
 *
 * 이미지 렌더러
 *
 * @remarks
 * 데이터 셀의 값을 url 로 해석해서 그 이미지를 내려받고 표시한다.
 *
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 *
 * ```js
 * // string type
 * column.renderer = 'image';
 *
 * // object type
 * column.renderer = {
 *      type: "image",
 *      imageMap: {
 *          "value1": "images/apple.jpg",
 *          "value2": "images/banana.jpg"
 *      },
 *      titleField: "fruits"
 * }
 * ```
 */
export declare interface ImageCellRenderer extends CellRenderer {
    /**
     * 셀 값과 해당 셀 값에 대응시킬 url 의 키-값 쌍
     *
     * @remarks
     * {@link ImageCellRenderer.imageCallback} 이 할당되어 있지 않거나 `undefined`를 반환한 경우 적용된다.
     *
     *
     * @example
     * ```js
     * column.renderer = {
     *      type: 'image',
     *      imageMap: {
     *          value1: 'images/e_equals_mc_square.jpg'
     *      }
     * }
     * ```
     */
    imageMap?: {
        [value: string]: string;
    };
    /**
     * 이미지를 렌더링을 위해 이미지의 경로를 지정하는 콜백
     *
     * @remarks
     * `false` 반환 시 해당 콜백에 의한 렌더링이 취소된다.
     *
     * {@link GetImageCallback} 의 형식을 따른다.
     *
     * [프로퍼티 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `model` - 그리드의 셀
     *
     * @eventProperty
     * @example
     * ```js
     * const f = function(grid, model) {
     *      const base = '/images/';
     *      if (jpgSet.indexOf(model.value)){
     *          return base + model.value + '.jpg';
     *      }
     *      else base + 'default.jpg';
     * }
     *
     * column.renderer = {
     *      type: 'image',
     *      imageCallback: f
     * }
     * ```
     */
    imageCallback?: GetImageCallback;
    /**
     * 이미지 렌더링을 위해 url 값으로 읽어올 필드의 필드명
     *
     * @remarks
     * {@link ImageCellRenderer.imageCallback} 이 할당되어 있지 않거나 `undefined`를 반환한 경우 적용된다.
     *
     * @example
     *
     * ```js
     * column.renderer = {
     *      "type": "image",
     *      "imageField": "Cats"
     * }
     * ```
     */
    imageField?: string;
    /**
     * 이미지의 alt 텍스트 값으로 읽어올 필드의 필드명
     *
     * @example
     * ```js
     * column.renderer = {
     *      "type": "image",
     *      "imageMap": {
     *          "value1": "images/fatcat.jpg",
     *          "value2": "images/bluecat.jpg"
     *      },
     *      "titleField": "CatName"
     * }
     * ```
     */
    titleField?: string;
    /**
     * 이미지의 alt 텍스트를 설정하기 위한 콜백
     *
     * @remarks
     * 설정할 alt 텍스트를 반환해야 한다.
     *
     * {@link GetCellTitleCallback} 의 형식을 따른다.
     * @eventProperty
     *
     * @example
     * ```js
     * const f = function(grid, model) {
     *      return 'cat image'
     * }
     * column.renderer = {
     *      type: 'image',
     *      imageMap: {
     *          value1: 'images/fatcat.jpg',
     *          value2: 'images/bluecat.jpg'
     *      },
     *      titleCallback: f
     * }
     * ```
     */
    titleCallback?: GetCellTitleCallback;
    /**
     * 이미지 높이
     */
    imageHeight?: number;
    /**
     * true이면 스페이스바를 입력했을때 onCellItemClicked가 실행된다.
     *
     * @defaultValue `false`
     */
    spaceKey?: boolean;
    /**
     * true이면 enterKey를 입력했을때 onCellItemClicked가 실행된다.
     *
     * @defaultValue `false`
     */
    enterKey?: boolean;
    /**
     * true이면 excel로 이미지를 export한다.
     *
     * @remarks
     * {@link GridExportOptions.exportImage}가 `false`이면 출력되지 않는다.
     *
     * @defaultValue `undefined`
     */
    exportImage?: boolean;
}

/**
 * @public
 *
 * 인디케이터에 표시될 내용 종류
 */
export declare enum IndicatorValue {
    /**
     * 없음
     */
    NONE = "none",
    /**
     * 행 순서
     */
    INDEX = "index",
    /**
     * 행 순서를 역순으로 표시
     */
    REVERSE = "reverse",
    /**
     * 행 고유 번호
     */
    ROW = "row"
}

/**
 * @public
 *
 * {@link FilterPanel}에서 사용할수 있는 연산자의 종류이다.
 *
 * @remarks
 * {@link DataColumn.valueType}에 따라서 사용할수 있는 연산자에 제한이 있다.
 */
export declare enum InlineFilterOperator {
    /**
     * 입력된 값과 동일한 Data
     */
    EQUAL = "equal",
    /**
     * 입력된 값과 다른 Data
     */
    NOT_EQUAL = "notEqual",
    /**
     * 입력된 값을 포함하고 있는 Data
     */
    CONTAINS = "contains",
    /**
     * 입력된 값을 포함하고 있지 않은 Data
     */
    NOT_CONTAINS = "notContains",
    /**
     * 입력된 값으로 시작하는 Data
     */
    STARTS_WITH = "startsWith",
    /**
     * 입력된 값으로 끝나는 Data
     */
    ENDS_WITH = "endsWith",
    /**
     * 입력된 값을 지우고 filter를 비활성화 시킨다.
     */
    RESET = "reset",
    /**
     * 입력된 값보다 큰 Data
     */
    GREATER = "greater",
    /**
     * 입력된 값보다 크거나 같은 Data
     */
    GREATER_EQUAL = "greaterEqual",
    /**
     * 입력된 값보다 작은 Data
     */
    LOWER = "lower",
    /**
     * 입력된 값보다 작거나 같은 Data
     */
    LOWER_EQUAL = "lowerEqual",
    /**
     * 범위를 지정한다.
     *
     * @remarks
     * `~`를 구분자로 해서 `value1 ~ value2`와 같은 형태로 지정한다.
     */
    BETWEEN = "between",
    /**
     * 값이 없는 Data를 검색
     */
    EMPTY = "empty"
}

/**
 * @public
 *
 * {@link GridBase.getInvalidCells} 에서 반환되는 오브젝트 형식
 */
export declare interface InvalidCell {
    /**
     * 컬럼 명
     */
    column: string;
    /**
     * 행의 고유 번호
     */
    dataRow: number;
    /**
     * 설정한 메시지
     */
    message: string;
    /**
     * 설정한 데이터 검증 결과 수준
     */
    level: ValidationLevel;
    /**
     * 필드 명
     */
    fieldName: string;
}

/**
 * @public
 *
 * 아이템의 상태
 */
export declare enum ItemState {
    /**
     * 편집, 추가, 입력 중이 아닌 경우
     */
    NORMAL = "normal",
    /**
     * 입력된 인덱스가 현재 편집 중인 아이템의 인덱스인 경우
     */
    FOCUSED = "focused",
    /**
     * 편집 중인 경우
     */
    UPDATING = "updating",
    /**
     * 삽입 중인 경우
     */
    INSERTING = "inserting",
    /**
     * 추가 중인 경우
     */
    APPENDING = "appending",
    /**
     * 더미
     */
    DUMMY = "dummy"
}

/**
 * @public
 *
 * 그리드에서 아이템의 종류
 *
 * @remarks
 * {@link GridBase.getModelAs | getModelAs()} 등에서 사용한다.
 *
 * @example
 * ```js
 * let model = gridView.getModelAs(3, 'row');
 * ```
 */
export declare enum ItemType {
    /**
     * 행
     */
    ROW = "row",
    /**
     * 그룹 아이템
     */
    GROUP = "group",
    /**
     * 그룹 푸터
     */
    FOOTER = "footer",
    /**
     * 트리 아이템
     */
    TREE = "tree"
}

/**
 * @public
 * {@link GridBase.saveColumnLayout} 에서 반환되는 레이아웃의 정보 모델
 *
 * @remarks
 * ```js
 * // array of LayoutInfo
 * [
 *      {column: "OrderID", visible: true, width: 80},
 *      {column: "CustomerID", visible: true, width: 90},
 *      {
 *          name: "companyGroup"
 *          items: [
 *              {
 *                  name: "countryGroup"
 *                  items: [
 *                      {column: "Country", visible: true, width: 100},
 *                      {column: "Phone", visible: true, width: 100}
 *                  ]
 *                  visible: true,
 *                  direction: "horizontal",
 *                  width: 250,
 *                  header: {visible: true, text: "Country Group"}
 *              },
 *              {column: "CompanyName", visible: true, width: 100}
 *          ]
 *          visible: true,
 *          direction: "vertical",
 *          width: 250,
 *          header: {visible: true, text: "Company Group"}
 *      },
 *      {column: "EmployeeID", visible: true, width: 90}
 * ]
 * ```
 */
export declare type LayoutInfo = ColumnLayoutInfo | GroupLayoutInfo;

/**
 * @public
 * 원하는 형태의 컬럼을 만들 수 있는 레이아웃 아이템 모델의 타입
 *
 * @remarks
 * {@link GridBase.setColumnLayout} 에서 사용된다.
 *
 * [개념 설명]
 *
 * span 은 {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td#attr-colspan | html table의 colspan} 과 비슷한 개념이다.
 *
 * span 개수와 컬럼 개수로 영역을 분할하며, `width`와 뒤의 수들을 더한 만큼 영역을 한다.
 *
 * layout 단위로 span 한다. 즉, 다음 layout이 그룹이면 그 그룹 전체를 span 한다.
 *
 * 그룹을 벗어나서 span 할 수 없다.
 *
 * 그룹은 span할 수 없다.
 *
 * 왼쪽에서 오른쪽으로, 위에서 아래로 진행한다.
 *
 * 상위 layout부터 먼저 span 한다(top-down).
 *
 * 그룹이 다음 layout들을 span 한 경우 새로 추가된 셀들을 하위 layout들에 배분한다.
 *
 * (배분 방식: 하위 layout의 cell 개수 비율에 따라 마지막 layout부터 배분한다.)
 *
 * 행 병합 상태일 경우 span  하려는 다음 layout들과 행 어긋남이 없어야 한다.
 *
 * fixed, rightFixed 경계를 넘어갈 수 없다.
 *
 * @example
 * ```js
 * [
 *        {
 *            name: "companyGroup",
 *            items: [
 *                {
 *                    column: "Country",
 *                    cellSpan: 3
 *                },
 *                20,20,
 *                {
 *                    column: "CompanyName",
 *                    cellSpan: 3
 *                },
 *                20,20,
 *            ],
 *            header: true
 *        },
 *        ...
 *    ];
 * ```
 */
export declare type LayoutItem = CellLayoutGroupItem | CellLayoutColumnItem;

/**
 * @public
 * 한 줄 입력을 받을 수 있는 텍스트 편집기
 *
 * @remarks
 * RealGrid의 기본편집기. 컬럼에 editor 속성을 지정하지 않거나 `'line'` / `'text'` 를 지정하면 LineCellEditor가 사용된다.
 * {@link TextCellEditor} 를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link CellEditor} - {@link TextCellEditor}
 *
 * @example
 * ```js
 * // string type
 * column.editor = "line"
 *
 * // object type
 * column.editor = { type: "line", maxLength: 1}
 * ```
 */
export declare interface LineCellEditor extends TextCellEditor {

    /**
     * 입력시 허용하는 문자열
     *
     * @remarks
     * 편집시 영문 또는 숫자등 특정집합만 입력가능하도록 하는 경우 허용할 문자을 입력한다.
     *
     *
     * @example
     * ```js
     * // 영문만 입력가능.
     * column.editor = {type:"line", inputCharacters:"A-Za-z"};
     *
     * // 한글만 입력가능
     * column.editor = {type:"line", inputCharacters:"ㄱ-힣"};
     * ```
     */
    inputCharacters?: string;
    /**
     * 입력시 제외하는 문자열
     *
     * @remarks
     * 편집시 특정문자는 제한하는 경우 제한할 문자열을 입력한다.
     * ```js
     * // 영문만 입력가능하고 ABCD는 입력제외 abcd는 입력가능.
     * column.editor = {type:"line", inputCharacters:"A-Za-z", ignoreCharacters:"ABCD"}
     * ```
     */
    ignoreCharacters?: string;
}

/**
 * @public
 *
 * 하이퍼링크를 표시하는 렌더러
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'link';
 *
 * // object type
 * column.renderer = {
 *     "type": "link",
 *     "urlCallback": function (grid, cell) {
 *         return "http://realgrid.com";
 *     },
 *     "titleField": "CompanyName"
 * }
 * ```
 */
export declare interface LinkCellRenderer extends CellRenderer {
    /**
     * 클릭 시 연결될 base url 주소
     *
     * @remarks
     * `linkField` 필드나 셀의 값 앞에 덧붙여 최종적인 주소를 설정한다.
     *
     * `'#'`일 경우 클릭 시 {@link GridBase.onCellItemClicked | onCellItemClicked} 가 호출된다.
     *
     * @example
     * ```js
     * column.renderer = {
     *      "type": "link",
     *      "baseUrl": "#"
     * }
     * ```
     */
    baseUrl?: string;
    /**
     * 링크의 target
     *
     * @remarks
     * 링크의 target을 지정한다 지정하지 않으면 `_blank`가 지정된다.
     *
     * @defaultValue `undefined`
     */
    target?: string;
    /**
     * 링크 될 주소가 지정되어있는 필드명
     *
     * @remarks
     * 지정되지 않으면 렌더링 되는 셀의 값이 링크 될 주소로 지정된다.
     */
    linkField?: string;
    /**
     * 스페이스바를 입력했을때 링크를 실행할 것인지의 여부
     *
     * @remarks
     * true를 입력하면 셀에 포커스가 있고 편집상태가 아닐때 스페이스 바를 입력하면 링크가 실행된다.
     * {@link GridBase.onCellItemClicked}가 있는 경우 해당 이벤트가 호출된후 결과값이 false이면 기본동작을 실행하지 않는다.
     *
     * @defaultValue `true`
     */
    spaceKey?: boolean;
    /**
     * enter를 입력했을때 링크를 실행할 것인지의 여부
     *
     * @remarks
     * true를 입력하면 셀에 포커스가 있고 편집상태가 아닐때 enter를 입력하면 링크가 실행된다.
     * {@link GridBase.onCellItemClicked}가 있는 경우 해당 이벤트가 호출된후 결과값이 false이면 기본동작을 실행하지 않는다.
     *
     * @defaultValue `true`
     */
    enterKey?: boolean;
    /**
     * 링크 될 주소를 지정하기 위한 콜백
     *
     * @remarks
     * 지정되면 `linkField`, `baseUrl` 을 무시한다.
     *
     * @eventProperty
     * @example
     * ```js
     * column.renderer = {
     *     "type": "link",
     *     "urlCallback": function (grid, cell) {
     *         return "http://realgrid.com";
     *     },
     * }
     * ```
     */
    urlCallback?: GetLinkUrlCallback;
    /**
     * HTML Anchor Element의 title 텍스트 값으로 읽어올 필드의 필드명
     *
     * @example
     * ```js
     * column.renderer = {
     *      "type": "link",
     *      "linkField": "ProductID",
     *      "titleField": "CompanyName"
     * }
     * ```
     */
    titleField?: string;
    /**
     * HTML Anchor Element의 title 텍스트를 설정하기 위한 콜백
     *
     * @remarks
     * 설정할 HTML Anchor Element의 title 텍스트를 반환해야 한다.
     *
     * {@link GetCellTitleCallback} 의 형식을 따른다.
     *
     * @eventProperty
     * @example
     *
     * ```js
     * const f = function(grid, model) {
     *      return 'new product'
     * }
     *
     * let column.renderer = {
     *      "type": "link",
     *      "urlCallback": function (grid, cell) {
     *          return "http://realgrid.com";
     *      },
     *      "titleCallback": f
     * }
     * ```
     */
    titleCallback?: GetCellTitleCallback;
    /**
     * anchor element에 class를 추가한다.
     *
     * @remarks
     * anchor element의 style을 변경하기 위한 class를 추가한다.
     *
     * {@link GetClassCallback}의 형식을 따른다.
     *
     * @eventProperty
     *
     * @example
     *
     * ```html
     * <style>
     * a.new {padding-right:25px;background:url('/images/ico_new.png') no-repeat 100% 50%;}
     * a.btn {display:inline-block;width:80px;line-height:30px;text-align:center;background-color:#222;color:#fff;overflow: hidden;}
     * </style>
     * ```
     *
     * ```js
     * const f = function(grid, model) {
     *   var cls = "";
     *   var value = model.value || "";
     *   value.indexOf("new") && (cls += " new");
     *   value.indexOf("button") && (cls += " btn");
     *
     *   return cls.trim();
     * }
     *
     * column.renderer = {
     *   type: "link",
     *   "classCallback": f
     * }
     * ```
     */
    classCallback?: GetClassCallback;
}

/**
 * @public
 * LocalDataProvider 클래스. {@link DataProviderBase} 를 상속한다.
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link DataProviderBase}
 */
export declare class LocalDataProvider extends DataProviderBase {
    /**
     * @internal
     */
    /**
     * 데이터 행의 건수가 변경되었음을 알리는 콜백
     *
     * @remarks
     * 행 추가 및 삭제 등으로 데이터 행의 개수가 변경됐을 때 호출된다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `newCount` - 변경 후 전체 데이터 행의 건수
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowCountChanged = function (provider, newCount) {
     *     console.log("DataProvider rowCount changed as: " + newCount);
     * };
     * ```
     */
    onRowCountChanged: (provider: LocalDataProvider, newCount: number) => void;
    /**
     * 데이터 행의 수정을 결정하는 콜백
     *
     * @remarks
     * 데이터 행이 수정되기 직전에 호출하여 행의 수정 여부를 확인한다. 행의 수정이 완료된 후 {@link LocalDataProvider.onRowUpdated | onRowUpdated}가 발생한다.
     *
     * 이벤트에 함수가 바인딩되지 않은 경우 기본으로 `true`를 반환한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 변경된 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `true`면 행의 수정을 완료하고 `false`면 행의 수정을 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowUpdating = function (provider, row) {
     *      if(row % 2 === 0) {
     *          console.log("DataProvider row updated: " + row);
     *          return true;
     *      }
     *      return false;
     * };
     * ```
     */
    onRowUpdating: (provider: LocalDataProvider, row: number) => boolean;
    /**
     * 데이터 행이 수정되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowUpdating | onRowUpdating} 에서 `true`가 반환되었을 때 수정이 완료된 후에 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 변경된 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowUpdated = function (provider, row) {
     *      console.log("DataProvider row updated: " + row);
     * };
     * ```
     */
    onRowUpdated: (provider: LocalDataProvider, row: number) => void;
    /**
     * 다수의 데이터 행이 일괄 수정되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.updateRows | updateRows } 등의 함수에서 이벤트 일괄 반영되도록 했을 때 발생한다.
     * @eventProperty
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 변경된 시작 데이터 행의 인덱스
     *
     * `count` - 변경된 행의 건수
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsUpdated = function (provider, row, count) {
     *      console.log("DataProvider rows updated from " + row + 'to' + (count + row));
     * };
     * ```
     */
    onRowsUpdated: (provider: LocalDataProvider, row: number, count: number) => void;
    /**
     * 다수의 데이터 행이 변경되었음을 알리는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 변경된 데이터 행들의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowListUpdated = function (provider, rows) {
     *      console.log("DataProvider rows updated: " + rows.join(', '));
     * };
     * ```
     */
    onRowListUpdated: (provider: LocalDataProvider, rows: number[]) => void;
    /**
     * 데이터 행 추가를 결정하는 콜백
     *
     * @remarks
     * 데이터 행이 추가되기 직전에 호출하여 행의 추가 여부를 확인한다. 행의 수정이 완료된 후 {@link LocalDataProvider.onRowInserted | onRowInserted }가 발생한다.
     *
     * 이벤트에 함수가 바인딩되지 않은 경우 기본으로 `true`를 반환한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 추가될 데이터 행의 인덱스
     *
     * `values` - 추가될 데이터 값, {@link DataValues} 형식
     *
     * @defaultValue `null`
     * [반환값] - `true`이면 행의 추가를 완료하고 `false`이면 행의 추가를 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowInserting = function (provider, row, values) {
     *      if (row > 100) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowInserting: (provider: LocalDataProvider, row: number, values: DataValues) => boolean;
    /**
     * 데이터 행이 추가되었을을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowInserting | onRowInserting} 콜백에서 `true`가 반환되어 행이 추가된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 추가된 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowInserted = function (provider, row) {
     *      console.log("DataProvider row inserted!");
     * };
     * ```
     */
    onRowInserted: (provider: LocalDataProvider, row: number) => void;
    /**
     * 다수의 데이터 행이 일괄 추가되었을 때 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.insertRows} 등의 함수에서 이벤트 일괄 반영되도록 했을 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 변경된 시작 데이터 행의 인덱스
     *
     * `count` - 변경된 행의 건수
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowsInserted = function (provider, row, count) {
     *      console.log("DataProvider " + count + " rows inserted!");
     * };
     * ```
     */
    onRowsInserted: (provider: LocalDataProvider, row: number, count: number) => void;
    /**
     * 데이터 행의 삭제를 결정하는 콜백
     *
     * @remarks
     * 데이터 행이 삭제되기 직전에 호출하여 행의 삭제 여부를 확인한다. 행의 삭제가 완료된 후 {@link LocalDataProvider.onRowDeleted | onRowDeleted} 가 발생한다.
     *
     * 이벤트에 함수가 바인딩되지 않은 경우 기본으로 `true`를 반환한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 추가될 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `true`이면 행의 삭제를 완료하고 `false`이면 행의 삭제를 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowDeleting = function (provider, row) {
     *      if (row < 100) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowDeleting: (provider: LocalDataProvider, row: number) => boolean;
    /**
     * 데이터 행이 삭제되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowDeleting | onRowDeleting} 콜백 함수에서 `true`가 반환되어 행이 추가된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 삭제된 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowDeleted = function (provider, row) {
     *      console.log('dataProvider row deleted: ' + row);
     * };
     * ```
     */
    onRowDeleted: (provider: LocalDataProvider, row: number) => void;
    /**
     * 데이터 행이 삭제되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowDeleting | onRowDeleting} 콜백 함수에서 `true`가 반환되어 행이 추가된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 삭제된 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowsDeleted = function (provider, rows) {
     *      console.log('DataProvider rows deleted: ' + rows.join(', '));
     * };
     * ```
     */
    onRowsDeleted: (provider: LocalDataProvider, rows: number[]) => void;
    /**
     * 데이터 행의 이동을 결정하는 콜백
     *
     * @remarks
     * 데이터 행이 이동 되기 직전에 호출하여 행의 이동 여부를 결정한다. 행의 이동이 완료된 후 {@link LocalDataProvider.onRowMoved | onRowMoved} 가 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 데이터 행의 원래의 인덱스
     *
     * `newRow` - 데이터 행의 이동후의 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `true`이면 행의 이동을 완료하고 `false`이면 행의 이동을 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowMoving = function (provider, row, newRow) {
     *      if (row < newRow) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowMoving: (provider: LocalDataProvider, row: number, newRow: number) => boolean;
    /**
     * 데이터 행이 이동되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowMoving | onRowMoving } 콜백 함수에서 `true`가 반환되어 행이 이동된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 데이터 행의 원래의 인덱스
     *
     * `newRow` - 데이터 행의 이동후의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowMoved = function (provider, row, newRow) {
     *      console.log('DataProvider row moved from ' + row + ' to ' + newRow);
     * };
     * ```
     */
    onRowMoved: (provider: LocalDataProvider, row: number, newRow: number) => void;
    /**
     * 복수의 데이터 행의 이동을 결정하는 콜백
     *
     * @remarks
     * 복수의 데이터 행이 이동 되기 직전에 호출하여 행의 이동 여부를 결정한다.행들의 이동이 완료된 후 {@link LocalDataProvider.onRowsMoved | onRowsMoved} 가 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 첫 데이터 행의 원래의 인덱스
     *
     * `count` - 이동할 데이터 행의 건수
     *
     * `newRow` - 첫 데이터 행의 이동 후의 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `true`이면 행들의 이동을 완료하고 `false`이면 행들의 이동을 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowsMoving = function (provider, row, count, newRow) {
     *      if (row < newRow || count > 20) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowsMoving: (provider: LocalDataProvider, row: number, count: number, newRow: number) => boolean;
    /**
     * 복수의 데이터 행이 이동되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowsMoving | onRowsMoving} 콜백 함수에서 `true`가 반환되어 행들이 이동된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 첫 데이터 행의 원래의 인덱스
     *
     * `count` - 이동할 데이터 행의 건수
     *
     * `newRow` - 첫 데이터 행의 이동후의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowsMoved = function (provider, row, count, newRow) {
     *      console.log('DataProvider ' + count + ' rows moved!');
     * };
     * ```
     */
    onRowsMoved: (provider: LocalDataProvider, row: number, count: number, newRow: number) => void;
    /**
     * 마우스를 이용한 행의 이동을 결정하는 콜백
     *
     * @remarks
     * 복수의 데이터 행이 이동 되기 직전에 호출하여 행의 이동 여부를 결정한다.행들의 이동이 완료된 후 {@link LocalDataProvider.onRowListMoved | onRowListMoved} 가 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 이동되는 행 인덱스의 배열
     *
     * `newRow` - 첫 데이터 행의 이동 후의 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `true`이면 행들의 이동을 완료하고 `false`이면 행들의 이동을 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowListMoving = function (provider, rows, newRow) {
     *      return rows.length === 1)
     * };
     * ```
     */
    onRowListMoving: (provider: LocalDataProvider, rows: number[], newRow: number) => boolean;
    /**
     * 복수의 데이터 행이 이동되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowListMoving | onRowListMoving} 콜백 함수에서 `true`가 반환되어 행들이 이동된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 이동된 행 인덱스의 배열
     *
     * `newRow` - 첫 데이터 행의 이동후의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowListMoved = function (provider, rows, newRow) {
     *      console.log('DataProvider ' + rows.length + ' rows moved!');
     * };
     * ```
     */
    onRowListMoved: (provider: LocalDataProvider, rows: number[], newRow: number) => void;
    /**
     * 데이터 셀의 값이 변경되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.setValue | setValue()} 를 이용하여 데이터를 변경할 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 값이 변경된 행의 인덱스
     *
     * `field` - 값이 변경된 필드의 인덱스
     *
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onValueChanged = function (provider, row, field) {
     *      console.log('DataProvider row Value changed at ' + row + ' on ' + field);
     * };
     * ```
     */
    onValueChanged: (provider: LocalDataProvider, row: number, field: number) => void;
    /**
     * 데이터 셋의 값이 변경되었었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.setValue | setValue()} 함수나 View에서의 입력으로 값이 바뀔 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * @eventProperty
     * @example
     * ```js
     * dataProvider.onDataChanged = function (provider) {
     *      console.log('dataChanged!');
     * };
     * ```
     */
    onDataChanged: (provider: LocalDataProvider) => void;
    /**
     * 데이터 행의 상태가 변경되었음을 알리는 콜백
     *
     * @remarks
     * 데이터행의 상태가 변경되는 경우 발생, 단 행 추가시에는 상태가 변경되었다 할 수 없으므로 예외로 한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 상태가 변경된 데이터 행의 인덱스
     *
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowStateChanged = function (provider, row) {
     *      console.log('dataProvider row state changed: ' + row);
     * };
     * ```
     */
    onRowStateChanged: (provider: LocalDataProvider, row: number) => void;
    /**
     * 복수의 데이터 행의 상태가 일괄 변경되었음을 알리는 콜백
     *
     * @remarks
     * 복수의 데이터행의 상태가 일괄 변경되는 경우 발생, 단 행 추가시에는 상태가 변경되었다 할 수 없으므로 예외로 한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 상태가 변경된 데이터 행들의 인덱스 배열
     *
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowStatesChanged = function (provider, rows) {
     *      console.log('dataProvider row state changed: ' + rows.join(','));
     * };
     * ```
     */
    onRowStatesChanged: (provider: LocalDataProvider, rows: number[]) => void;
    /**
     * 모든 행의 상태가 초기회 되었음을 알리는 콜백
     *
     * @remarks
     * {@link DataProviderBase.clearRowStates} 를 통해 행의 상태가 모두 초기화 한 후에 발생
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowStatesCleared = function (provider) {
     *      console.log('dataProvider row state cleared!');
     * };
     * ```
     */
    onRowStatesCleared: (provider: LocalDataProvider) => void;
    /**
     * 복수의 데이터 행의 상태가 복원되었음을 알리는 콜백
     *
     * @remarks
     * {@link DataProviderBase.restoreUpdatedRows | restoreUpdatedRows() } 함수를 통해 수정된 행들이 복원 되었을 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 복원된 데이터 행들의 인덱스 배열
     *
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRestoreRows = function (provider, rows) {
     *      console.log('dataProvider row restored: ' + rows.join(', '));
     * };
     * ```
     */
    onRestoreRows: (provider: LocalDataProvider, rows: number[]) => void;
    /**
     * 데이터 셋의 데이터 건수를 반환한다.
     *
     * @example
     * ```js
     * let rowCount = ds.getRowCount();
     * ```
     */
    getRowCount(): number;
    /**
     * 데이터 셋의 데이터 건수를 설정하다.
     *
     * @remarks
     * 데이터 셋의 데이터 건수를 강제로 설정한다. 기존의 건수가 새로운 건수보다 많을 경우 잘려서 버려지고 새로운 건수가 많을 경우 새로운 행이 추가된다.
     *
     * @param newCount - 새로운 데이터 건수
     * @param fillFieldDefaults - 새로운 행이 추가될때 필드의 기본값을 사용하여 값을 넣을지의 여부, 기본값: `false`
     * @param defaultValues - 새로운 행이 추가될때 각각의 필드에 해당하는 값들, 기본값: `null`, 필드순서대로 사용한다.
     * @param rowState - 새로운 행의 상태, 기본값: {@link RowState.NONE}
     *
     * @example
     * ```js
     * ds.setRowCount(100);
     * ```
     */
    setRowCount(newCount: number, fillFieldDefaults?: boolean, defaultValues?: DataValues, rowState?: RowState): void;
    /**
     * 필터간의 연산조건을 설정한다.
     *
     * @remarks
     * 필터들의 연산 조건을 AND 또는 OR로 설정한다
     * {@link LocalDataProvider.setFilters | setFilters }에서 filterMode 지정하는것과 동일한 기능이다
     *
     * @param filterMode - 필터들의 연산 조건. `'and'`또는 `'or'`
     */
    setFilterMode(filterMode?: string): void;
    /**
     * 데이터 셋에서 데이터를 필터링한다.
     *
     * @remarks
     * DataProvider에 필터를 적용한다. 필터에 부합하지 않은 행은 DataProvider에 존재하지 않게 된다.
     *
     * @param filters - 필터 설정 값
     * @param filterMode - 필터들의 연산 조건. `'and'`또는 `'or'` 다.
     * @example
     * ```js
     * // nonArray
     * dataProvider.setFilters({criteria: "value['field1']='가수'"});
     *
     * // string
     * dataProvider.setFilters([
     *   "value['field1']='가수'",
     *   "value['field2']='여자'"
     * ], "and");
     *
     * // object
     * dataProvider.setFilters([
     *   {criteria: "value['field1']='가수'"},
     *   {criteria: "value['field2']='여자'"}
     * ], "and");
     * ```
     */
    setFilters(filters: DataFilters, filterMode?: string): void;
    /**
     * JSON 데이터 원본에서 데이터를 가져와 데이터 셋을 생성한다.
     *
     * @param data - 데이터 원본, JSON 문자열 또는 오브젝트의 배열
     * @param options - 데이터 추출및 채우는 방식 설정, {@link DataFillOptions} 또는 DataFillOptions 객체, `null`이면 기본값으로 동작
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillJsonData([
     *  {
     *    FieldA: 'ABC',
     *    FieldB: 10
     *  }, {
     *    FieldA: 'DEF',
     *    FieldB: 30
     *  }], options);
     * ```
     */
    fillJsonData(data: any, options?: DataFillOptions): void;
    /**
     * XML 데이터 원본에서 문자열을 파싱하여 데이터 셋을 생성한다.
     *
     * @param data - XML 문자열
     * @param options - 데이터 추출및 채우는 방식 설정,  {@link DataFillOptions} 객체 또는 DataFillOptions와 동일 구조의 object
     *
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillXmlData(data, options);
     * ```
     */
    fillXmlData(data: any, options?: DataFillOptions): void;
    /**
     * CSV 데이터 원본에서 문자열을 파싱하여 데이터 셋을 생성한다.
     *
     * @param data - CSV 문자열
     * @param options - 데이터 추출및 채우는 방식 설정,  {@link DataFillOptions} 객체 또는 DataFillOptions와 동일 구조의 object
     *
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillCsvData(data, options);
     * ```
     */
    fillCsvData(data: any, options?: DataFillOptions): void;
    /**
     * 데이터 원본에서 가져와 데이터 셋을 채운다.
     *
     * @param rows - 데이터 원본, 2차원 배열 또는 오브젝트의 배열
     * @param start - 데이터 셋에 채울 데이터의 시작 행, 기본값: `0`
     * @param count - 데이터 셋에 채울 데이터 건수, `-1`이면 데이터 원본의 건수만큼 채운다. 기본값: `-1`
     * @example
     * ```js
     * dataProvider.setRows([
     *  {
     *    FieldA: 'ABC',
     *    FieldB: 10
     *  }, {
     *    FieldA: 'DEF',
     *    FieldB: 30
     *  }]);
     * ```
     */
    setRows(rows: DataValues[], start?: number, count?: number): void;
    /**
     * 데이터 원본에서 가져와 데이터 셋에 추가한다.
     *
     * @param rows - 데이터 원본, 2차원 배열 또는 오브젝트의 배열
     * @param start - 데이터 셋에 채울 데이터의 시작 행, 기본값 `0`
     * @param count - 데이터 셋에 채울 데이터 건수, `-1`이면 데이터 원본의 건수만큼 추가된다, 기본값: `-1`
     * @param rowEvents - true면 행 단위로 추가 이벤트가 발생하고, false면 복수행 추가 이벤트가 한 번 발생한다. 기본값: `false`
     * @example
     * ```js
     * dataProvider.addRows([
     *  {
     *    FieldA: 'GHI',
     *    FieldB: 15
     *  }, {
     *    FieldA: 'KLM',
     *    FieldB: 31
     *  }]);
     * ```
     */
    addRows(rows: DataValues[], start?: number, count?: number, rowEvents?: boolean): void;
    /**
     * 데이터 원본에서 가져와 데이터 셋의 특정 위치에 삽입한다.
     *
     * @param row - 삽입할 데이터 행의 인덱스
     * @param rows - 데이터 원본, 2차원 배열 또는 Object의 배열
     * @param start - 데이터 셋에 채울 데이터의 시작 행, 기본값: `0`
     * @param count - 데이터 셋에 채울 데이터 건수, -1이면 데이터 원본의 건수만큼 삽입된다. 기본값: `-1`
     * @param rowEvents - true면 행 단위로 추가 이벤트가 발생하고, false면 복수행 추가 이벤트가 한 번 발생한다. 기본값: `false`
     * @example
     * ```js
     * dataProvider.insertRows(10, [
     *  {
     *    FieldA: 'OPQ',
     *    FieldB: 34
     *  }, {
     *    FieldA: 'RST',
     *    FieldB: 27
     *  }]);
     * ```
     */
    insertRows(row: number, rows: DataValues[], start?: number, count?: number, rowEvents?: boolean): void;
    /**
     * 데이터 원본에서 가져와 데이터 셋의 특정 위치에 변경한다.
     *
     * @param row - 변경할 데이터 행의 인덱스
     * @param rows - 데이터 원본, 2차원 배열 또는 Object의 배열
     * @param start - 데이터 셋에 채울 데이터의 시작 행, 기본값: `0`
     * @param count - 데이터 셋에 채울 데이터 건수, `-1`이면 데이터 원본의 건수만큼 변경된다, 기본값: `-1`
     * @param strict - textField의 값이 `null`, `undefined` `""`인경우 변경여부 `false`이면 동일한 값으로 판단하여 변경하지 않는다.
     * @param rowEvents - `true`이면 행별로 {@link LocalDataProvider.onRowUpdated | onRowUpdated}를 호출한다. `false`이면 {@link LocalDataProvider.onRowsUpdated | onRowsUpdated}를 호출한다.
     * @example
     * ```js
     * dataProvider.updateRows(10, [
     *  {
     *    FieldA: 'OPQ',
     *    FieldB: 34
     *  }, {
     *    FieldA: 'RST',
     *    FieldB: 27
     *  }]);
     * ```
     */
    updateRows(row: number, rows: DataValues[], start?: number, count?: number, strict?: boolean, rowEvents?: boolean): void;
    /**
     * 연속적이지 않은 행을 일괄 수정한다.
     * @param rows - 데이터 원본 &#123;1:&#123;"field1":value, "field2":value2&#125;, ...&#125;
     * @param strict - textField의 값이 `null`, `undefined` `""`인경우 변경여부 `false`이면 동일한 값으로 판단하여 변경하지 않는다.
     * @param rowEvents - `true`이면 행별로 {@link LocalDataProvider.onRowUpdated | onRowUpdated}를 호출한다. `false`이면 {@link LocalDataProvider.onRowListUpdated | onRowListUpdated}를 호출한다.
     *
     * @example
     * ```js
     * var data = {
     *      1:{"field1":value1, "field2":value2},
     *      3:{"field1":value1, "field2":value2}
     * }
     * dataProvider.updateRowsByDataRow(data);
     * ```
     */
    updateRowsByDataRow(rows: {
        [key: number]: DataValues;
    }, strict?: boolean, rowEvents?: boolean): void;
    /**
     * 데이터 셋을 초기화한다
     *
     * @example
     * ```js
     * dataProvider.clearRows();
     * ```
     */
    clearRows(): void;
    /**
     * 데이터 셋의 특정 데이터 행의 값을 변경한다.
     *
     * @param row - 변경할 데이터 행의 인덱스
     * @param values - 행의 변경할 데이터, 필드 인덱스 순서대로 배열에서 가져온다
     * @param strict - 값이 `undefined` 이거나 명시되지 않은 필드는 기존의 값을 유지한다
     *
     * @example
     * ```js
     * dataProvider.updateRow(3, ['value1', 'value2', 'value3', 'value4'], true);
     * ```
     */
    updateRow(row: number, values: DataValues, strict: boolean): void;
    /**
     * 특정 행들을 View에게 감출 때 사용한다.
     * @remarks
     * 숨겨진 상태에서 데이터 셋의 추가, 삭제가 발생하는 경우 인덱스가 변경되므로 주의를 요한다.
     * @param dataRows - 감출 데이터 행의 인덱스 또는 인덱스 배열
     *
     * @example
     * ```js
     * // single
     * dataProvider.hideRows(3);
     *
     * //multiple
     * dataProvider.hideRows([3,2,1]);
     * ```
     */
    hideRows(dataRows: number[] | number): void;
    /**
     * 감춰진 데이터행을 다시 표시한다.
     *
     * @param dataRows - 다시 표시할 데이터 행의 인덱스 또는 인덱스 배열
     *
     * @example
     * ```js
     * // single
     * dataProvider.showHiddenRows(3);
     *
     * //multiple
     * dataProvider.showHiddenRows([3,2,1]);
     * ```
     */
    showHiddenRows(dataRows: number[] | number): void;
    /**
     * 감춰진 데이터행들의 인덱스을 반환한다.
     *
     * @example
     * ```js
     * let hiddens = dataProvider.getHiddenRows();
     * ```
     */
    getHiddenRows(): number[];
    /**
     * 특정 행이 감춰줘있는지의 여부를 반환한다.
     *
     * @param dataRow - 확인할 데이터 행의 인덱스
     *
     * @example
     * ```js
     * let isHidden = dataProvider.isHiddenRow(3);
     * ```
     */
    isHiddenRow(dataRow: number): boolean;
    /**
     * 모든 행의 감춰진 상태를 초기환한다.
     *
     * @example
     * ```js
     * dataProvider.resetHiddenRows();
     * ```
     */
    resetHiddenRows(): void;
    /**
     * 데이터 행을 추가한다
     *
     * @param values - 추가할 행의 값, 배열 또는 Object
     * @returns 추가된 행의 dataRow 실패한경우 -1이 return된다.
     *
     * @example
     * ```js
     * dataProvider.addRow({
     *    FieldA: 'GHI',
     *    FieldB: 15
     * });
     * ```
     */
    addRow(values: DataValues): number;
    /**
     * 특정 위치에 데이터 행을 삽입한다
     *
     * @param row - 삽입할 데이터 행의 인덱스
     * @param values - 삽입할 행의 값, 배열 또는 오브젝트
     *
     * @example
     * ```js
     * dataProvider.insertRow(4, {
     *    FieldA: 'DNA',
     *    FieldB: 15
     * });
     * ```
     */
    insertRow(row: number, values: DataValues): boolean;
    /**
     * 특정 위치의 데이터 행을 제거한다
     *
     * @param row - 제거할 데이터 행의 인덱스
     *
     * @example
     * ```js
     * dataProvider.removeRow(2);
     * ```
     */
    removeRow(row: number): void;
    /**
     * 특정 위치의 복수의 데이터 행들을 제거한다.
     *
     * @param rows - 제거할 데이터 행 인덱스의 배열
     * @param rowEvents - 개별 이벤트 발생 여부, 기본값: `false`
     *
     * @example
     * ```js
     * dataProvider.removeRows([2,3,4]);
     * ```
     */
    removeRows(rows: number[], rowEvents?: boolean): void;
    /**
     * 특정 데이터 행을 이동한다
     *
     * @param rows - 이동할 데이터 행 인덱스
     * @param newRow - 새로운 인덱스
     *
     * @example
     * ```js
     * dataProvider.moveRow(2, 5);
     * ```
     */
    moveRow(row: number, newRow: number): void;
    /**
     * 복수의 데이터 행들을 이동한다.
     *
     * @param row - 이동할 데이터 행들 중 첫 행의 인덱스
     * @param count - 이동할 데이터 행의 건수
     * @param newRow - 이동될 행의 인덱스
     * @example
     * ```js
     * dataProvider.moveRows(2, 2, 5);
     * ```
     */
    moveRows(row: number, count: number, newRow: number): void;
    /**
     * 특정 데이터 행의 특정 필드의 값을 반환한다.
     *
     * @param row - 값을 가져올 데이터 행의 인덱스
     * @param field - 값을 가져올 필드의 인덱스 또는 필드명
     *
     * @example
     * ```js
     * let val = dataProvider.getValue(2, 10);
     * ```
     */
    getValue(row: number, field: number | string): any;
    /**
     * 특정 데이터 행의 특정 필드의 값을 변경한다.
     *
     * @param row - 값을 변경할 데이터 행의 인덱스
     * @param field - 값을 변경할 필드의 인덱스 또는 필드명
     * @param newValue - 변경할 새로운 값
     *
     * @example
     * ```js
     * dataProvider.setValue(2, 5, 'newValue');
     * ```
     */
    setValue(row: number, field: number | string, newValue: any): void;
    /**
     * 데이터 셋의 특정 구간의 데이터를 2차원 배열로 반환한다.
     *
     * @param startRow - 시작 데이터 행의 인덱스 0이면 시작, 기본값: `0`
     * @param endRow - 끝 데이터 행의 인덱스, `-1`이면 데이터 셋의 끝까지, 기본값: `-1`
     *
     * @example
     * ```js
     * let rows = dataProvider.getRows();
     * ```
     */
    getRows(startRow?: number, endRow?: number): RowValues[];
    /**
     * @public
     * 지정한 데이터 행의 값을 Object 형태로 변환한다.
     *
     * @param row - 행 고유번호
     * @param rowState - `true`이면 행의 상태값을 추가한다.
     *
     * @returns 행의 값을 json 형태로 반환한다.
     *
     * @example
     * ```js
     * let jsonRow = ds.getJsonRow(5);
     * ```
     */
    getJsonRow(row: number, rowState?: boolean): RowObject;
    /**
     * 데이터 셋의 특정 구간의 데이터를 Object 배열로 반환한다.
     *
     * @param startRow - 시작 데이터 행의 인덱스, 기본값: `0`
     * @param endRow - 끝 데이터 행의 인덱스, -1이면 데이터 셋의 끝까지
     * @param rowState - `true`이면 결과 값에 행의 상태값을 추가한다.
     *
     * @example
     * ```js
     * let rows = dataProvider.getJsonRows();
     * ```
     */
    getJsonRows(startRow?: number, endRow?: number, rowState?: boolean): object[];
    /**
     * 데이터 셋의 특정 데이터 행을 설정에 따라 Object로 반환한다.
     *
     * @param options - 데이터를 반환내는 방식 설정, {@link DataOutputOptions} 과 동일
     * @param row - 데이터 행의 인덱스
     *
     * @example
     * ```js
     * let opt = {
     *      nullText: '빈 값'
     * }
     * let row = dataProvider.getOutputRow(opt, 4);
     * ```
     */
    getOutputRow(options: DataOutputOptions, row: number): object;
    /**
     * 데이터 셋의 특정 구간의 데이터를 설정에 따라 Object 배열로 반환한다.
     *
     * @param options - 데이터를 반환내는 방식 설정,  {@link DataOutputOptions} 과 동일
     * @param startRow - 시작 데이터 행의 인덱스, 기본값: `0`
     * @param endRow - 끝 데이터 행의 인덱스, -1이면 데이터 셋의 끝까지, 기본값: `-1`
     *
     *
     * @example
     * ```js
     * let opt = {
     *      nullText: '빈 값'
     * }
     * let rows = dataProvider.getOutputRows(opt, 4, 10);
     * ```
     */
    getOutputRows(options: DataOutputOptions, startRow?: number, endRow?: number): object[];
    /**
     * 데이터 셋의 특정 필드에 해당하는 특정 구간의 데이터를 반환한다.
     *
     * @param filed - 필드의 인덱스 또는 필드명
     * @param startRow - 시작 행의 인덱스, 기본값: `0`
     * @param endRow - 마지막 행의 인덱스, -1이면 데이터 셋의 끝까지, 기본값: `-1`
     */
    getFieldValues(field: number | string, startRow?: number, endRow?: number): any[];
    /**
     * 검색 설정 방식에 따라 특정 값이 있는 행을 찾는다.
     *
     * @param options - 검색 방식, {@link SearchOptions} 모델로 지정한다.
     * @returns 찾은 행의 인덱스
     *
     * @example
     * ```js
     * ds.searchDataRow({fields:['fieldName'], values: ['value']});
     * ```
     */
    searchDataRow(options: SearchOptions): number;
    /**
     * 검색 설정 방식에 따라 특정 값이 있는 셀을 찾는다.
     *
     * @param options - 검색 방식, {@link SearchCellOptions} 모델로 지정한다.
     * @returns 찾은 셀의 정보, {@link SearchCellResult} 모델이다.
     *
     * @example
     * ```js
     * ds.searchData({fields:['fieldName'], value: 'value'});
     * ```
     */
    searchData(options: SearchCellOptions): SearchCellResult;


}

/**
 * @public
 * LocalTreeDataProvider 클래스. {@link DataProviderBase} 를 상속한다.
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link DataProviderBase}
 */
export declare class LocalTreeDataProvider extends DataProviderBase {


    /**
     * 행의 갯수가 변경되었음을 알리는 콜백
     *
     * @remarks
     * 행 추가 및 삭제 등으로 행의 개수가 변경됐을 때 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `newCount` - 변경된 행의 갯수
     *
     * @example
     * ```js
     * dataProvider.onRowCountChanged = function (provider, count) {
     *     console.log("DataProvider rowCount changed as: " + newCount);
     * };
     * ```
     */
    onRowCountChanged: (provider: LocalTreeDataProvider, newCount: number) => void;
    /**
     * 행이 추가됨을 결정하는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 추가되기 직전에 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * `index` - 부모 행의 자식들 중 삽입된 행의 위치(순서)
     *
     * `child` - 추가 된 행의 자식 데이터
     *
     * @defaultValue `null`
     * [반환값] - 기본값: `true`, 명시적으로 `false`를 리턴하면 행이 삽입되지 않는다.
     *
     * @example
     * ```js
     * dataProvider.onRowAdding = function (provider, row, index, child) {
     *      if (row > 100) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowAdding: (provider: LocalTreeDataProvider, row: number, index: number, child: any) => boolean;
    /**
     * 행이 추가되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 추가된 후 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowAdded = function (provider, row) {
     *      console.log("DataProvider row added at "+ row);
     * };
     * ```
     */
    onRowAdded: (provider: LocalTreeDataProvider, row: number) => void;
    /**
     * 행들이 추가되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 추가된 후 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `parent` - 부모의 id
     *
     * `rows` - 데이터 행들의 트리 id들
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsAdded = function (provider, parent, rows) {
     *      console.log("DataProvider row added at " + parent + " as " + rows.join(", "));
     * };
     * ```
     */
    onRowsAdded: (provider: LocalTreeDataProvider, parent: number, rows: number[]) => void;
    /**
     * 행 삭제를 결정하는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 삭제되기 전 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * @defaultValue `null`
     *
     * [반환값] - - 기본값: `true`, 삭제하려면 `true`, 삭제를 취소하려면 `false` 를 반환한다.
     *
     * @example
     * ```js
     * dataProvider.onRowDeleting = function (provider, row) {
     *      if (row < 100) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowDeleting: (provider: LocalTreeDataProvider, row: number) => boolean;
    /**
     * 행 삭제가 되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 삭제된 후 호출한다.
     *
     * softDeleting = true 일 경우 Row의 State가 Deleted로 변경된 것 만으로는 호출되지 않는다.
     *
     * 완전히 TreeDataProvider에서 삭제되었을 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowDeleted = function (provider, row) {
     *      console.log('dataProvider row deleted ' + row);
     * };
     * ```
     */
    onRowDeleted: (provider: LocalTreeDataProvider, row: number) => void;
    /**
     * 행들이 삭제가 되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터 행들이 삭제된 후 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `rows` - 데이터 행들의 트리 id들
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsDeleted = function (provider, rows) {
     *      console.log('DataProvider rows deleted: ' + rows.join(', '));
     * };
     * ```
     */
    onRowsDeleted: (provider: LocalTreeDataProvider, rows: number[]) => void;
    /**
     * 행 수정을 결정하는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 수정되기 전에 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * @defaultValue `null`
     * [반환값] - 기본값: `true`, `false` 를 반환하면 수정이 취소된다.
     *
     * @example
     * ```js
     * dataProvider.onRowUpdating = function (provider, row) {
     *      if(row % 2 === 0) {
     *          console.log("DataProvider row updated: " + row);
     *          return true;
     *      }
     *      return false;
     * };
     * ```
     */
    onRowUpdating: (provider: LocalTreeDataProvider, row: number) => boolean;
    /**
     * 행 수정이 되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 수정되기 전에 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowUpdated = function (provider, row) {
     *      console.log("DataProvider row updated: " + row);
     * };
     * ```
     */
    onRowUpdated: (provider: LocalTreeDataProvider, row: number) => void;
    /**
     * 다수의 데이터 행 변경을 결정하는 콜백
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 변경될 데이터 행들의 트리 id
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsUpdating = function (provider, rows) {
     *      if (rows.length > 10) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowsUpdating: (provider: LocalTreeDataProvider, rows: number[]) => boolean;
    /**
     * 다수의 데이터 행이 변경되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.updateRows | updateRows } 등의 함수에서 이벤트 일괄 반영되도록 했을 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 변경된 데이터 행들의 트리 id들
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsUpdated = function (provider, rows) {
     *      console.log("DataProvider rows updated: " + rows.join(', '));
     * };
     * ```
     */
    onRowsUpdated: (provider: LocalTreeDataProvider, rows: number[]) => void;
    /**
     * 데이터의 값이 변경 되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalTreeDataProvider.setValue} 를 이용하여 데이터를 변경한후 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 값이 변경된 데이터 행의 트리 id.
     *
     * `field` - 필드의 인덱스.
     *
     * @defaultValue `null`
     * @example
     * ```js
     * dataProvider.onValueChanged = function (provider, row, field) {
     *      console.log('DataProvider row Value changed at ' + row + ' on ' + field);
     * };
     * ```
     */
    onValueChanged: (provider: LocalTreeDataProvider, row: number, field: number) => void;
    /**
     * 데이터가 변경 되었음을 알리는 콜백
     *
     * @remarks
     * key 입력이나  {@link LocalTreeDataProvider.setValue} 를 이용하여 데이터를 변경한후 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onDataChanged = function (provider) {
     *      console.log('dataChanged!');
     * };
     * ```
     */
    onDataChanged: (provider: LocalTreeDataProvider) => void;
    /**
     * 행 상태가 변경되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider의 데이터행의 rowState가 변경된 뒤 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 변경된 데이터 행의 트리 id
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowStateChanged = function (provider, row) {
     *      console.log('dataProvider row state changed: ' + row);
     * };
     * ```
     */
    onRowStateChanged: (provider: LocalTreeDataProvider, row: number) => void;
    /**
     * 여러 행들의 상태가 변경되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에서 여러 건의 데이터행의 rowState가 변경된 뒤 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `rows` - 변경된 데이터 행들의 트리 id 들
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowStatesChanged = function (provider, rows) {
     *      console.log('dataProvider row state changed: ' + rows.join(','));
     * };
     * ```
     */
    onRowStatesChanged: (provider: LocalTreeDataProvider, rows: number[]) => void;
    /**
     * 행 들의 형제 간 이동을 결정하는 콜백
     *
     * @remarks
     * {@link LocalTreeDataProvider.moveRowSibling} 함수를 사용하여 형제 간 위치를 바꾸려고 할때 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 이동하려는 데이터 행의 트리 id
     *
     * `offset` - 상하 위치 단계 값
     *
     * @defaultValue `null`
     * [반환값] - 기본값: `true`, `false`를 반환하면 이동이 취소된다.
     *
     * @example
     * ```js
     * dataProvider.onRowSiblingMoving = function (provider, row, offset) {
     *      if (row % 2 === 0) {
     *          return true;
     *      }
     *      return false;
     * };
     * ```
     */
    onRowSiblingMoving: (provider: LocalTreeDataProvider, row: number, offset: number) => boolean;
    /**
     * 행 들의 형제 간 이동했음을 알리는 콜백
     *
     * @remarks
     * {@link LocalTreeDataProvider.moveRowSibling} 함수를 사용하여 형제 간 위치가 바뀌었을 때 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 이동한 데이터 행의 트리 id
     *
     * `offset` - 상하 위치 단계 값
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowSiblingMoved = function (provider, row, offset) {
     *      console.log('sibling row moved on: ' + row);
     * };
     * ```
     */
    onRowSiblingMoved: (provider: LocalTreeDataProvider, row: number, offset: number) => void;
    /**
     * DragAndDrop을 이용한 형제 간 이동을 결정하는 콜백
     *
     * @remarks
     * 마우스 dragAndDrop을 사용하여 형제 간 위치를 바꾸려고 할때 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `rows` - 이동하려는 데이터 행의 트리 id 배열
     *
     * `offset` - 상하 위치 단계 값
     *
     * @defaultValue `null`
     * [반환값] - 기본값: `true`, `false`를 반환하면 이동이 취소된다.
     *
     * @example
     * ```js
     * dataProvider.onRowsSiblingMoving = function (provider, rows, offset) {
     *      if (rows.length > 1) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowsSiblingMoving: (provider: LocalTreeDataProvider, rows: number[], offset: number) => boolean;
    /**
     * dragAndDrop을 이용해서 형제 간 이동했음을 알리는 콜백
     *
     * @remarks
     * 마우스 dragAndDrop을 사용하여 형제 간 위치가 바뀌었을 때 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `rows` - 이동한 데이터 행의 트리 id 배열
     *
     * `offset` - 상하 위치 단계 값
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsSiblingMoved = function (provider, rows, offset) {
     *      console.log('sibling rows moved on: ' + rows);
     * };
     * ```
     */
    onRowsSiblingMoved: (provider: LocalTreeDataProvider, rows: number[], offset: number) => void;
    /**
     * 행의 부모를 바꾸는 것을 결정하는 콜백
     *
     * @remarks
     * {@link LocalTreeDataProvider.changeRowParent} 함수를 사용하여 부모를 바꾸려고 할때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 이동하려는 데이터 행의 트리 id
     *
     * `parent` - 이동하려는 곳의 부모 아이템
     *
     * `index` - 이동하려는 부모의 위치 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `false`를 반환하면 이동이 취소된다.
     *
     * @example
     * ```js
     * dataProvider.onRowParentChanging = function (provider, row, parent, index) {
     *      if (row % 2 === 0) {
     *          return true;
     *      }
     *      return false;
     * };
     * ```
     */
    onRowParentChanging: (provider: LocalTreeDataProvider, row: number, parent: number, index: number) => boolean;
    /**
     * 행의 부모가 바뀐 것을 알리는 콜백
     *
     * @remarks
     * {@link LocalTreeDataProvider.changeRowParent} 함수를 사용하여 부모가 바뀐 후에 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 이동한 데이터 행의 트리 id
     *
     * `parent` - 이동한 곳의 부모 아이템
     *
     * `index` - 이동한 부모의 위치 index
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowParentChanged = function (provider, row, parent, index) {
     *      console.log('parent row changed to ' + parent);
     * };
     * ```
     */
    onRowParentChanged: (provider: LocalTreeDataProvider, row: number, parent: number, index: number) => void;
    /**
     * 저장 된 데이터행의 갯수를 반환한다.
     *
     * @remarks
     * 루트의 하위에 저장되어있는 모든 아이템의 갯수를 반환한다.
     *
     * @example
     * ```js
     * let rowCount = ds.getRowCount();
     * ```
     */
    getRowCount(): number;
    /**
     * 트리의 데이터를 새로운 데이터로 설정한다.
     *
     * @remarks
     * 트리의 기존 데이터행들을 모두 삭제하고 매개변수로 전달되는 배열의 배열을 데이터 행들로 추가한다.
     *
     * @param rows - 설정할 데이터
     * @param treeField - 필드 명
     * @param needSortnig - 정렬 여부
     * @param childrenField - 자식 행이 있는 지를 지시하는 필드
     * @param iconField - 트리 노드에 표시할 아이콘 경로를 값으로 가지고 있는 필드 이름
     *
     * @example
     * ```js
     * dataProvider.setRows([{
     *          'uno', 1, 'one', 'ichi', 'ee', 'I'
     *      }, {
     *          'dos', 2, 'two', 'ni', 'er', 'II'
     *      }
     * ], 'number', false, '', 'icon');
     * ```
     */
    setRows(rows: DataValues[], treeField: string, needSorting?: boolean, childrenField?: string, iconField?: string): void;
    /**
     * 트리의 데이터를 새로운 CSV 데이터로 설정한다.
     *
     * @remarks
     * 트리의 기존 데이터행들을 모두 삭제하고 매개변수로 전달되는 CSV를 데이터 행들로 추가한다.
     *
     * @param rows - 설정할 데이터
     * @param treeField - 필드 명
     * @param needSortnig - 정렬 여부
     * @param childrenField - 자식 행이 있는 지를 지시하는 필드
     * @param iconField - 트리 노드에 표시할 아이콘 경로를 값으로 가지고 있는 필드 이름
     *
     * @example
     * ```js
     * let rows = `Username; Identifier;First name;Last name
     * booker12;9012;Rachel;Booker
     * grey07;2070;Laura;Grey
     * johnson81;4081;Craig;Johnson
     * jenkins46;9346;Mary;Jenkins
     * smith79;5079;Jamie;Smith
     * `
     * dataProvider.setCsvRows(rows, 'number', false, '', 'icon');
     * ```
     */
    setCsvRows(rows: string, treeField: string, needSorting?: boolean, childrenField?: string, iconField?: string): void;
    /**
     * 트리의 데이터를 새로운 XML 데이터로 설정한다.
     *
     * @remarks
     * 트리의 기존 데이터행들을 모두 삭제하고 매개변수로 전달되는 XML을 데이터 행들로 추가한다.
     * rowElement에 "row"를 입력하면 루트의 row element가 사용될 것이고,
     * rowElement에 "row[0].row"를 입력하면 루트의 첫번째 행이 사용될 것이다.
     * "row.row"는 "row[0].row"와 같다.
     *
     * @param xml - 설정할 데이터
     * @param rowElement - XML 중 트리의 데이터 행들로 사용될 element의 이름
     * @param childrenField - 자식 행이 있는 지를 지시하는 필드, 자식의 필드 명
     * @param iconField - 트리 노드에 표시할 아이콘 경로를 값으로 가지고 있는 필드 이름
     *
     * @example
     * ```js
     * dataProvider.setXmlRows(rows, 'number', false, '', 'icon');
     * ```
     */
    setXmlRows(xml: any, rowElement: string, childrenField?: string, iconField?: string): void;
    /**
     * 트리의 데이터를 새로운 JSON 데이터로 설정한다.
     *
     * @remarks
     * 트리의 기존 데이터행들을 모두 삭제하고 매개변수로 전달되는 JSON 객체를 데이터 행들로 추가한다.
     *
     * @param json - 설정할 데이터. Json 배열이거나 Json 배열을 속성으로 갖는 object. Json 배열이 아닌 경우 rowsProp에 지정된 속성을 배열로 지정해야 한다.
     * @param rowsProp - Json 중 트리의 데이터 행들로 사용될 배열을 값으로 하는 속성명
     * @param childrenProp - 자식 행이 있는 지를 지시하는 속성 이름. 해당 속성의 값이 자식의 필드 이름과 같아야한다.
     * @param iconProp - 트리 노드에 표시할 아이콘 경로를 값으로 가지고 있는 속성명
     *
     * @example
     * ```js
     * dataProvider.setObjectRows(rows, 'rowsProp', 'childField', 'iconField');
     * ```
     */
    setObjectRows(json: any, rowsProp: string, childrenProp?: string, iconProp?: string): void;
    /**
     * 트리의 데이터를 새로운 JSON 데이터로 설정한다.
     *
     * @remarks
     * 트리의 기존 데이터행들을 모두 삭제하고 매개변수로 전달되는 JSON 객체를 데이터 행들로 추가한다.
     * {@link LocalTreeDataProvider.setObjectRows}와 다른점은 childrenProp와 iconProp가 field에 등록되어있지 않아도 된다.
     *
     * @param json - 설정할 데이터. Json 배열이거나 Json 배열을 속성으로 갖는 object. Json 배열이 아닌 경우 rowsProp에 지정된 속성을 배열로 지정해야 한다.
     * @param rowsProp - Json 중 트리의 데이터 행들로 사용될 배열의 속성명
     * @param childRowsProp - 1 레벨의 배열명과 하위 레벨의 배열명이 다른경우 하위 레벨의 배열 속성명
     * @param childrenProp - 자식 행이 있는 지를 지시하는 속성명.
     * @param iconProp - 트리 노드에 표시할 아이콘 경로를 값으로 가지고 있는 속성명
     *
     * @example
     * ```js
     * dataProvider.setNestedRows(rows, 'rowsProp', 'childRowsProp', 'childrenProp", 'iconProp');
     * ```
     */
    setNestedRows(json: any, rowsProp: string, childRowsProp: string, childrenProp?: string, iconProp?: string): void;
    /**
     * 지정한 설정에 따라 Json 데이터를 로드하여 TreeDataProvider 로컬 저장소에 저장한다.
     *
     * @param data - json 형태의 데이터
     * @param options - {@link DataFillOptions} 와 같은 모델의 설정 정보
     *
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillJsonData([
     *  {
     *    FieldA: 'ABC',
     *    FieldB: 10
     *  }, {
     *    FieldA: 'DEF',
     *    FieldB: 30
     *  }], options);
     * ```
     */
    fillJsonData(data: any, options: DataFillOptions): void;
    /**
     * 지정한 설정에 따라 xml 데이터를 로드하여 TreeDataProvider 로컬 저장소에 저장한다.
     *
     * @param data - xml 형태의 데이터
     * @param options - {@link DataFillOptions} 와 같은 모델의 설정 정보
     *
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillXmlData(data, options);
     * ```
     */
    fillXmlData(data: any, options: DataFillOptions): void;
    /**
     * 지정한 설정에 따라 csv 데이터를 로드하여 TreeDataProvider 로컬 저장소에 저장한다.
     *
     * @param data - csv 형태의 데이터
     * @param options - {@link DataFillOptions} 와 같은 모델의 설정 정보
     *
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillCsvData(data, options);
     * ```
     */
    fillCsvData(data: any, options: DataFillOptions): void;
    /**
     * 트리 행에 표시된 아이콘 인덱스를 반환한다.
     *
     * @param row - 데이터 행의 트리 id
     *
     * @example
     * ```js
     * let iconIndex = treeProvider.getIconIndex(4);
     * ```
     */
    getIconIndex(row: number): number;
    /**
     * 지정한 행의 아이콘을 변경한다.
     *
     * @param row - 아이콘을 변경할 행의 트리 id
     * @param iconIndex - 새로 변경할 아이콘 인덱스
     *
     * @example
     * ```js
     * treeProvider.setIconIndex(42, 4);
     * ```
     */
    setIconIndex(row: number, iconIndex: number): void;
    /**
     * 지정한 행의 부모의 row id를 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id
     * @returns 행 또는 부모 행이 존재하지 않을 경우 -1을 반환한다
     *
     * @example
     * ```js
     * let p = treeProvider.getParent(4);
     * ```
     */
    getParent(row: number): number;
    /**
     * 지정한 행의 level을 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id
     *
     * @example
     * ```js
     * let level = treeProvider.getLevel(4);
     * ```
     */
    getLevel(row: number): number;
    /**
     * 지정한 행의 자식 행들의 개수를 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id. -1일 경우 루트 행의 자식 행들의 개수를 반환한다.
     * @returns 지정한 행 또는 자식 행이 존재하지 않을 경우 0을 반환한다
     * @example
     * ```js
     * let childCount = treeProvider.getChildCount(4);
     * ```
     */
    getChildCount(row: number): number;
    /**
     * 지정한 행의 모든 자식 행들의 고유 번호를 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id, -1일 경우 루트 행의 자식 행들의 고유 번호를 반환한다.
     * @returns 지정한 행이 존재하지 않을 경우 null을 반환한다.
     *
     * @example
     * ```js
     * let children = treeProvider.getChildren(4);
     * ```
     */
    getChildren(row: number): number[];
    /**
     * 지정한 행의 자손 행들의 개수를 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id, -1일 경우 루트 행의 자손 행들의 개수를 반환한다.
     *
     * @example
     * ```js
     * let descenCount = treeProvider.getDescendantCount(4);
     * ```
     */
    getDescendantCount(row: number): number;
    /**
     * 지정한 행의 자손 행들의 id를 반환한다.
     *
     * @param data - 지정한 데이터 행의 트리 id, -1일 경우 루트 행의 자손 행들의 row id를 반환한다.
     * @param maxLevel - 반환할 수 있는 최대 레벨 깊이. 설정 된 값 이하의 레벨을 가진 행들만 반환한다.
     * @example
     * ```js
     * let descendants = treeProvider.getDescendants(4, 2);
     * ```
     */
    getDescendants(row: number, maxLevel?: number): number[];
    /**
     * 지정한 행의 조상 행들의 id를 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id
     * @returns 지정한 행 또는 행의 조상 행들이 존재하지 않을 경우 `null`을 반환한다.
     * @example
     * ```js
     * let ances = treeProvider.getAncestors(4);
     * ```
     */
    getAncestors(row: number): number[];
    /**
     * 지정한 데이터 행을 JSON 객체로 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id
     * @param rowState - `true`이면 행의 상태값을 추가한다.
     * @param recursive - `true`이면 자식노드를 포함한다.
     * @param childRowsProp - 자식 속성의 속성명을 지정한다. 기본값: 'rows'
     * @param iconProp - 아이콘 필드의 속성명을 지정한다. 기본값: 'iconIndex'
     * @param level - 자식노드를 포함하는 경우 포함될 parentNode의 level을 `0`으로 계산한 level을 지정한다. 기본값: '-1'
     *
     * @returns 지정한 행이 존재하지 않을 경우 `null`을 반환한다.
     *
     * @example
     * ```js
     * let jsonRow = treeProvider.getJsonRow(4);
     * ```
     */
    getJsonRow(row: number, rowState?: boolean, recursive?: boolean, childRowsProp?: string, iconProp?: string, level?: number): any;
    /**
     * 지정한 데이터 행과 자손들을 JSON 객체로 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id, 지정하지 않거나 rowId를 null로 지정하면 루트 행의 데이터를 가져옵니다.
     * @param recursive - 자손을 포함할 것인지 여부. 기본값: false
     * @param childRowsProp - 자식 속성의 속성명을 지정한다. 기본값: 'rows'
     * @param iconProp - 아이콘 필드의 속성명을 지정한다. 기본값: 'iconIndex'
     * @param rowState - `true`이면 행의 상태값을 추가한다.
     *
     * @returns 지정한 행이 존재하지 않을 경우 `null`을 반환한다.
     * @example
     * ```js
     * let jsonRow = treeProvider.getJsonRows(4, true);
     * ```
     */
    getJsonRows(row: number, recursive?: boolean, childRowsProp?: string, iconProp?: string, rowState?: boolean): object[];
    /**
     * 지정한 데이터 행을 형식을 적용하여 JSON 객체로 가져온다.
     *
     * @param options - {@link DataOutputOptions} 와 같은 모델의 설정 정보
     * @param row - 지정한 데이터 행의 트리 id. 지정하지 않을경우 루트 행의 결과를 반환한다.
     * @param iconProp - 아이콘 필드의 속성명을 지정한다. 기본값: 'iconIndex'
     * @returns 지정한 데이터 행이 존재하지 않으면 `null`을 반환한다.
     * @example
     * ```js
     * let opt = {
     *      nullText: '빈 값'
     * }
     * let row = dataProvider.getOutputRow(opt, 4);
     * ```
     */
    getOutputRow(options: DataOutputOptions, row: number, iconProp?: string): object;
    /**
     * 지정한 데이터 행과 자손들을 형식을 적용하여 JSON 객체로 가져온다.
     *
     * @param options - {@link DataOutputOptions} 와 같은 모델의 설정 정보
     * @param row - 지정한 데이터 행의 트리 id. 지정하지 않을경우 루트 행의 결과를 반환한다.
     * @param recursive - 자손을 포함할 것인지 여부. 기본값: `false`
     * @param childRowsProp - 자식 속성의 속성명을 지정한다. 기본값: 'rows'
     * @param iconProp - 아이콘 필드의 속성명을 지정한다. 기본값: 'iconIndex'
     * @returns 지정한 데이터 행이 존재하지 않으면 `null`을 반환한다.
     *
     * @example
     * ```js
     * let opt = {
     *      nullText: '빈 값'
     * }
     * let row = dataProvider.getOutputRows(opt, 4);
     * ```
     */
    getOutputRows(options: DataOutputOptions, row: number, recursive?: boolean, childRowsProp?: string, iconProp?: string): object[];
    /**
     * 지정한 트리 행의 자식 행을 추가한다.
     *
     * @param row - 지정한 데이터 행의 트리 id. 지정하지 않을경우 루트 행을 지정한다.
     * @param values - 추가할 행의 필드 값 배열 또는 Object
     * @param iconIndex - 트리 행에 표시할 아이콘 인덱스. 기본값: -1
     * @param hasChildren - 자식의 있는지 표시 여부. 기본값: `false`. true면 자식이 있는 것으로 표시
     * @returns 성공적으로 추가하면 추가된 행 고유번호를, 실패하면 -1을 반환한다.
     * @example
     * ```js
     * treeProvider.addChildRow(4, ['value1', 'value2', 'value3', 'value4'], -1, true);
     * ```
     */
    addChildRow(row: number, values: DataValues, iconIndex?: number, hasChildren?: boolean): number;
    /**
     * 지정한 트리 행의 자식행들 중 원하는 위치에 자식행을 추가한다.
     *
     * @param row - 지정한 데이터 행의 트리 id. 지정하지 않을경우 루트 행을 지정한다.
     * @param index - 지정한 부모 행의 자식들 중 삽입하려는 행이 들어갈 위치
     * @param values - 필드값의 배열이나 필드들을 속성으로 하는 json 객체
     * @param iconIndex - 트리 행에 표시할 아이콘 인덱스. 기본값: -1
     * @param hasChildren - 자식의 있는지 표시 여부. 기본값: `false`. `true`면 자식이 있는 것으로 표시
     * @returns 성공적으로 추가하면 추가된 행 고유번호를, 실패하면 -1을 반환한다.
     * @example
     * ```js
     * treeProvider.insertChildRow(4, 3, ['value1', 'value2', 'value3', 'value4'], -1, true);
     * ```
     */
    insertChildRow(row: number, index: number, values: DataValues, iconIndex?: number, hasChildren?: boolean): number;
    /**
     * 지정한 트리 행에 자식노드를 원하는 위치에 추가한다.
     *
     * @remarks
     * 트리형태의 자료를 추가할때 사용한다.
     *
     * @param row - 지정한 데이터 행의 트리 id. 지정하지 않을경우 루트 행을 지정한다.
     * @param index - 지정한 부모 행의 자식들 중 삽입하려는 행이 들어갈 위치
     * @param data - json형태의 data
     * @param childrenProp - 하위 노드가 있는 경우 속성명
     * @param iconField - 트리 행에 표시할 아이콘 인덱스를 가지고 있는 필드
     * @param noState - 행의 상태값을 추가여부 기본값: false
     * @returns 성공적으로 추가하면 추가된 행 고유번호를, 실패하면 -1을 반환한다.
     */
    insertChildNode(row: number, index: number, data: RowObject, childrenProp?: string, iconField?: string, noState?: boolean): number;
    /**
     * 지정한 데이터행의 필드 값들을 수정한다.
     *
     * @param row - 지정한 데이터 행의 트리 id
     * @param values - 변경 값. 필드값의 배열이거나, array또는 json객체다.
     * @param strict - 값이 undefined거나 명시되지 않은 필드는 기존 값을 유지한다.
     * @returns 지정한 데이터 행이 존재할 경우 성공여부를, 하지 않을 경우 `false`를 반환한다.
     *
     * @example
     * ```js
     * treeProvider.updateRow(4, ['value1', 'value2', 'value3', 'value4'], true);
     * ```
     */
    updateRow(row: number, values: any[], strict?: boolean): boolean;
    /**
     * 지정한 데이터행들의 필드 값들을 수정한다.
     *
     * @param rows - 지정한 데이터 행의 트리 id 배열
     * @param values - 변경 값. 필드값의 배열이거나, array또는 json객체다.
     * @param strict - true이면 값이 undefined거나 명시되지 않은 필드는 기존 값을 유지한다.
     *
     * @example
     * ```js
     * treeProvider.updateRows([4,3], [{field1: 'value1', field2: 'value2', field2: 'value3', field4: 'value4'}, {field1: 'val1'}], true);
     * ```
     */
    updateRows(rows: number[], values: DataValues[], strict: boolean): void;
    /**
     * 지정한 데이터행을 삭제한다.
     *
     * @remarks
     * 지정한 데이터행이 조상행인 경우 모든 자손행들도 같이 삭제된다.
     * DataProvider의 softDeleting이 `true`인 경우 실제로 삭제되지않고 rowState만 변경된다.
     *
     * @param row - 삭제할 데이터 행의 트리 id
     * @returns - 지정한 행 또는 행의 부모가 존재할 경우 성공여부를, 하지 않을경우 `false`를 반환한다.
     *
     * @example
     * ```js
     * treeProvider.removeRow(4);
     * ```
     */
    removeRow(row: number): boolean;
    /**
     * 지정한 데이터 행들을 삭제한다.
     *
     * @remarks
     * 지정한 데이터행이 조상행인 경우 모든 자손행들도 같이 삭제된다.
     * DataProvider의 softDeleting이 `true`인 경우 실제로 삭제되지않고 rowState만 변경된다.
     *
     * @param rows - 삭제할 데이터 행들의 트리 id들. 지정하지 않거나 빈 배열을 입력할 경우, false를 반환한다.
     * @returns - 삭제의 성공여부를 반환한다.
     *
     * @example
     * ```js
     * treeProvider.removeRows([1,3,4]);
     * ```
     */
    removeRows(rows: number[]): boolean;
    /**
     * DataProvider의 모든 행을 삭제한다.
     *
     *
     * @example
     * ```js
     * treeProvider.clearRows();
     * ```
     */
    clearRows(): void;
    /**
     * 지정한 행 또는 행들을 화면에서 감춘다.
     *
     * @remarks
     * 숨겨진 상태에서 remove, insert가 발생하는 경우 dataRow가 변경될 수 있으므로 사용시 주의한다.
     *
     * @param dataRows - 숨기고 싶은 행 번호 또는 번호들
     *
     * @example
     * ```js
     * // single
     * treeProvider.hideRows(4);
     *
     * // array
     * treeProvider.hideRows([3,4]);
     * ```
     */
    hideRows(dataRows: number[] | number): void;
    /**
     * 화면에서 감춘 행또는 행들을 보여준다.
     *
     * @remarks
     * filterMode, sortMode:"explicit"인 경우 `showHiddenRows()`를 사용하면 필터나 정렬이 재적용된다.
     * 접힌(collapse) 상태로 표시된다.
     *
     * @param dataRows - 보이고 싶은 행 번호 또는 번호들
     *
     * @example
     * ```js
     * // single
     * treeProvider.showHiddenRows(4);
     *
     * // array
     * treeProvider.showHiddenRows([3,4]);
     * ```
     */
    showHiddenRows(dataRows: number[] | number): void;
    /**
     * 숨겨진 행들의 번호를 반환한다.
     * @example
     * ```js
     * let rows = treeProvider.getHiddenRows();
     * ```
     */
    getHiddenRows(): number[];
    /**
     * 지정된 행이 숨겨진 행인지의 여부를 반환한다.
     *
     * @param dataRow - 지정한 데이터 행의 고유번호
     *
     * @example
     * ```js
     * let isHidden = treeProvider.isHiddenRow(4);
     * ```
     */
    isHiddenRow(dataRow: number): boolean;
    /**
     * 숨겨진 모든 행을 다시 표시한다.
     *
     * @example
     * ```js
     * treeProvider.resetHiddenRows();
     * ```
     */
    resetHiddenRows(): void;
    /**
     * 지정한 데이터 셀의 값을 반환한다.
     *
     * @param row - 데이터 행의 트리 id
     * @param field - 필드명 또는 인덱스
     * @returns 해당 데이터 행이 존재하지 않을 경우 `null`을 반환한다.
     * @example
     * ```js
     * let val = dataProvider.getValue(2, 10);
     * ```
     */
    getValue(row: number, field: string | number): any;
    /**
     * 지정한 데이터 셀의 값을 변경한다.
     *
     * @param row - 데이터 행의 트리 id
     * @param field - 필드명 또는 인덱스
     * @returns 해당 데이터 행이 존재하지 않을 경우 `null`을 반환한다.
     *
     * @example
     * ```js
     * dataProvider.setValue(2, 5, 'newValue');
     * ```
     */
    setValue(row: number, field: string | number, value: any): void;
    /**
     * 같은 부모의 형제 사이에서 특정 데이터행의 위치를 지정한 단계만큼 이동한다.
     *
     * @param row - 데이터 행의 트리 id
     * @param offset - 지정 단계 값
     * @returns 해당 데이터 행이 존재하지 않을 경우 `false`를 반환한다
     *
     * @example
     * ```js
     * dataProvider.moveRowSibling(4, 1);
     * ```
     */
    moveRowSibling(row: number, offset: number): boolean;
    /**
     * 특정 데이터행의 위치를 지정한 행의 하위로 이동한다.
     *
     * @param row - 데이터 행의 트리 id
     * @param parent - 지정한 부모 행의 id. 이 행의 하위로 이동한다.
     * @param index - 형제들 사이에서의 위치
     * @returns 해당 데이터 행 또는 그 부모행이 존재하지 않을 경우 또는 동일한 위치로 이동하려고 했을때 `false`를 반환한다.
     *
     * @example
     * ```js
     * dataProvider.changeRowParent(4, 1, 2);
     * ```
     */
    changeRowParent(row: number, parent: number, index: number): boolean;
    /**
     * 검색 설정 방식에 따라 특정 값이 있는 행을 찾는다.
     *
     * @param options - 검색 방식, {@link SearchOptions} 모델로 지정한다.
     * @returns 찾은 행의 인덱스
     *
     * @example
     * ```js
     * ds.searchDataRow({fields:['fieldName'], values: ['value'], parentId: 3});
     * ```
     *
     * @example
     * ```js
     * ds.searchDataRow({fields:['fieldName'], values: ['value']});
     * ```
     */
    searchDataRow(options: SearchOptions): number;
    /**
     * 검색 설정 방식에 따라 특정 값이 있는 셀을 찾는다.
     *
     * @param options - 검색 방식, {@link SearchCellOptions} 모델로 지정한다.
     * @returns 찾은 셀의 정보, {@link SearchCellResult} 모델이다.
     *
     * @example
     * ```js
     * ds.searchData({fields:['fieldName'], value: 'value', parentId: 3});
     * ```
     */
    searchData(options: SearchCellOptions): SearchCellResult;


}

/**
 * {@link LookupSource} 를 채우기 위한 모델 정보
 *
 * @remarks
 * {@link GridBase.fillLookupData | fillLookupData()} 시 매개변수로 사용된다.
 *
 * @example
 * ```js
 * // rows 속성을 이용할 경우
 * gridView.fillLookupData("empLookup", {
 *      rows: [
 *          ["TOMSP", "5", "TOMSP_5X"],
 *          ["TOMSP", "6", "TOMSP_6X"]
 *      ]});
 *
 * // key-value 속성을 이용할 경우
 * gridView.fillLookupData("empLookup", {
 *      keys: [
 *          ["TOMSP", "5", "TOMSP_5X"],
 *          ["TOMSP", "6", "TOMSP_6X"]
 *      ],
 *      values: [
 *          ["TOMSP_5X"],
 *          ["TOMSP_6X"]
 *      ]});
 * ```
 */
export declare type LookupData = LookupDataRows | LookupDataKeyValues;

/**
 * {@link LookupData} 의 한 종류
 *
 * @example
 * ```
 * {
 *      keys: [
 *          ["TOMSP", "5"],
 *          ["TOMSP", "6"]
 *      ],
 *      values: [
 *          ["TOMSP_5X"],
 *          ["TOMSP_6X"]
 *      ]
 * }
 * ```
 */
export declare interface LookupDataKeyValues {
    /**
     * 키들
     */
    keys: string[] | string[][];
    /**
     * 값
     */
    values: string[];
}

/**
 * {@link LookupData} 의 한 종류
 *
 * @example
 * ```js
 * // key1, key2, value
 * rows: [
 *      ["TOMSP", "5", "TOMSP_5X"],
 *      ["TOMSP", "6", "TOMSP_6X"]
 * ]
 * ```
 */
export declare interface LookupDataRows {
    /**
     * 키들과 값들의 배열
     */
    rows: string[];
}

/**
 * 컬럼에 연결된 데이터 필드의 실제 값 대신 그 값과 연관된 다른 값을 셀에 표시하기 위한 설정 정보
 *
 * @remarks
 * {@link GridBase.setLookups | setLookups}, {@link GridBase.addLookupSource | addLookupSource} 에서 사용된다.
 *
 * @example
 * ```js
 * dataProvider.setFields([
 *     { fieldName:"field1"},
 *     { fieldName:"field2"},
 *     { fieldName:"text1"},
 *     { fieldName:"text2"},
 *     ....
 * ]);
 * gridView.setColumns([
 *     { fieldName:"field1", name:"field1", lookupDisplay:true, lookupSourceId:"field1Data", lookupKeyFields:["field1"], editor:{type:"dropDown"}},
 *     { fieldName:"field2", name:"field2", lookupDisplay:true, lookupSourceId:"field2Data", lookupKeyFields:["field1","field2"], editor:{type:"dropDown"}},
 *     { fieldName:"text1", name:"text1"},
 *     { fieldName:"text2", name:"text2"}
 *     ....
 * ]);
 * // field1의 셀을 수정하였을때 field2의 dropDown Editor의 목록이 변경되도록 컬럼 구성
 * ....
 * gridView.setLookups([
 *     { id:"field1Data",
 *       levels:1,
 *       keys:["data1","data2","data3"],
 *       values:["데이터1","데이터2","데이터3",],
 *     },
 *     { id:"field2Data",
 *       levels:2,
 *       ordered: true,
 *       keys: [
 *         ["data1","data1_code1"],
 *         ["data1","data1_code2"],
 *         ["data1","data1_code3"],
 *         ["data1","data1_code4"],
 *         ["data2","data2_code1"],
 *         ["data2","data2_code2"],
 *         ["data3","data3_code3"],
 *         ["data3","data3_code4"]
 *       ],
 *       values:[
 *         ["데이터1_코드1"],
 *         ["데이터1_코드2"],
 *         ["데이터1_코드3"],
 *         ["데이터1_코드4"],
 *         ["데이터2_코드1"],
 *         ["데이터2_코드2"],
 *         ["데이터3_코드1"],
 *         ["데이터3_코드2"]
 *       ],
 *      }
 * ]);
 * // field1에서 data1을 선택하면 field2의 dropDown Editor에는 data1의 하위코드들만 보여진다.
 * ```
 */
export declare interface LookupSource {
    /**
     * 고유명 (id)
     */
    id: string;
    /**
     * lookup tree 에서의 수준
     *
     * @remarks
     * `1` 이상이어야 한다.
     */
    level?: number;
    /**
     * 정렬 여부
     *
     * @defaultValue `false`
     */
    ordered?: boolean;
    /**
     * 키들
     *
     * @remarks
     * `level` 이 1보다 큰 경우, 순차적으로 해당 레벨과 대응되는 key 값들을 입력해야한다.
     *
     * @example
     * ```js
     * // level 1 인 경우
     * ['동물', '식물', '균류']
     *
     * // level 2 인 경우
     * [['동물', '인간'], ['동물', '쥐'], ['식물', '피튜니아'], ['식물', '파리지옥'], ['균류', '푸른곰팡이'], ['균류', '송이버섯']]
     * ```
     */
    keys: string[] | string[][];
    /**
     * 값
     */
    values: string[];
}

/**
 * 메뉴 항목 관련 설정 정보 모델
 *
 * @deprecated
 * PopupMenuItem으로 변경
 *
 * @remarks
 * {@link PopupMenuItem} 형식을 이용하여 생성한 객체를 {@link GridBase.onMenuItemClicked} 와 {@link GridBase.onContextMenuItemClicked} 으로 콜백을 지정할 때 매개변수로 사용된다.
 *
 * 또는 {@link GridBase.addPopupMenu} 사용 시  {@link PopupMenuItem.callback | callback} 의 매개변수 중 `menuItem`의 형식이다.
 *
 * @example
 * ```js
 * gridView.addPopupMenu("menu1", [
 *         {
 *              label: "alpha",
 *              callback: function(grid, menuItem, index) {
 *                  console.log("aa")
 *                  console.log(menuItem); // 해당 형식의 객체
 *                  console.log(clickData);
 *              }
 *         },
 *         {label: "beta"},
 *         {label: "gamma"}
 * ]);
 * ```
 */
export declare interface MenuItem {
    /**
     * 메뉴 항목 형태
     */
    type: MenuItemType;
    /**
     * 표시 여부
     */
    visible: boolean;
    /**
     * 클릭 가능 여부
     */
    enabled: boolean;
    /**
     * 메뉴에 표시될 명칭
     */
    label: string;
    /**
     * 메뉴의 그룹, type이 "radio"일때 동일 그룹내에서 하나만 선택
     */
    group: string;
    /**
     * type이 "check"나 "radio"일때 체크 여부
     */
    checked: boolean;
    /**
     * 태그
     */
    tag: any;
    /**
     * 클릭 했을 때 호출되는 콜백
     * @eventProperty
     */
    callback: MenuItemClick;
    /**
     * 부모: MenuItem 객체
     */
    parent: PopupMenu;
}

/**
 * 메뉴 아이템을 클릭 시 호출되는 콜백
 *
 * @remarks
 * {@link GridBase.onMenuItemClicked} 와 {@link GridBase.onContextMenuItemClicked}, {@link PopupMenuItem | PopupMenuItem.callback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * grid - GridBase 컨트롤
 *
 * menuItem - MenuItem 객체
 *
 * clickData - 클릭된 아이템의 정보
 *
 * @example
 * ```js
 * grid.addPopupMenu("menu1", [
 *         {
 *              label: "alpha",
 *              callback: function(grid, menuItem, clickData) {
 *                  console.log("aa")
 *                  console.log(menuItem);
 *                  console.log(clickData);
 *              }
 *         },
 *         {label: "beta"},
 *         {label: "gamma"}
 * ]);
 * ```
 */
export declare type MenuItemClick = (grid: GridBase, menuItem: PopupMenuItem, clickData: ClickData) => void;

/**
 * @public
 *
 * PopupMenu 등에 표시되는 메뉴 항목의 유형
 *
 * @remarks
 * {@link PopupMenuItem."type"} 과 {@link MenuItem."type"} 에서 사용된다.
 *
 * @example
 * ```js
 * let menu = [{
 *      label: "menu3 입니다",
 *      type: "check",
 *      checked: true,
 *  }]
 * ```
 */
export declare enum MenuItemType {
    /**
     * 일반 텍스트
     */
    NORMAL = "normal",
    /**
     * 체크박스와 텍스트
     */
    CHECK = "check",
    /**
     * 라디오 버튼과 텍스트
     */
    RADIO = "radio",
    /**
     * 메뉴 항목 간 구분
     */
    SEPARATOR = "separator"
}

/**
 * 모바일 관련 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setMobileOptions({longTapDuration: 300});
 * ```
 */
export declare interface MobileOptions {
    /**
     * 롱 탭으로 인식하기 위한 최소 시간
     *
     * @defaultValue `500`
     */
    longTapDuration?: number;
    /**
     * 더블 탭이 발생하기 위한 탭 간 최대 시간
     *
     * @defaultValue `300`
     */
    doubleTapInterval?: number;
    /**
     * 탭 간 동일 탭으로 인지하는 영역범위
     *
     * @defaultValue `4`
     */
    tapThreshold?: number;
    /**
     * 편집 커맨더를 보여줄지에 대한 여부
     *
     * @defaultValue `true`
     */
    showEditCommander?: boolean;
    /**
     * 모바일에서 툴팁을 보여줄 건지에 대한 여부
     *
     * @remarks
     * 다른 툴팁 설정들이 `true`여야 한다.
     *
     * @defaultValue `false`
     */
    showTooltip?: boolean;
    /**
     *
     * @deprecated
     * {@link EditOptions.scrollOnEditing}으로 이동.
     *
     * 모바일에서 편집 중 일때 스크롤 시 처리
     *
     */
    scrollOnEditing?: ScrollOnEditing;
}

/**
 * @public
 * 드롭 다운 목록에서 여러 항목들을 선택할 수 있는 편집기
 *
 * @remarks
 * 셀에 저장되는 값의 각 value 를 구분하기 위한 구분자 지정은 편집기의 속성이 아닌 {@link DataColumn.valueSeparator | column.valueSeparator} 에서 지정하며 기본값은 ',' 이다.
 *
 * {@link DropDownCellEditor} 를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link CellEditor} - {@link TextCellEditor} - {@link DropDownCellEditor}
 *
 * @example
 *
 * ```js
 * // string type
 * column.editor = "checklist"
 *
 * // object type
 * column.editor = {
 *      type: "checklist",
 *      values: ["VINET", "TOMSP", "VICTE"],
 *      labels: ['label1', 'label2', 'label3'],
 *      displayLabels: "valueLabel",
 *      textReadOnly: true,
 *      showButtons: true
 * }
 * ```
 */
export declare interface MultiCheckCellEditor extends DropDownCellEditor {

    /**
     * 확인 / 취소 버튼 표시 여부
     *
     * @defaultValue `true`
     */
    showButtons?: boolean;
    /**
     * 확인 버튼 텍스트
     */
    acceptText?: string;
    /**
     * 취소 버튼 텍스트
     */
    cancelText?: string;
    /**
     * 모두 선택을 적용하는 버튼의 텍스트
     */
    allCheckText?: string;
    /**
     * 모두 선택 버튼의 표시 여부
     *
     * @defaultValue `false`
     */
    showAllCheck?: boolean;
}

/**
 * @public
 * 여러 줄 입력을 받을 수 있는 편집기
 *
 * {@link CellEditor} 를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link CellEditor}
 *
 * @example
 *
 * ```js
 * // string type
 * column.editor = "multiline"
 *
 * // object type
 * column.editor = { type: "multiline", maxLength: 50}
 * ```
 */
export declare interface MultiLineCellEditor extends CellEditor {

    /**
     * 입력할 수 있는 문자의 최대 길이
     *
     * @remarks
     * 0을 입력시에 제한이 없다.
     *
     */
    maxLength?: number;
    /**
     * editor의 최소높이.
     *
     * @defaultValue `0`
     */
    minHeight?: number;
    /**
     * editor의 높이
     *
     * @remarks
     * `0`인경우 높이를 입력된 내용에 맞춰 자동으로 조절한다.
     * `-1`인 경우 셀의 높이로 고정한다.
     * `0` 이상인 경우 입력된 높이로 고정한다.
     *
     * @defaultValue `0`
     */
    height?: number;
    /**
     * 강제개행을 하기위한 키 지정
     *
     * @remarks
     * `true`인 경우 ctrl + enter 는 무시되고 alt + enter 또는 shift + enter 로 강제 개행이 된다.
     *
     * `false`인 경우 ctrl + enter 로 강제 개행한다.
     *
     * @defaultValue `false`
     */
    altEnterNewLine?: boolean;
}

/**
 * @public
 * 숫자와 구두점 및 부호만을 입력할 수 있는 편집기
 *
 * @remarks
 *
 * {@link CellEditor} 를 상속한다.
 *
 * editFormat을 이용해서 입력시 천단위 기호를 표시하거나 소수점이하 자리를 제한할수 있다.
 *
 * [상위 클래스]
 *
 * {@link CellEditor}
 *
 * @example
 * ```js
 * // string type
 * column.editor = "number"
 *
 * // object type
 * column.editor = { type: "number", positiveOnly: true};
 *
 * // 정수만 입력
 * column.editor = {type:"number", editFormat:"#,##0"}
 *
 * // 소수점 2자리까지만 입력
 * column.editor = {type:"number", editFormat:"#,##0.00"}
 * ```
 */
export declare interface NumberCellEditor extends CellEditor {

    /**
     * 양수 값만 입력 허용 여부
     *
     * @defaultValue `false`
     */
    positiveOnly?: boolean;
    /**
     * 정수 값만 입력 허용 여부
     *
     * @defaultValue `false`
     */
    integerOnly?: boolean;
    /**
     * 입력되는 숫자의 서식
     *
     * @remarks
     * "#,##0.##" 을 지정하면 "1,234,567.89" 와 같이 천단위 구분기호 , 를 표시하면서 소수점은 2자리까지만 입력받는다.
     *
     * 일부 국가에서 사용되는 천단위 구분기호와 소수점이 반대인 경우 "#,##0.##;,;." 으로 지정한다.
     *
     * 화면에 표시되는 서식은 {@link ValueColumn.numberFormat}을 참조.
     *
     */
    editFormat?: string;
    /**
     * addString에 해당하는 문자 키
     */
    multipleChar?: string;
    /**
     * 입력 허용 가능 자리수
     *
     * @remarks
     * 0 이 입력되면 제한이 없다.
     */
    maxIntegerLength?: number;
    /**
     * multipleChar로 덧붙여지는 문자열
     *
     * @defaultValue `'000'`
     */
    addString?: string;
    /**
     * 콤마(,)를 제외하고 입력 최대 길이를 정할 것인지 여부
     */
    maxLengthExceptComma?: boolean;
    /**
     * 스페이스 바 키로 공백 입력을 허용할 것인지 여부
     *
     * @defaultValue `false`
     */
    blankWithSpace?: boolean;
    /**
     * step버튼을 표시할것인지 여부
     *
     * @defaultValue `false`
     */
    showStepButton?: boolean;
    /**
     * 버튼을 클릭했을때 더하거나 빼는 값을 입력한다.
     *
     * @defaultValue `1`
     */
    step?: number;
    /**
     * 버튼을 세로 또는 가로로 배열한다.
     *
     * @defaultValue `vertical`
     */
    direction?: string;
    /**
     * 최소값을 입력한다.
     *
     * @defaultValue `undefined`
     */
    min?: number;
    /**
     * 최대값을 입력한다.
     *
     * @defaultValue `undefined`
     */
    max?: number;
    /**
     * 버튼을 누르고 있는 동안 값이 변경되는 속도를 지정한다.
     *
     * @defaultValue `100ms`
     */
    delay?: number;
    /**
     * 키보드를 이용한 입력허용 여부
     *
     * @defaultValue `false`
     */
    textReadOnly?: boolean;
}

/**
 * number 필드 변환시 수행 될 콜백함수 형식
 *
 * @remarks
 * {@link DataOutputOptions.numberCallback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `ds` - DataProvider 컨트롤
 *
 * `row` - 아이템의 인덱스
 *
 * `field` - 필드명
 *
 * `value` - 값
 *
 * [반환값] - 출력할 값
 *
 * @example
 * ```js
 * const f = function(ds, row, field, value) {
 *      let v = Number(value);
 *      return v === NaN ? 42: v;
 * }
 * ```
 */
export declare type NumberOutputCallback = (ds: DataProviderBase, row: number, field: string, value: any) => number | any;

/**
 * @public
 * json형태의 data를 dataProvider에 입력할때 각 행별로 호출되는 콜백
 *
 * @remarks
 * 서버에서 전달된 data의 형태가 fields로 설정한 fieldName과 다르거나 value값을 임의로 변경할때 사용한다.
 *
 * @example
 * ```js
 * dataProvider.valuesCallback = function (ds, obj) {
 *     let row = [];
 *     if (obj) {
 *         for (let i = 0, cnt = this.fieldCount; i < cnt; i++) {
 *             let fld = this.getOrgFieldName(i);
 *             let fName = Object.keys(obj).find(function(key) {return key.toLowerCase() === fld.toLowerCase()})
 *             if (obj.hasOwnProperty(fName)) {
 *                 row[i] = obj[fName];
 *             }
 *         }
 *     }
 *     return row;
 * }
 * ```
 *
 */
export declare type ObjectToValuesCallback = (ds: DataProviderBase, obj: ConfigObject) => RowValues;

/**
 * @public
 * 암호를 입력하기 위한 편집기
 *
 * @remarks
 * 입력한 값들이 `*` 로 표시된다.
 *
 * {@link TextCellEditor} 를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link CellEditor} - {@link TextCellEditor}
 *
 * @example
 * ```js
 * // string type
 * column.editor = "password"
 *
 * // object type
 * column.editor = { type: "password", maxLength: 6}
 * ```
 */
export declare interface PasswordCellEditor extends TextCellEditor {
    /**
     * 셀편집기 종류: 암호
     */
    type?: 'password';
}

/**
 * 클립보드의 데이터를 그리드에 붙여넣는 것에 관한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setPasteOptions({enabled: false});
 * ```
 */
export declare interface PasteOptions {
    /**
     * 붙여넣기 가능 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
    /**
     * 클립보드의 내용과 상관없이 focus 된 셀 하나에만 값을 붙여 넣을지에 대한 여부
     */
    singleMode?: boolean;
    /**
     * 붙여넣기 할 때 편집 시작 여부
     *
     * @remarks
     * 붙여넣게 될 값이 복수 행이 아니고, 붙여넣을 행이 아직 편집 중이 아니면 편집을 시작한다.
     * `false` 면 이 행에 연결된 데이터 행을 업데이트한다.
     *
     * @defaultValue `true`
     */
    startEdit?: boolean;
    /**
     * 복수 행 붙여넣기일 때 기존 편집 상태 commit 여부
     *
     * @remarks
     * `false` 로 지정하면 기존 편집을 취소한다.
     *
     * @defaultValue `true`
     */
    commitEdit?: boolean;
    /**
     * 붙여 넣을 여러 행이 기존의 행의 범위를 넘어설 때 행 추가 여부
     *
     * @defaultValue `true`
     */
    enableAppend?: boolean;
    /**
     * 포함되지 않은 필드의 값을 데이터 필드의 기본값으로 채워 넣을지에 대한 여부
     *
     * @defaultValue false
     */
    fillFieldDefaults?: boolean;
    /**
     * 포함되지 않은 필드의 값을 컬럼의 기본값으로 채워 넣을지에 대한 여부
     *
     * @remarks
     * {@link PasteOptions.fillFieldDefaults | fillFieldDefaults} 가 true라면 데이터필드의 기본값을 먼저 적용한 후 컬럼 기본값을 적용한다.-active
     *
     * @defaultValue false
     */
    fillColumnDefaults?: boolean;
    /**
     * 복수 행 붙여 넣기 중 행별로 행 validation을 실행할 것인지의 여부
     *
     * @defaultValue false
     */
    forceRowValidation?: boolean;
    /**
     * 복수 행 붙여 넣기 중 행별로 컬럼 validation을 실행할 것인지의 여부
     *
     * @remarks
     * {@link PasteOptions.forceRowValidation | forceRowValidation} 이 `true`면 행 validation을 먼저 실행한다.
     *
     * @defaultValue `false`
     */
    forceColumnValidation?: boolean;
    /**
     * 데이터 필드에 지정된 datetimeFormat 외에 datetime 필드값으로 변환할 때 사용할 형식들
     *
     * @defaultValue `null`
     */
    datetimeFormats?: string[];
    /**
     * 데이터 필드에 지정된 booleanFormat 외에 boolean 필드값으로 변환할 때 사용할 형식
     *
     * @defaultValue `null`
     */
    booleanFormat?: string;
    /**
     * number 필드값으로 변환할 때 에러로 판단하지 않고 무시해도 되는 하나 이상의 문자열들
     *
     * @remarks
     * 지정한 문자열들을 모두 빈 문자열로 치환한 후 숫자로 변환한다.
     *
     * @defaultValue `null`
     */
    numberChars?: string[];
    /**
     * number 필드값으로 변환할 때 소수점으로 표시되는 문자
     *
     * @remarks
     * ex) `'.'`
     *
     * @defaultValue `null`
     */
    numberSeparator?: string;
    /**
     * 컬럼별로 number 필드값으로 변환할 때 에러로 판단하지 않고 무시해도 되는 하나 이상의 문자열들
     *
     * @remarks
     * ex) `{"column1": [",", "kr"], "column2": [" ", "$"]}`
     *
     * @defaultValue `{}`
     */
    numberCharsOfCols?: {
        [key: string]: string[];
    };
    /**
     * 컬럼별로 number 필드값으로 변환할 때 소수점으로 표시되는 문자
     *
     * @remarks
     * ex) `{"column1": ".", "column2": ","}`
     *
     * @defaultValue `null`
     */
    numberSeparatorOfCols?: {
        [key: string]: string;
    };
    /**
     * 붙여넣기 시작 위치
     *
     * @remarks
     * `true` 시 focus 셀이 포함된 선택 영역의 처음 셀부터 붙여넣기
     * `false` 시 focus 셀 부터 붙여넣기
     *
     * @defaultValue `false`
     */
    selectionBase?: boolean;
    /**
     * 여러 개 셀에 붙여넣기 가능 여부
     *
     * @remarks
     * 하나의 셀을 복사후 여러 개의 셀에 붙여넣기 할 수 있다.
     *
     * @defaultValue `false`
     */
    selectBlockPaste?: boolean;
    /**
     * Validation이 실패하거나 형변환이 실패 시 붙여넣기 중지 여부
     *
     * @remarks
     * `false` 시 계속 진행하되, 에러가 있는 행은 건너뛰고 붙여넣기한다.
     *
     * @defaultValue `false`
     */
    stopOnError?: boolean;
    /**
     * {@link GridBase.onEditRowChanged | onEditRowChanged }, {@link GridBase.onCellEdited | onCellEdited} 의 발생 여부
     *
     * @remarks
     * {@link GridBase.onEditRowPasted | onEditRowPasted } 는 지정여부와 상관없이 항상 발생
     *
     * @defaultValue `false`
     */
    noEditEvent?: boolean;
    /**
     * 여러 줄의 데이터 붙여넣기 도중 refresh 실행 여부
     *
     * @remarks
     * 붙여넣기를 하는 중에는 refresh되지 않아 속도가 개선된다.
     *
     * @defaultValue `false`
     */
    noDataEvent?: boolean;
    /**
     * 여러 행 붙여넣기 시 행 수 만큼 {@link GridBase.onEditRowPasted | onEditRowPasted } 이벤트의 발생 여부
     *
     * @defaultValue `false`
     */
    eventEachRow?: boolean;
    /**
     * readOnly이거나 editable이 `false`인 컬럼은 paste 대상에서 제외 여부
     *
     * @defaultValue `false`
     */
    checkReadOnly?: boolean;
    /**
     * DropDown Editor 의 domainOnly 가 `true`인 컬럼에 붙여넣기 할때 values 에 없는 값 붙여넣기 제외 여부
     *
     * @defaultValue `false`
     */
    checkDomainOnly?: boolean;
    /**
     * DropDown Editor 에 label값을 붙여넣는 경우 value 로 변환해서 저장할지의 여부
     *
     * @defaultValue `false`
     */
    convertLookupLabel?: boolean;
    /**
     * 붙여넣기 시 editFormat이 있으면 editFormat 형태로, 없으면 styles.numberFormat 형태로 붙여넣기 된다.
     *
     * @defaultValue `false`
     */
    applyNumberFormat?: boolean;
    /**
     * mask에 붙여넣을 수 없는 경우 붙여넣기 제한 여부
     *
     * @remarks
     * mask의 입력자리수보다 긴 경우 mask에 들어가는 자리를 제외하고 붙여넣기가 된다.
     *
     * @defaultValue `false`
     */
    applyEditMask?: boolean;
    /**
     * 붙여넣기 시 editor.maxLength, maxLengthExceptComma 적용 여부
     *
     * @defaultValue `false`
     */
    applyMaxLength?: boolean;
    /**
     * ValidationError 를 발생시킬지 여부
     *
     * @defaultValue `true`
     */
    throwValidationError?: boolean;
    /**
     * editor에 inputCharacters, ignoreCharacters 적용여부
     *
     * @defaultValue `false`
     */
    applyInputChars?: boolean;
}

/**
 * @public
 *
 * {@link ShapeCellRenderer} 에서 사용 가능한 도형 목록
 *
 * @example
 * ```js
 * column.renderer = {
 *     "type": "shape",
 *     "shape": "triangle" // PolygonShape
 * }
 * ```
 */
export declare enum PolygonShape {
    /**
     * 직사각형
     */
    RECTANGLE = "rectangle",
    /**
     * 삼각형
     */
    TRIANLGE = "triangle",
    /**
     * 역삼각형
     */
    INVERTED_TRIANLGE = "itriangle",
    /**
     * 다이아몬드
     */
    DIAMOND = "diamond",
    /**
     * 위를 향하는 화살표
     */
    UP_ARROW = "uparrow",
    /**
     * 아래를 향하는 화살표
     */
    DOWN_ARROW = "downarrow",
    /**
     * 왼쪽을 향하는 화살표
     */
    LEFT_ARROW = "leftarrow",
    /**
     * 오른쪽을 향하는 화살표
     */
    RIGHT_ARROW = "rightarrow",
    /**
     * 더하기 기호
     */
    PLUS = "plus",
    /**
     * 빼기 기호
     */
    MINUS = "minus",
    /**
     * 등호 기호
     */
    EQUAL = "equal",
    /**
     * 별 모양
     */
    STAR = "star"
}

/**
 * @public
 * 그리드에 등록되는 팝업 메뉴 또는 하위 메뉴의 설정 모델
 *
 * [상위 클래스]
 *
 * {@link PopupMenuBase}
 *
 *
 * @remarks
 * {@link GridBase.setContextMenu | setContextMenu} 또는 {@link GridBase.addPopupMenu | addPopupMenu}를 이용해서 등록한다.
 *
 * 마우스 오른쪽 버튼을 클릭하거나 버튼을 이용해서 표시한다.
 *
 *
 * @example
 * ```js
 *  let menu = [{
 *      name: "group1",
 *      label: "menu1 입니다.",
 *      children: [{
 *          name: "child1",
 *          label: "submenu1 입니다."
 *      }, {
 *          name: "child2",
 *          label: "submenu2 입니다."
 *      }]
 *  }, {
 *      name: "menu2",
 *      label: "menu2 입니다",
 *  }, {
 *      label: "-"
 *  }, {
 *      name: "check",
 *      label: "menu3 입니다",
 *      type: "check",
 *      checked: true,
 *      tag: "check_menu"
 *  }, {
 *      name: "radiogroup",
 *      label: "group menu",
 *      children: [{
 *          name: "radio1",
 *          label: "group1 - 첫번째",
 *          type: "radio",
 *          group: "group1",
 *          checked: true
 *      }, {
 *          name: "radio2",
 *          label: "group1 - 두번째",
 *          type: "radio",
 *          group: "group1"
 *      }, {
 *          name: "radio3",
 *          label: "group1 - 세번째",
 *          type: "radio",
 *          group: "group1"
 *      }]
 *  }];
 * ```
 */
export declare interface PopupMenu extends PopupMenuBase {
    /**
     * 하위 메뉴를 지정한다.
     */
    children: (PopupMenu | PopupMenuItem)[];
    /**
     * 하위 메뉴를 추가한다.
     */
    addMenu?: (src: (PopupMenu | PopupMenuItem)[], index?: number) => PopupMenu | PopupMenuItem;
    /**
     * 하위 메뉴를 제거한다.
     */
    removeMenu?: (name: string) => boolean;
    /**
     * 하위 메뉴를 가져온다.
     *
     * @remarks
     * 하위 메뉴의 속성을 변경할때 사용한다.
     * @example
     * ```js
     * const menu = grid.getPopupMenu('popup1');
     * const subMenu = menu.getMenu('menu1');
     * subMenu.enabled = false;
     * ```
     */
    getMenu?: (name: string) => PopupMenu | PopupMenuItem;
}

/**
 * @public
 * {@link PopupMenu}와 {@link PopupMenuItem} 의 기반 클랙스 이다.
 *
 * @remarks
 *
 * [하위 클래스]
 *
 * {@link PopupMenu}
 *
 * {@link PopupMenuItem}
 *
 */
export declare interface PopupMenuBase {
    /**
     * 메뉴의 이름
     */
    name?: string;
    /**
     * 메뉴에 표시되는 text
     * `-`로 입력하면 구분선으로 표시된다.
     */
    label: string;
    /**
     * 표시 여부
     *
     * @defaultValue `true`
     */
    visible?: boolean;
    /**
     * 활성화 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
    /**
     * 사용자가 임의값을 입력할수 있는 속성
     */
    tag?: any;
    /**
     * 사용자가 지정하는 className
     */
    styleName?: string;
}

/**
 * 마우스 오른쪽 클릭을 통해 표시되는 팝업 메뉴 아이템의 설정 모델
 *
 * {@link PopupMenu} 참조
 *
 * [상위 클래스]
 *
 * {@link PopupMenuBase}
 *
 */
export declare interface PopupMenuItem extends PopupMenuBase {
    /**
     * 메뉴 아이템의 유형
     *
     * @defaultValue {@link MenuItemType.NORMAL}
     */
    type?: MenuItemType;
    /**
     * 그룹 명
     * type이 `radio`인 경우 동일 그룹으로 묶을때 사용한다.
     */
    group?: string;
    /**
     * 체크 여부
     *
     * @remarks
     * {@link PopupMenuItem."type" | type} 이 {@link MenuItemType.CHECK | check} 또는 {@link MenuItemType.RADIO | radio} 일 때 활성화된다.
     */
    checked?: boolean;
    /**
     * 메뉴 아이템을 클릭했을 때 호출되는 콜백
     *
     * @eventProperty
     */
    callback?: MenuItemClick;
}

/**
 * {@link ExportBaseOptions | 그리드 내보내기 설정}에서 showProgress가 true일때 수행될 콜백을 지정하기 위한 형식
 *
 * @remarks
 * [매개변수 목록]
 * `grid` - 현재 export를 진행중인 grid, zip파일을 생성중인 경우 null이 전달된다.
 *
 * `work` - Grid가 엑셀을 생성하면서 호출되는 경우 `process`, zip파일을 생성하면서 호출되는 경우 `zip`이 전달된다. jsZIP이 generateAsync지원하는 경우 호출된다.
 *
 * `max` - maxPosition
 *
 * `position` - 현재 진행되고 있는 position
 */
export declare type ProgressCallback = (grid: GridBase, work: string, max: number, position: number) => any;

/**
 * RealGrid 메인 클래스
 *
 * @public
 */
declare class RealGrid {
    /**
     * 설치된 RealGrid 모듈의 version을 확인한다.
     *
     * @returns 설치된 RealGrid의 version을 반환.
     */
    static getVersion(): string;


    /**
     * 마지막으로 선택된 그리드를 반환한다.
     *
     * @remarks
     * 현재 선택된 element가 그리드가 아닌경우에도 마지막으로 선택된 그리드가 반환된다.
     *
     * @returns 그리드가 focus를 가진적이 없이면 `undefined`가 return 된다.
     */
    static getActiveGrid(): any;
    /**
     * 입력한 element가 가지고 있는 그리드를 반환한다.
     *
     * @param container - 그리드를 생성할때 사용한 elementID 또는 element
     *
     * @returns container에 그리드가 있는 경우 그리드를 반환한다.
     */
    static getGridInstance(container: string | HTMLDivElement): any;


    /**
     * @public
     * 그리드가 mobile모드로 생성되도록 한다.
     *
     * @remarks
     * 그리드가 브라우저의 mobile상태를 확인하지 못하는 경우 RealGrid.setMobile(true)을 이용해서 모바일 상태로 변경한다.
     * 그리드가 생성되기 전에 설정해야 한다.
     *
     * @param value - boolean
     */
    static setMobile(value: boolean): void;
    /**
     * @public
     * 그리드가 tablet모드로 생성되도록 한다.
     *
     * @remarks
     * 기기가 tablet인지 확인하지 못하는 경우 RealGrid.setTablet(true)을 이용해서 태블릿 상태로 변경한다.
     * 그리드가 생성되기 전에 설정해야 한다.
     *
     * @param value - boolean;
     */
    static setTablet(value: boolean): void;
    /**
     * GridView Class를 반환한다.
     * {@link GridView} 참조
     */
    static get GridView(): typeof GridView;
    /**
     * TreeView Class를 반환한다.
     * {@link TreeView} 참조
     */
    static get TreeView(): typeof TreeView;
    /**
     * LocalDataProvider Class를 반환한다.
     * {@link LocalDataProvider} 참조
     */
    static get LocalDataProvider(): typeof LocalDataProvider;
    /**
     * LocalTreeDataProvider Class를 반환한다.
     * {@link LocalTreeDataProvider} 참조
     */
    static get LocalTreeDataProvider(): typeof LocalTreeDataProvider;

}
export default RealGrid;

/**
 * {@link FormTemplateRenderer.valueCallback} 에 사용되는 콜백 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `form` - FormView 모델
 *
 * `item` - FormView 의 아이템
 *
 * `field` - 필드명
 *
 * [반환값] - string type 의 template 형식
 */
export declare type RealizeFormValueCallback = (form: any, item: any, field: string) => string;

/**
 * @public
 *
 * {@link ColumnHeader.templateCallback} 또는 {@link CellLayoutGroupHeader.templateCallback}에 사용되는 콜백 형식
 *
 * @remarks
 * 컬럼 헤더의 template에 입력한 field중 {@link ColumnObject.values | values}에 지정되지 않은 값을 가져올때 사용한다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `header` - 컬럼의 header 또는 그룹 Layout의 header
 *
 * `field` - 필드명
 *
 * [반환값] - string
 *
 * @example
 * ```js
 * const f = function (grid, model, field) {
 *      if (field == "field1") {
 *          return "1234";
 *      } else if (field === "field2") {
 *          return "ABCD";
 *      } else {
 *          return "field Fail";
 *      }
 * }
 *
 * column.header.template =
 *                "<img src='images/realgrid-logo.png' height='20'/>"+
 *                "<span style='color: red;font-weight: bold;'>${field1}</span>"+
 *                "<span style='color: blue'>${field2}</span>";
 * column.header.templateCallback = f;
 * ```
 */
export declare type RealizeHeaderCallback = (grid: GridBase, header: ColumnHeader | CellLayoutGroupHeader, field: string) => string;

/**
 * @public
 * {@link ColumnSummary.templateCallback}에서 사용되는 콜백 형식
 *
 * @remarks
 * {@link ColumnFooter}, {@link HeaderSummary}, {@link GridColumn.groupFooter | GroupFooter}의 template에 입력한 field중 {@link ColumnObject.values | values}에 지정되지 않은 값을 가져올때 사용한다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `column` - footer의 column
 *
 * `summaryIndex` - footer의 순번
 *
 * `summary` - `footer`객체 또는 `groupFooter`인 경우 {@link GroupItem}
 *
 * `field` - 필드명
 *
 * [반환값] - string
 *
 * @example
 * ```js
 * const f = function (grid, column, summaryIndex, summary, field) {
 *      if (field == "field1") {
 *          return "1234";
 *      } else if (field === "field2") {
 *          return "ABCD";
 *      } else {
 *          return "field Fail";
 *      }
 * }
 *
 * column.footer.template =
 *                "<img src='images/realgrid-logo.png' height='20'/>"+
 *                "<span style='color: red;font-weight: bold;'>${field1}</span>"+
 *                "<span style='color: blue'>${field2}</span>";
 * column.footer.templateCallback = f;
 * ```
 */
export declare type RealizeSummaryCallback = (grid: GridBase, column: GridColumn, summaryIndex: number, summary: ColumnSummary | GroupItem, field: string) => string;

/**
 * {@link TemplateCellRenderer.valueCallback} 에 사용되는 콜백 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `model` - 그리드의 셀
 *
 * `field` - 필드명
 *
 * [반환값] - string type 의 template 형식
 *
 * @example
 * ```js
 * const f = function (grid, model, field) {
 *      if (field == "xxx") {
 *          return "1234";
 *      }
 * }
 *
 * column.renderer = {
 *      type: "html",
 *      template: "<img src='images/realgrid-logo.png' height='20'/>"+
 *                "<span>${value}-${value:unitprice}-</span>"+
 *                "<span style='color: red;font-weight: bold;'>${xxx}</span>"+
 *                "<span style='color: blue'>${value:Country}</span>",
 *      valueCallback: f
 * ```
 */
export declare type RealizeValueCallback = (grid: GridBase, model: GridCell, field: string) => string;

/**
 * @public
 *
 * 그리드를 다시 그릴 때 필요한 상수
 *
 * @remarks
 * {@link DisplayOptions.refreshMode} 에서 사용한다.
 *
 * @example
 * ```js
 * grid.displayOptions.refreshMode = 'visibleOnly';
 * ```
 */
export declare enum RefreshMode {
    /**
     * 모든 컬럼들을 다시 그리기
     */
    ALL = "all",
    /**
     * 보이는 컬럼들만 다시 그리기
     */
    VISIBLE_ONLY = "visibleOnly"
}

/**
 * @public
 *
 * 사용자 지정 렌더러의 편집 완료 결과 모델
 *
 * @remarks
 * {@link CustomCellRenderer.editClick} 에서 반환되어야 한다.
 */
export declare interface RendererEditResult {
    /**
     * 커밋 여부
     *
     * @defaultValue `true`
     */
    commit: boolean;
    /**
     * 수정된 값
     */
    value: any;
}

/**
 * 복원 모드 종류
 */
export declare enum RestoreMode {
    /**
     * 복원 모드를 설정하지 않는다.
     */
    NONE = "none",
    /**
     * 명시적으로 {@link DataProviderBase.restoreUpdatedRows | restoreUpdatedRows()}를 사용했을 경우에만 RowState 와 값이 변경된다.
     */
    EXPLICIT = "explicit",
    /**
     * 원래 값으로 다시 수정만 하면 RowState 도 다시 원상태로 돌아온다.
     */
    AUTO = "auto"
}

/**
 * @public
 * RowBar영역의 셀 스타일을 지정하기 위한 콜백
 *
 * @remarks
 * {@link CheckBar.cellStyleCallback}에서 사용되는 형식이다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨트롤
 *
 * `type` - {@link GridCellType} 중 `check`, `indicator`, `state` 중 하나
 *
 * `index` - 셀의 itemIndex
 *
 * @example
 * ```js
 * var f = function(grid, type, index) {
 *  if (grid.getValue(index, "field") === "TEST") {
 *    return 'style-test';
 *  }
 * }
 * ```
 */
export declare type RowBarCellStyleCallback = (grid: GridBase, type: GridCellType, index: number) => string;

/**
 * row block 마스크를 설정하기 위한 콜백
 *
 * @remarks
 *
 * {@link DisplayOptions.rowBlockCallback} 에서 사용된다.
 * {@link DisplayOptions.rowBlockType} 이 {@link RowMaskType.NONE} 이면 반영되지 않는다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `itemIndex` - 선택 된 행의 인덱스
 *
 * [반환값] - Row Block Mask 를 적용시킬 행의 범위, `start`: 시작 행, `end`: 끝 행
 *
 * @example
 * ```js
 * const f = function(grid, itemIndex) {
 *     let billNo;
 *     let ds = grid.getDataSource();
 *     let fld = ds.getFieldIndex("text1");
 *     let dataRow = grid.getDataRow(itemIndex);
 *     if (dataRow >= 0) {
 *         billNo = ds.getValue(dataRow, fld);
 *     } else {
 *         billNo = null;
 *     }
 *
 *     let top = Math.min(grid.getTopItem(), itemIndex);
 *     let full = top + grid.fullItemCount();
 *     let startNo = top + full;
 *     let endNo = -1;
 *     let check1 = false;
 *
 *     for (let i = top; i <= full; i++) {
 *         dataRow = grid.getDataRow(i);
 *         if (dataRow < 0) {
 *             continue;
 *         }
 *
 *         let cBillNo = ds.getValue(dataRow, fld);
 *
 *         if (cBillNo === billNo) {
 *             startNo = Math.min(startNo, i), endNo = Math.max(endNo, i);
 *             check1 = true;
 *         } else {
 *             if (check1) {
 *                 break;
 *             }
 *         }
 *     };
 *
 *     if (startNo <= endNo && endNo > 0) {
 *         console.log(startNo)
 *         console.log(endNo);
 *         return { start: startNo, end: endNo };
 *     }
 * }
 * ```
 */
export declare type RowBlockCallback = (grid: GridBase, itemIndex: number) => {
    start: number;
    end: number;
};

/**
 * 행 그룹핑과 관련된 영역들의 표시 방법 등에 대한 설정 모델
 *
 * @remarks
 * {@link GridView.setRowGroup} 사용시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setRowGroup({levelIndent: false});
 * ```
 */
export declare interface RowGroup {
    /**
     * 그룹핑 된 컬럼의 머지 표현 여부
     *
     * @defaultValue `false`
     */
    mergeMode?: boolean;
    /**
     * 자동 정렬 여부
     *
     * @remarks
     * `false`로 설정하면 행 그룹 시 자동으로 정렬되지 않고 그리드에 표시된 데이터의 순서대로 행 그룹핑 된다.
     */
    sorting?: boolean;
    /**
     * 행 그룹이 펼쳐진 상태일 때, 그룹 헤더, 푸터의 표시 여부
     *
     * @defaultValue {@link RowGroupAdornments.BOTH}
     */
    expandedAdornments?: RowGroupAdornments;
    /**
     * 행 그룹이 접힌 상태일 때, 그룹 헤더, 푸터의 표시 여부
     *
     * @defaultValue {@link RowGroupAdornments.HEADER}
     */
    collapsedAdornments?: RowGroupAdornments;
    /**
     * 특정 그룹 푸터의 표시 여부를 지정하기 위한 콜백
     *
     * @remarks
     * {@link RowGroup.mergeMode } 가 `true` 인 경우 일부 그룹 푸터의 표시여부를 지정할 수 있다.
     * 표시하길 원하는 경우 `true` 값을 반환한다.
     *
     * @eventProperty
     */
    createFooterCallback?: CreateFooterCallback;
    /**
     * 그룹 레벨 간 들여쓰기 여백
     *
     * @defaultValue `20`
     */
    levelIndent?: number;


    /**
     * expander 표시 여부
     * @defaultValue {@link ExpanderVisibility.DEFAULT}
     * @deprecated
     * expanderVisibility로 대체.
     */
    mergeExpanderVisibility?: ExpanderVisibility;
    /**
     * expander 표시 여부
     * @defaultValue {@link ExpanderVisibility.DEFAULT}
     */
    expanderVisibility?: ExpanderVisibility;
    /**
     * expander 표시여부를 결정하는 콜백
     *
     * @eventProperty
     */
    expanderVisibleCallback?: ExpanderVisibleCallback;
    /**
     * 헤더에 표시할 문자열 서식
     * @defaultValue `'${groupField}: ${groupValue} - ${rowCount} rows'`
     */
    headerStatement?: string;
    /**
     * 헤더에 표시할 문자열을 return하는 콜백
     * @remarks
     * {@link RowGroup.headerStatement}가 있는 경우 무시된다.
     *
     * @eventProperty
     */
    headerCallback?: HeaderCallback;
    /**
     * 컬럼의 값이 아닌 다른 값으로 그룹을 만들때 사용하는 콜백
     * {@link RowGroup.mergeMode}에서는 사용할수 없다.
     *
     * @remarks
     * 컬럼의 일부 값 또는 다른 컬럼과 조합해서 그룹을 만드는 경우 사용한다.
     * 데이터를 정렬한후 콜백이 호출되기 때문에 별도의 정렬이 필요하다면 {@link DataProviderBase.setDataComparer | 사용자 정의 정렬 함수}를 이용해서 정렬을 한다.
     *
     * @eventProperty
     */
    valueForGroupCallback?: ValueForGroupCallback;
    /**
     * 로우그룹 푸터의 갯수와 style등을 지정한다.
     * @param footers - {@link RowGroupFooter} 또는 배열
     */
    setFooters?(footers: RowGroupFooter | RowGroupFooter[]): void;
}

/**
 * @public
 *
 * 행 그룹 상태일 때 헤더나 푸터의 표시 방법
 *
 * @remarks
 * {@link RowGroup.collapsedAdornments}, {@link RowGroup.expandedAdornments} 에서 사용된다.
 *
 * @example
 *
 * ```js
 * grid.setRowGroup({expandedAdornments: "none"});
 * ```
 */
export declare enum RowGroupAdornments {
    /**
     * 표시 안 함, expandedAdornments 상태에서만 적용 가능하다.
     */
    NONE = "none",
    /**
     * 행 그룹 상태일 때 헤더 표시
     */
    HEADER = "header",
    /**
     * 행 그룹 상태일 때 푸터 표시
     */
    FOOTER = "footer",
    /**
     * 행 그룹 상태일 때 summary의 내용을 헤더 위치에 표시
     */
    SUMMARY = "summary",
    /**
     * 행 그룹 상태일 때 헤더와 푸터 둘 다 표시, expandedAdornments 상태에서만 적용
     */
    BOTH = "both"
}

/**
 * 그리드 그룹푸터 모델
 */
export declare interface RowGroupFooter {
    /**
     * 그룹 푸터 행에 적용되는 스타일 클래스명
     */
    styleName?: string;
    /**
     * excel로 export할때 적용될 스타일 명
     */
    exportStyleName?: string;
    /**
     * 스타일을 지정하기 위한 콜백
     *
     * @remarks
     * {@link GroupFooterStyleCallback} 참조
     *
     * @eventProperty
     */
    styleCallback?: GroupFooterStyleCallback;
    /**
     * 그룹 푸터의 컬럼별로 적용되는 스타일을 지정하기 위한 콜백
     *
     * @remarks
     * {@link CellStyleCallback} 참조
     *
     * * @eventProperty
     */
    cellStyleCallback?: CellStyleCallback;
}

/**
 * @public
 *
 * 그리드 그룹 푸터 영역에 관한 콜렉션 모델
 *
 * @remarks
 *
 * 그리드의 그룹 푸터를 생성하고 관리한다.
 *
 * @example
 * ```js
 * gridView.rowGroup.setFooters([
 *      {
 *          styleName: 'group-footer-1'
 *      }, {
 *          styleName: 'group-footer-2'
 *      }
 * ])
 * ```
 */
export declare interface RowGroupFooterCollection {
    /**
     * 표시되는 푸터의 갯수
     */
    readonly count: number;
    /**
     * 그룹 푸터의 아이템들
     */
    items?: RowGroupFooter[];
    /**
     * 지정된 index의 그룹 푸터를 가져온다.
     *
     * @param index - 푸터의 index
     */
    get(index: number): RowGroupFooter;
}

/**
 *
 * 행의 높이를 반환하는 콜백형식
 *
 * @remarks
 * number 또는 number[]형태로 행의 높이를 지정한다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `type` - row의 {@link ItemType | type}
 *
 * `itemIndex` - row의 itemIndex
 *
 * [반환값] - 행의 높이, 여러줄로 이루어진 행의 경우 배열로 반환하면 각각 지정된다.
 */
export declare type RowHeightCallback = (grid: GridBase, type: ItemType, itemIndex: number) => number | number[];

/**
 * 그리드의 인디케이터에 관한 설정 모델
 *
 * @remarks
 * 인디케이터는 행 index를 표시하거나, focus 된 행의 위치 등을 표시한다.
 *
 * {@link GridBase.setRowIndicator} 사용시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setRowIndicator({zeroBase: true});
 * ```
 */
export declare interface RowIndicator {
    /**
     * 인디케이터 셀들에 표시할 내용
     *
     * @defaultValue {@link IndicatorValue.INDEX}
     */
    displayValue?: IndicatorValue;
    /**
     * 인디케이터 숫자가 0부터 시작할 것인지의 여부
     *
     * @defaultValue `false`
     */
    zeroBase?: boolean;
    /**
     * 인디케이터에 표시될 숫자와 아이템 인덱스(행 순서)와의 간격
     *
     * @remarks
     * 인디케이터 숫자 = 아이템 인덱스 + indexOffset
     *
     * @defaultValue `0`
     */
    indexOffset?: number;
    /**
     * 인디케이터에 표시될 숫자와 데이터 행 고유번호와의 간격을 지정
     *
     * @remarks
     * 인디케이터 숫자 = 데이터 행 번호 + rowOffset
     *
     * @defaultValue `0`
     */
    rowOffset?: number;
    /**
     * 최소 너비
     *
     * @defaultValue `32`
     */
    minWidth?: number;
    /**
     * 최대 너비
     *
     * @defaultValue `0`
     */
    maxWidth?: number;
    /**
     * 너비
     *
     * @remarks
     * `0`인경우 표시되는 내용에 따라 너비가 변경된다.
     *
     * @defaultValue `0`
     *
     */
    width?: number;
    /**
     * 실제 표시되는 너비
     *
     * @remarks
     * `width`가 0일때 rowIndicator의 너비
     */
    displayWidth?: number;
    /**
     * 마우스로 클릭 혹은 드래그 시 선택 영역 지정 가능 여부
     *
     * @remarks
     * {@link DisplayOptions.selectionMode} 가 {@link SelectionMode.NONE} 이 아니고, {@link DisplayOptions.selectionStyle} 이 {@link SelectionStyle | single selection style} 이 아니어야 선택 영역 지정이 가능하다.
     *
     * @defaultValue `true`
     */
    selectable?: boolean;
    /**
     * 인디케이터에 표시되는 상태의 형태
     *
     * @defaultValue {@link StateMark.IMAGE}
     */
    mark?: StateMark;
    /**
     * focus 된 행에 해당하는 셀의 스타일 적용여부 여부
     *
     * @remarks
     * `true`면 focus 된 행에 해당하는 셀을 `'rg-rowindicator-focus'` 스타일로 표시한다.
     *
     * @defaultValue `true`
     */
    showFocus?: boolean;
    /**
     * 데이터 선택 영역에 맞춰 관련된 셀들의 스타일 적용 여부
     *
     * @remarks
     * `true`면 데이터 선택 영역에 맞춰 관련된 셀들을 `'rg-rowindicator-select'` 스타일로 표시한다.
     *
     * @defaultValue `false`
     */
    showSelection?: boolean;
    /**
     * 체크바, 상태바, 인디케이터 중에서 보여지는 순서 (인덱스)
     *
     * @remarks
     * 숫자가 작을 수록 왼쪽에 배치된다.
     */
    displayOrder?: number;
    /**
     * head 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    headText?: string;
    /**
     * foot 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    footText?: string;
    /**
     * summary 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    sumText?: string;
    /**
     * 팝업 메뉴
     */
    popupMenu?: PopupMenuItem[] | string;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * 셀의 스타일을 지정하기 위한 콜백
     */
    cellStyleCallback?: RowBarCellStyleCallback;
}

/**
 * @public
 *
 * 선택 된 행의 표시 형태 (행의 마스크 종류)
 *
 * @remarks
 * {@link DisplayOptions.rowBlockType | rowBlockType}, {@link DisplayOptions.rowHoverType | rowHoverType}, {@link DisplayOptions.rowFocusType | rowFocusType} 등에서 사용된다.
 *
 * @example
 *
 * ```js
 * grid.displayOptions.rowBlockCallback = f;
 * grid.displayOptions.rowBlockType = 'row';
 * ```
 */
export declare enum RowMaskType {
    /**
     * 없음
     */
    NONE = "none",
    /**
     * 인디케이터, 상태바, 체크바, 컬럼을 포함한 영역
     */
    ROW = "row",
    /**
     * 컬럼 영역
     */
    DATA = "data",
    /**
     * 인디케이터, 상태바, 체크바, 컬럼을 포함한 영역 + 빈 영역
     */
    FILL = "fill",
    /**
     * 하나의 셀
     */
    CELL = "cell"
}

/**
 * 행 오브젝트
 *
 * @remarks
 * {@link DataValues} 의 형식 중 하나
 */
export declare type RowObject = {
    [key: string]: any;
};

/**
 * 행의 상태
 */
export declare enum RowState {
    /**
     * 아무것도 아님
     */
    NONE = "none",
    /**
     * 생성됨
     */
    CREATED = "created",
    /**
     * 업데이트됨
     */
    UPDATED = "updated",
    /**
     * 삭제됨
     */
    DELETED = "deleted",
    /**
     * 생성 후 삭제됨
     */
    CREATE_AND_DELETED = "createAndDeleted"
}

/**
 * 행 상태의 따른 행들의 목록
 *
 * @remarks
 * {@link DataProviderBase.getAllStateRows} 로 해당 모델을 반환할 수 있다.
 */
export declare interface RowStateList {
    /**
     * 생성된 행의 index 들
     */
    created?: number[];
    /**
     * 생성되었다 삭제된 행의 index 들
     */
    createAndDeleted?: number[];
    /**
     * 삭제된 행의 index 들
     */
    deleted?: number[];
    /**
     * 갱신 된 행의 index 들
     */
    updated?: number[];
}

/**
 * 행 스타일 변경을 위한 콜백
 *
 * @remarks
 * 스타일 클래스 명을 반환해야한다.
 *
 * {@link GridBase.setRowStyleCallback} 에서 쓰인다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `item` - 행 아이템
 *
 * `fixed` - 고정행 여부
 *
 * [반환값] - 스타일 클래스 명 또는 {@link RowStyleObject} 객체
 *
 * @example
 * ```js
 * const f = function(grid, item, fixed) {
 *      if (fixed) {
 *          return 'custom-fixed-row';
 *      }
 *      else if (item.isDataRow) {
 *          var val =
 *          return 'custom-data-row';
 *      }
 * }
 * gridView.setRowStyleCallback(f)
 * ```
 */
export declare type RowStyleCallback = (grid: GridBase, item: GridItem, fixed: boolean) => string | RowStyleObject;

/**
 * {@link RowStyleCallback} 으로 행의 스타이을 변경시 반환되는 스타일 모델
 *
 * @remarks
 * {@link GridBase.setRowStyleCallback}에서 사용된다.
 *
 * @example
 * ```js
 * cosnt f = function(grid, item fixed) {
 *   if (dataProvider.getValue(item.dataRow, "fieldName") === "value") {
 *     return {
 *       editable: false,
 *       styleName: "userStyleName"
 *     }
 *   }
 * }
 * gridView.setRowStyleCallback(f);
 * ```
 */
export declare interface RowStyleObject {
    /**
     * 행전체의 editable 여부
     *
     * @remarks
     * 지정하지않으면 다음 순위의 editable이 적용된다.
     */
    editable?: boolean;
    /**
     * 행전체의 readOnly여부
     * @remarks
     * 지정하지않으면 다음 순위의 editable이 적용된다.
     */
    readOnly?: boolean;
    /**
     * 행의 className
     * @remarks
     * 지정하지 않으면 그리드의 기본 스타일명이 사용된다.
     */
    styleName?: string;
    /**
     * excel로 export할때 적용되는 스타일 명
     */
    exportStyleName?: string;
    /**
     * 행의 tr element에 적용되는 inline style
     *
     * @remarks
     * tr의 style에 직접 적용되는 속성들을 지정한다.
     *
     * @example
     * ```js
     * const f = function(grid, item, fixed) {
     *   var ret = { style: {background:undefined, color: undefined}}
     *   if (dataProvider.getValue(item.dataRow, "fieldName") === "A") {
     *     ret.style.background = "red";
     *   } else if (dataProvider.getValue(item.dataRow, "fieldName") === "B") {
     *     ret.style.color = "red";
     *   } else if (dataProvider.getValue(item.dataRow, "fieldName") === "C") {
     *     ret.style.background = "lightblue"
     *     ret.style.color = "red";
     *   };
     *   return ret;
     * }
     * ```
     */
    style?: ConfigObject;
}

/**
 * 행 데이터
 *
 * @remarks
 * {@link DataValues} 의 형식 중 하나
 */
export declare type RowValues = any[];

declare enum ScrollEventType {
    LINE = "line",
    PAGE = "page",
    THUMB_TRACK = "thumbTrack",
    THUMB_END = "thumbEnd",
    SCROLL_END = "scrollEnd"
}

/**
 * livescroll 을 미적용 할 때 스크롤 위치를 알려주는 화면에 표시되는 메시지를 반환하는 콜백 형식
 *
 * @remarks
 * {@link DisplayOptions.scrollMessageCallback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `isVertical` - 수직 스크롤 여부
 *
 * `itemIndex` - 스크롤 위치에 있는 아이템의 인덱스
 *
 * [반환값] - 화면에 표시되는 메시지의 텍스트
 *
 * @example
 * ```js
 * const f = function(grid, vertical, itemIndex) {
 *     let msg = grid.getValue(itemIndex, "area3name");
 *     return "<span style='color:blue;font-size:20px'>itemIndex = " + msg+"</span>";
 * }
 * ```
 */
export declare type ScrollMessageCallback = (grid: GridBase, isVertical: boolean, itemIndex: number) => string;

/**
 * @public
 *
 * 편집 중 일때 스크롤 시 처리 상태
 *
 * @remarks
 * {@link EditOptions.scrollOnEditing} 에서 설정 가능하다.
 *
 * @example
 * ```js
 * grid.editOptions.scrollOnEditing = 'cancel';
 * ```
 */
export declare enum ScrollOnEditing {
    /**
     * 편집 취소
     */
    CANCEL = "cancel",
    /**
     * 커밋
     */
    COMMIT = "commit",
    /**
     * 편집기 유지
     */
    DEFAULT = "default"
}

/**
 * @public
 * 검색 기능이 추가 된 {@link DropDownCellEditor | 드롭 다운 편집기}
 *
 * @remarks
 * {@link DropDownCellEditor} 를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link CellEditor} - {@link TextCellEditor} - {@link DropDownCellEditor}
 *
 * @example
 *
 * ```js
 * // string type
 * column.editor = "search"
 *
 * // object type
 * column.editor = {
 *      type: "search",
 *      values: ["VINET", "TOMSP", "VICTE"],
 *      labels: ['label1', 'label2', 'label3'],
 *      displayLabels: "valueLabel",
 *      textReadOnly: true,
 *      searchLength: 3
 * }
 * ```
 */
export declare interface SearchCellEditor extends DropDownCellEditor {

    /**
     * 검색 시작에 필요한 최소 글자수
     *
     * @defaultValue `1`
     */
    searchLength?: number;
    /**
     * 지막 키 입력이 완료된 후 검색이 시작될때까지의 시간 (ms, 밀리세컨드)
     *
     * @defaultValue `1000`
     */
    searchDelay?: number;
    /**
     * searchLength, searchDelay 와 관계없이 Ctrl+Enter 키 입력으로 즉시 {@link GridBase.onEditSearch | onEditSearch} 이벤트 발생 여부
     *
     * @defaultValue `false`
     */
    useCtrlEnterKey?: boolean;
    /**
     * searchLength, searchDelay 와 관계없이 Enter 키 입력으로 즉시 {@link GridBase.onEditSearch | onEditSearch} 이벤트 발생 여부
     *
     * @remarks
     * 목록이 비어 있는 경우만 동작한다.
     *
     * @defaultValue `false`
     */
    useEnterKey?: boolean;
    /**
     * 처음에 보여줄 건수
     *
     * @remarks
     * 0 일 경우 전부 보여준다.
     *
     * @defaultValue `0`
     */
    initCount?: number;
    /**
     * 더보기 버튼을 클릭하였을 때 보여줄 건수
     *
     * @defaultValue `25`
     */
    moreItemCount?: number;
    /**
     * 더보기 버튼에 표시되는 텍스트
     */
    moreText?: string;
    /**
     * 키 입력 시 재조회 여부
     *
     * @defaultValue `false`
     */
    reInquiry?: boolean;
}

/**
 * 셀 검색 관련 유연한 설정 모델
 *
 * @remarks
 * {@link GridBase.searchCell} 에서 사용된다.
 *
 * @example
 * ```js
 * function searchCellHandler() {
 *     let value = "PR20012392"
 *     let fields = [ "RequestType", "ServiceCode" ];
 *     let startFieldIndex = fields.indexOf(grid.getCurrent().fieldName) + 1;
 *     let options = {
 *          fields : fields,
 *          value : value,
 *          startIndex : grid.getCurrent().itemIndex,
 *          startFieldIndex : startFieldIndex,
 *          wrap : true,
 *          caseSensitive : false,
 *          partialMatch : true
 *     }
 *     let index = grid.searchCell(options);
 *     grid.setCurrent(index);
 * }
 * ```
 */
export declare interface SearchCellOptions {
    /**
     * 검색할 필드 목록
     *
     * @remarks
     * 필드명 또는 필드 인덱스로 지정 가능
     */
    fields?: string[];
    /**
     * 지정한 검색 조건값
     */
    value?: string;
    /**
     * 검색 시작 행
     *
     * @defaultValue `0`
     */
    startIndex?: number;
    /**
     * fields 배열에서 검색을 시작할 필드의 인덱스
     *
     * @remarks
     * let fields = ["a", "b", "c", "d"]; const startFieldIndex = 2 인 경우 "c" 필드부터 검색을 시작한다.
     *
     * @defaultValue `0`
     */
    startFieldIndex?: number;
    /**
     * 마지막 행까지 해당하는 행이 없으면 첫 행부터 다시 검색할 것인지 여부
     *
     * @defaultValue `true`
     */
    wrap?: boolean;
    /**
     * 검색된 행 선택여부
     *
     * @remarks
     * `true`로 지정하면 검색된 행이 있을 때 그 행을 선택하고, 현재 표시된 범위 밖이면 표시되도록 스크롤한다.
     *
     * @defaultValue `true`
     */
    select?: boolean;
    /**
     * 대소문자를 구분하여 검색할지의 여부
     *
     * @defaultValue `false`
     */
    caseSensitive?: boolean;
    /**
     * 포함되는 것도 검색할지 여부
     *
     * @defaultValue `false`
     */
    partialMatch?: boolean;
    /**
     * 필드와 컬럼들 순서가 다를 때 지정하는 컬럼들의 배열
     *
     * @remarks
     * 이곳에 지정한 순서대로 검색이 수행된다.
     * 이 속성 사용시 {@link SearchCellOptions.fields} 는 사용하지 않는다.
     */
    columns?: string[];
    /**
     * 사용자 정의 조건을 위한 콜백
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * const f = function(v1, v2, sensitive, partialMatch) {
     *      if (v1 === v2) {
     *           return true;
     *      }
     *      let s1 = String(v1);
     *      let s2 = v2 == null ? undefined : String(v2);
     *      if (!s1 && !s2) {
     *           return true;
     *      }
     *      if (!s1 || !s2) {
     *           return false;
     *      }
     *      if (!caseSensitive) {
     *           s1 = s1.toLowerCase();
     *           s2 = s2.toLowerCase();
     *      }
     *      if (partialMatch) {
     *      	    return s2.indexOf(s1) >= 0;
     *      } else {
     *      	    return s1 == s2;
     *      }
     * }
     *
     * let options = {
     *          fields : fields,
     *          value : value,
     *          compareCallback: f
     * }
     *
     * let index = grid.searchCell(options);
     * ```
     */
    compareCallback?: CompareCallback;
    /**
     * 상위트리의 행 고유 번호
     * {@link LocalTreeDataProvider.searchData | LocalTreeDataProvider} 에서만 사용 가능하다.
     */
    parentId?: number;
    /**
     * 역순 검색
     *
     * @remarks
     * startFieldIndex를 기준으로 역순으로 검색하고 없는 경우 startIndex의 윗행을 검색한다.
     * startIndex가 지정되지 않으면 마지막 행부터 검색한다.
     *
     * @defaultValue `false`
     */
    reverse?: boolean;
}

/**
 * @public
 *
 * 검색된 셀의 위치정보
 *
 * @remarks
 * {@link GridBase.searchCell} 또는 {@link LocalDataProvider.searchData} / {@link LocalTreeDataProvider.searchData} 에서 사용한다.
 */
export declare interface SearchCellResult {
    /**
     * 행 고유 번호
     */
    dataRow: number;
    /**
     * 필드 인덱스
     */
    fieldIndex: number;
    /**
     * 검색한 필드 목록에서의 인덱스
     */
    searchFieldIndex: number;
    /**
     * 필드이름
     */
    fieldName: string;
}

/**
 * 행 검색 관련 유연한 설정 정보 모델
 *
 * @remarks
 * {@link GridBase.searchItem}에서 사용된다.
 *
 * {@link LocalDataProvider.searchDataRow}, {@link LocalTreeDataProvider.searchDataRow} 에서 사용될 경우, 필터링 되었거나 행 그룹핑 된 경우 감춰진 행들은 찾지 않는다.
 *
 * @example
 *
 * ```js
 * function searchItemHandler() {
 *     let values = ["PR20012392", "QF24212112"]
 *     let fields = [ "RequestType", "ServiceCode" ];
 *     let startFieldIndex = fields.indexOf(grid.getCurrent().fieldName) + 1;
 *     let options = {
 *          fields : fields,
 *          values: values,
 *          startIndex : grid.getCurrent().itemIndex,
 *          startFieldIndex : startFieldIndex,
 *          wrap : true,
 *          caseSensitive : false,
 *          partialMatch : true
 *     }
 *     let index = grid.searchCell(options);
 *     grid.setCurrent(index);
 * }
 * ```
 */
export declare interface SearchOptions {
    /**
     * 검색할 필드 목록
     *
     * @remarks
     * 필드명 또는 필드 인덱스로 지정 가능.
     */
    fields?: string[];
    /**
     * fields 에 지정한 각 필드에 해당하는 순서에 맞게 배열된 검색 조건값
     */
    values?: string[];
    /**
     * 검색 시작 행
     *
     * @defaultValue `0`
     */
    startIndex?: number;
    /**
     * 마지막 행까지 해당하는 행이 없으면 첫 행부터 다시 검색할 것인지 여부
     */
    wrap?: boolean;
    /**
     * 검색된 행 focus 여부
     *
     * @remarks
     * `true`로 지정하면 검색된 행이 있을 때 그 행을 선택하고, 현재 표시된 범위 밖이면 표시되도록 스크롤한다.
     *
     * {@link GridBase.searchItem} 에서만 사용 가능하다.
     *
     * @defaultValue `true`
     */
    select?: boolean;
    /**
     * 해당 조건에 맞는 필드들을 전부 검색할 건지의 여부
     *
     * @remarks
     * `false`면 지정된 fields중 일치하는 필드가 있으면 검색을 종료한다.
     *
     * @defaultValue `true`
     */
    allFields?: boolean;
    /**
     * 대소문자를 구분하여 검색할지의 여부
     *
     * @defaultValue `false`
     */
    caseSensitive?: boolean;
    /**
     * 포함되는 것도 검색할지 여부
     *
     * @defaultValue `false`
     */
    partialMatch?: boolean;
    /**
     * 사용자 정의 조건을 위한 콜백
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * const f = function(v1, v2, sensitive, partialMatch) {
     *      if (v1 === v2) {
     *           return true;
     *      }
     *      let s1 = String(v1);
     *      let s2 = v2 == null ? undefined : String(v2);
     *      if (!s1 && !s2) {
     *           return true;
     *      }
     *      if (!s1 || !s2) {
     *           return false;
     *      }
     *      if (!caseSensitive) {
     *           s1 = s1.toLowerCase();
     *           s2 = s2.toLowerCase();
     *      }
     *      if (partialMatch) {
     *      	    return s2.indexOf(s1) >= 0;
     *      } else {
     *      	    return s1 == s2;
     *      }
     * }
     *
     * let options = {
     *          fields : fields,
     *          values : values,
     *          compareCallback: f
     * }
     *
     * let index = grid.searchItem(options);
     * ```
     */
    compareCallback?: CompareCallback;
    /**
     * 상위트리의 행 고유 번호
     * {@link LocalTreeDataProvider.searchDataRow | LocalTreeDataProvider} 에서만 사용 가능하다.
     */
    parentId?: number;
    /**
     * 역순으로 검색한다.
     *
     * @remarks
     * `reverse`가 `true`이면 startIndex를 기준으로 위의 행을 검색한다.
     */
    reverse?: boolean;
}

/**
 * @public
 *
 * 그리드 선택 영역 정보 모델
 *
 * @remarks
 * {@link GridBase.onCopy}, {@link GridBase.setSelection} 등에서 사용된다.
 */
declare interface Selection {
    /**
     * 스타일
     */
    style?: SelectionStyle;
    /**
     * 시작 행의 itemIndex
     */
    startItem?: number;
    /**
     * 시작 행의 고유 번호
     */
    startRow?: number;
    /**
     * 시작 컬럼의 이름
     */
    startColumn?: string;
    /**
     * 끝 행의 itemIndex
     */
    endItem?: number;
    /**
     * 끝 행의 고유 번호
     */
    endRow?: number;
    /**
     * 끝 컬럼의 이름
     */
    endColumn?: string;


}
export { Selection as Selection }

/**
 * 셀 선택 디스플레이
 *
 * @remarks
 * 개발 중...
 */
export declare enum SelectionDisplay {
    /**
     * 셀
     */
    CELL = "cell",
    /**
     * 셀과 경계
     */
    CELL_AND_BORDER = "cellAndBorder",
    /**
     * 마스크
     */
    MASK = "mask"
}

/**
 * 셀 선택 영역에 대한 모드
 *
 * @remarks
 *
 * {@link DisplayOptions.selectionMode} 에서 사용된다.
 */
declare enum SelectionMode {
    /**
     * 영역선택을 사용하지 않음.
     */
    NONE = "none",
    /**
     * 하나의 영역선택만 사용
     */
    SINGLE = "single",
    /**
     * 여러개의 영역선택을 사용
     */
    EXTENDED = "extended"
}
export { SelectionMode as SelectionMode }

/**
 * 셀 선택 영역에 대한 스타일
 *
 * @remarks
 * `SINGLE`, `SINGLE_ROW`, `SINGLE_COLUMN` 을 single selection style 이라한다.
 *
 * {@link DisplayOptions.selectionStyle} 에서 사용된다.
 *
 * {@link RowIndicator.selectable} 기능이 정상적으로 작동하려면 {@link DisplayOptions.selectionStyle} 이 single selection style 이 아니어야 한다.
 *
 * {@link DisplayOptions.selectionStyle} 이 single selection style 이 아니어야 `ctrl` key 를 누른 후 컬럼헤더 드래그 시 컬럼 단위 선택 영역이 지정된다.
 *
 */
export declare enum SelectionStyle {
    /**
     * 블록 형태로 선택
     */
    BLOCK = "block",
    /**
     * 블록과 동일한 형식으로 선택하지만 셀단위가 아닌 그룹단위로 선택을 한다.
     */
    GROUP = "group",
    /**
     * 행 단위로 선택
     */
    ROWS = "rows",
    /**
     * 컬럼 단위로 선택
     */
    COLUMNS = "columns",
    /**
     * 하나의 행만 선택
     */
    SINGLE_ROW = "singleRow",
    /**
     * 하나의 컬럼만 선택
     */
    SINGLE_COLUMN = "singleColumn",
    /**
     * 하나의 셀만 선택
     */
    SINGLE = "single",
    /**
     * 선택 불가
     */
    NONE = "none"
}

/**
 * @public
 * 하나 이상의 데이터 값을 동시에 표시하는 컬럼
 *
 * @remarks
 * `fieldName` 대신에 `fieldNames` 라는 속성이 있다.
 *
 * `type` 속성에 `'series'` 를 설정하면 적용된다.
 *
 * {@link ValueColumn} 을 상속한다.
 *
 * [상위 클래스]
 *
 * {@link GridColumn} - {@link ValueColumn}
 *
 * @example
 * ```js
 * let column = {
 *     "name": "sparkCol",
 *     "type": "series",
 *     "fieldNames": "201901..201909",
 *     "width": 150,
 *     "renderer": {
 *         "type": "sparkcolumn"
 *     },
 *     "header": {
 *         "text": "Spark Column"
 *     }
 * }
 * ```
 */
export declare interface SeriesColumn extends ValueColumn {
    /**
     * 설정된 필드명들
     */
    fieldNames: string;
}

/**
 * @public
 *
 * 하나 이상의 데이터 값을 동시에 표시하는 Series column 을 텍스트로 표시하기 위한 렌더러
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'series';
 *
 * // object type
 * let column = {
 *     "name": "colSeries",
 *     "type": "series",
 *     "fieldNames": "201601.201701.201801.201901",
 *     "renderer": {
 *         "type": "series",
 *         "valueSeparator": "."
 *     }
 * }
 * ```
 */
export declare interface SeriesTextCellRenderer extends CellRenderer {
    /**
     * 표시되는 값들의 구분자
     *
     * @defaultValue `','`
     */
    valueSeparator?: string;
}

/**
 * 편집 시 체크 결과 값을 결정하는 콜백 형식
 *
 * @remarks
 * {@link CheckCellRenderer.setCheckedCallback} 에서 사용한다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `itemIndex` - 아이템의 순서
 *
 * `column` - 컬럼 객체
 *
 * `oldValue` - 편집 전 값
 *
 * `checked` - 편집 전 체크 상태
 *
 * [반환값] - 체크 결과 값
 *
 * @example
 * ```js
 * const f = function(grid, itemIndex, column, oldValue, checked) {
 *      if (itemIndex % 2 === 0) {
 *          return checked;
 *      }
 *      else if (itemIndex % 17 === 0) {
 *          return oldValue
 *      }
 *      else {
 *          return false;
 *      }
 * }
 * ```
 */
export declare type SetCheckedCallback = (grid: GridBase, itemIndex: number, column: DataColumn, oldValue: any, checked: boolean) => any;

/**
 * @public
 *
 * 그리드에 포함되어 있는 도형을 표시하는 렌더러
 *
 * @remarks
 * 자동 높이에서 `TOP_EDGE`, `BOTTOM_EDGE`를 사용할 수 없다..
 *
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'shape';
 *
 * // object type
 * column.renderer = {
 *     "type": "shape",
 *     "shape": "diamond"
 * }
 * ```
 */
export declare interface ShapeCellRenderer extends CellRenderer {
    /**
     * 도형의 스타일 클래스 명
     *
     * @defaultValue `'rg-shape-renderer-shape'`
     */
    shapeStyle?: string;
    /**
     * 도형 종류
     *
     * @remarks
     * {@link PolygonShape} 에 있는 도형들을 설정할 수 있다.
     *
     * 원 모양을 설정하고 싶다면, `'ellipse'`로 설정하면 된다.
     *
     * `shape` 나 `shapeCallback` 이 지정되지 않은 경우 적용된다.
     *
     * @defaultValue {@link PolygonShape.STAR}
     */
    shape?: string;
    /**
     * 셀 값 - 도형 종류 쌍
     *
     * @remarks
     * `shape` 보다 우선 적용된다.
     *
     * `shapeCallback` 이 지정되지 않은 경우 적용된다.
     *
     * @example
     * ```js
     *
     * let sMap = {
     *      "value1": "triangle",
     *      "value2": "diamond"
     * }
     *
     * column.renderer = {
     *     "type": "shape",
     *     "shapeMap": sMap
     * }
     * ```
     */
    shapeMap?: {
        [cellValue: string]: PolygonShape;
    };
    /**
     * 도형의 종류를 지정하기 위한 콜백
     *
     * @remarks
     * {@link GetShapeCallback} 의 형식을 따른다.
     *
     * @eventProperty
     * @example
     * ```js
     * const f = function(grid, model) {
     *      if (model.value) {
     *          return 'ellipse';
     *      }
     *      else {
     *          return 'minus';
     *      }
     * }
     *
     * column.renderer = {
     *      type: 'shape',
     *      shapeCallback: f
     * }
     * ```
     */
    shapeCallback?: GetShapeCallback;
    /**
     * 도형의 너비
     *
     * @defaultValue `16`
     */
    shapeWidth?: number;
    /**
     * 도형의 높이
     *
     * @defaultValue `16`
     */
    shapeHeight?: number;
    /**
     * 도형의 위치
     *
     * @defaultValue {@link IconLocation.LEFT}
     */
    shapeLocation?: IconLocation;
}

/**
 * @public
 *
 * 엑셀 시트 보호를 적용시 허용할 속성을 지정한다.
 *
 * @remarks
 * 허용하는 경우 "0" 허용하지 않는 경우 "1"을 입력한다.
 *
 * 속성을 지정하지 않으면 엑셀 기본값으로 설정된다.
 *
 * 셀의 잠금/서식숨기기 속성은 {@link DataColumn.cellProtectProps}또는 {@link ColumnStyleObject.cellProtectProps}를 이용한다.
 *
 * @example
 * ```js
 * gridView.exportGrid({
 *     type: "excel",
 *     target: "local",
 *     sheetProtect: true;
 *     protectProperties: {
 *         selectLockedCells: "0",
 *         selectUnlockedCells: "0"
 *     },
 *     protectPassword: "12345678";
 * })
 * ```
 */
export declare interface SheetProtectProperties {
    /**
     * 셀 서식
     */
    formatCells?: string;
    /**
     * 열 서식
     */
    formatColumns?: string;
    /**
     * 행 서식
     */
    formatRows?: string;
    /**
     * 열 삽입
     */
    insertColumns?: string;
    /**
     * 행 삽입
     */
    insertRows?: string;
    /**
     * 하이퍼링크 삽입
     */
    insertHyperlinks?: string;
    /**
     * 열 삭제
     */
    deleteColumns?: string;
    /**
     * 행 삭제
     */
    deleteRows?: string;
    /**
     * 정렬
     */
    sort?: string;
    /**
     * 자동 필터 사용
     */
    autoFilter?: string;
    /**
     * 피벗 테이블 보고서 사용
     */
    pivotTables?: string;
    /**
     * 객체 편집
     */
    objects?: string;
    /**
     * 시나리오 편집
     */
    scenarios?: string;
    /**
     * 잠긴 셀 선택
     */
    selectLockedCells?: string;
    /**
     * 잠기지 않은 셀 선택
     */
    selectUnlockedCells?: string;
}

/**
 * @public
 *
 * 셀 값을 신호세기로 표시하는 렌더러
 *
 * @remarks
 *
 * 주어진 범위 내에서 값이 위치한 곳을 신호세기 형태로 표시한다.
 *
 * mininum과 maxinum이 주어지지 않으면 `0`부터 `barCount`까지가 범위이다.
 *
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'signalbar';
 *
 * // object type
 * let column.renderer = {
 *      "type": "signalbar",
 *      "barCount": 5
 * }
 * ```
 */
export declare interface SignalBarCellRenderer extends CellRenderer {
    /**
     * 신호세기를 보여주는 바의 스타일 명
     *
     * @defaultValue `'rg-signalbar-renderer-bar'`
     */
    barStyle?: string;
    /**
     * 값보다 큰 범위에 적용되는 스타일 명
     *
     * @defaultValue `'rg-signalbar-renderer-inactive'`
     */
    inactiveStyle?: string;
    /**
     * 바의 총 갯수
     *
     * @defaultValue `10`
     */
    barCount?: number;
    /**
     * 바로 표현할 수 있는 최소값
     *
     * @remarks
     * `maximum`과 같이 사용해야 한다.
     *
     * 예를 들어, `minimum`이 50, maximum 이 150 이면, 50부터 150 사이에 값이 위치한 곳까지 barStyle로 표시되고 값보다 큰 범위는 inactiveStyle로 표시된다.
     *
     * @defaultValue `NaN`
     */
    minimum?: number;
    /**
     * 바로 표현할 수 있는 최대값
     *
     * @remarks
     * `minimum`과 같이 사용해야 한다.
     *
     * 예를 들어, `minimum`이 50, maximum 이 150 이면, 50부터 150 사이에 값이 위치한 곳까지 barStyle로 표시되고 값보다 큰 범위는 inactiveStyle로 표시된다.
     *
     * @defaultValue `NaN`
     */
    maximum?: number;
    /**
     * 셀과 비교했을 때 시작 바의 높이 비율
     *
     * @defaultValue `50`
     */
    startRate?: number;
    /**
     * 셀과 비교했을 때 끝 바의 높이 비율
     *
     * @defaultValue `100`
     */
    endRate?: number;
    /**
     * 절대값으로 그릴지의 여부
     *
     * @defaultValue `false`
     */
    absoluteValue: boolean;
}

/**
 * @public
 *
 * 대소문자 구분 유형
 *
 * @remarks
 * {@link SortingOptions.textCase}, {@link GridBase.orderBy | orderBy()} 등에서 사용된다.
 *
 * @example
 * ```js
 * gridView.orderBy(['fruit'], ['descending'], ['insensitive']);
 * ```
 */
export declare enum SortCase {
    /**
     * 구분
     */
    SENSITIVE = "sensitive",
    /**
     * 구분하지 않음
     */
    INSENSITIVE = "insensitive"
}

/**
 * @public
 *
 * 정렬 방식
 *
 * @remarks
 * {@link DataProviderBase.getDistinctValues | getDistinctValues()}, {@link GridBase.orderBy | orderBy()} 등에서 사용된다.
 *
 * @example
 * ```js
 * gridView.orderBy(['fruit'], ['descending'], ['insensitive']);
 * ```
 *
 */
export declare enum SortDirection {
    /**
     * 오름차순
     */
    ASCENDING = "ascending",
    /**
     * 내림차순
     */
    DESCENDING = "descending",
    /**
     * 없음
     */
    NONE = "none"
}

/**
 * 데이터 정렬에 대한 설정 모델
 *
 * @remarks
 * {@link SortingOptions.style | style} 이 "exclusive"일 때 shift 키와 함께 컬럼 헤더를 클릭하면 "inclusive"처럼 동작한다.
 *
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setSortingOptions({enabled: false});
 * ```
 */
export declare interface SortingOptions {
    /**
     * 컬럼 헤더를 클릭으로 컬럼을 정렬 가능 여부
     *
     * @remarks
     * {@link GridBase.orderBy | orderBy()} 는 이 속성 값과 상관없이 실행된다.
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
    /**
     * 그리드에서 여러 컬럼에 대한 정렬 상태를 지정하는 방식
     *
     * @defaultValue {@link SortStyle.EXCLUSIVE}
     */
    style?: SortStyle;
    /**
     * 필터 핸들의 표시 방법
     *
     * @defaultValue {@link HandleVisibility.VISIBLE}
     */
    handleVisibility?: HandleVisibility;
    /**
     * 정렬 전에 commit 할 건지의 여부
     *
     * @defaultValue {@link HandleVisibility.VISIBLE}
     */
    commitBeforeSorting?: boolean;
    /**
     * 정렬 시 현재 focus 된 행 유지 여부
     *
     * @defaultValue `false`
     */
    keepFocusedRow?: boolean;
    /**
     * 대소문자 구분
     *
     * @defaultValue {@link SortCase.SENSITIVE}
     */
    textCase?: SortCase;
    /**
     * 여러 컬럼을 정렬했을 때 정렬 순서 표시 여부
     *
     * @defaultValue `false`
     */
    showSortOrder?: boolean;
    /**
     * 현재페이지 기준으로 정렬할 것인지의 여부
     *
     * @defaultValue `false`
     */
    pageSorting?: boolean;
    /**
     * toast 관련 설정
     *
     * @remarks
     * {@link ToastOptions} 모델을 따른다.
     *
     * @defaultValue `{visible: false, message: "Sorting..."}`
     */
    toast?: ToastOptions;
}

/**
 * @public
 *
 * 데이터 수정 이후 정렬 동작 모드
 *
 * @remarks
 * {@link GridBase.sortMode} 에서 사용된다.
 *
 * @example
 * ```js
 * gridView.sortMode = "explicit";
 * ```
 */
export declare enum SortMode {
    /**
     * 자동
     */
    AUTO = "auto",
    /**
     * 데이터 수정이후 명시적으로 정렬을 수행해야 정렬
     */
    EXPLICIT = "explicit"
}

/**
 * @public
 *
 * 그리드 컬럼 헤더 클릭 시 정렬 유형
 *
 * @remarks
 * {@link SortingOptions.style} 에서 사용된다.
 *
 * @example
 *
 * ```js
 * grid.sortingOptions.style = 'inclusive'
 * ```
 */
export declare enum SortStyle {
    /**
     * 정렬 안 함
     */
    NONE = "none",
    /**
     * 마지막으로 클릭 한 컬럼으로 정렬
     */
    EXCLUSIVE = "exclusive",
    /**
     * 처음으로 클릭 한 컬럼을 우선으로 정렬
     */
    INCLUSIVE = "inclusive",
    /**
     * 마지막으로 클릭한 컬럼을 우선으로 정렬
     */
    REVERSE = "reverse"
}

/**
 * @public
 *
 * 스파크 차트 그래프를 표시하기 위한 렌더러들의 기반 모델
 *
 * @remarks
 * {@link SparkLineRenderer}, {@link SparkColumnRenderer}, {@link SparkWinLossRenderer} 들의 기반
 *
 * SparkChartRenderer 의 모든 프로퍼티는 이를 상속한 위의 모델에서만 설정 / 호출할 수 있다.
 *
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * [하위 크래스]
 *
 * {@link SparkLineRenderer}
 *
 * {@link SparkColumnRenderer}
 *
 * {@link SparkWinLossRenderer}
 *
 * @warning SparkChartRenderer 로 직접 설정하거나 호출할 수 없다.
 */
export declare interface SparkChartRenderer extends CellRenderer {
    /**
     * 기준값
     */
    baseValue: number;
    /**
     * 그려지는 스파크 라인 중 처음 값에 적용되는 스타일 클래스 명
     */
    firstStyle: string;
    /**
     * 그려지는 스파크 라인 중 마지막 값에 적용되는 스타일 클래스 명
     */
    lastStyle: string;
    /**
     * 그려지는 스파크 라인 중 가장 큰 값에 적용되는 스타일 클래스 명
     */
    highStyle: string;
    /**
     * 그려지는 스파크 라인 중 가장 작은 값에 적용되는 스타일 클래스 명
     */
    lowStyle: string;
    /**
     * 그려지는 스파크 라인 중 기준값(`baseValue`)보다 작은 값에 적용되는 스타일 클래스 명
     */
    belowStyle: string;
    /**
     * 그려지는 스파크 라인의 점에 적용되는 스타일 클래스 명
     */
    pointStyle: string;
}

/**
 * @public
 *
 * 하나 이상의 데이터 값을 동시에 표시하는 Series column 을 Spark Column 으로 표시하기 위한 렌더러
 *
 * @remarks
 * 기간 등 일정 범위 내의 데이터 흐름을 간략하고 직관적으로 표시하는 데 유용하다.
 *
 * {@link SeriesColumn} 에서만 사용 가능하다.
 *
 * {@link SparkChartRenderer} 를 상속한다.
 *
 * SparkChartRenderer 의 lastStyle, highStyle, lowStyle 이 기본으로 적용된다.
 *
 * [기본값]
 *
 * `lastStyle`: "rg-sparkcolumn-renderer-last";
 *
 * `highStyle`: "rg-sparkcolumn-renderer-high";
 *
 * `lowStyle`: "rg-sparkcolumn-renderer-low";
 *
 * [상위 클래스]
 *
 * {@link CellRenderer} - {@link SparkChartRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'sparkcolumn';
 *
 * // object type
 * column.renderer = {
 *      "type": "sparkcolumn",
 *      "highStyle": "custom-sparkcolumn-renderer-high",
 *      "barWidth" 0.9
 * }
 * ```
 */
export declare interface SparkColumnRenderer extends SparkChartRenderer {

    /**
     * 차트의 스타일 명
     *
     * @defaultValue `'rg-sparkcolumn-renderer-chart'`
     */
    chartStyle: string;
    /**
     * 그래프 막대 하나가 차지하는 너비 비율
     *
     * @remarks
     * `1`을 초과할 수 없다
     *
     * @defaultValue `0.8`
     */
    barWidth: number;
}

/**
 * @public
 *
 * 하나 이상의 데이터 값을 동시에 표시하는 Series column 을 Spark Line 으로 표시하기 위한 렌더러
 *
 * @remarks
 * 기간 등 일정 범위 내의 데이터 흐름을 간략하고 직관적으로 표시하는 데 유용하다.
 *
 * {@link SeriesColumn} 에서만 사용 가능하다.
 *
 * SparkChartRenderer 의 lastStyle, highStyle, lowStyle 이 기본으로 적용된다.
 *
 * [기본값]
 *
 * `lastStyle`: "rg-sparkline-renderer-last";
 *
 * `highStyle`: "rg-sparkline-renderer-high";
 *
 * `lowStyle`: "rg-sparkline-renderer-low";
 *
 * [상위 클래스]
 *
 * {@link CellRenderer} - {@link SparkChartRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = 'sparkline';
 *
 * // object type
 * let column.renderer = {
 *         "type": "sparkline"
 *     }
 * }
 * ```
 */
export declare interface SparkLineRenderer extends SparkChartRenderer {

    /**
     * 차트의 스타일 명
     *
     * @defaultValue `'rg-sparkline-renderer-chart'`
     */
    chartStyle: string;
}

/**
 * @public
 *
 * 하나 이상의 데이터 값을 동시에 표시하는 Series column 을 Spark WinLoss 으로 표시하기 위한 렌더러
 *
 * @remarks
 * 기간 등 일정 범위 내의 데이터 흐름을 간략하고 직관적으로 표시하는 데 유용하다.
 *
 * {@link SeriesColumn} 에서만 사용 가능하다.
 *
 * {@link SparkChartRenderer} 를 상속한다.
 *
 * SparkChartRenderer 의 belowStyle 이 기본으로 적용된다.
 *
 * [기본값]
 *
 * `belowStyle`: "rg-sparkwinloss-renderer-below";
 *
 * [상위 클래스]
 *
 * {@link CellRenderer} - {@link SparkChartRenderer}
 * @example
 * ```js
 * // string type
 * column.renderer = 'sparkwinloss';
 *
 * // object type
 * let column.renderer = {
 *      "type": "sparkwinloss",
 *      "barWidth": 0.9,
 *      "barHeight": 0.6
 * }
 * ```
 */
export declare interface SparkWinLossRenderer extends SparkChartRenderer {

    /**
     * 차트의 스타일 명
     *
     * @defaultValue `'rg-sparkwinloss-renderer-chart'`
     */
    chartStyle: string;
    /**
     * 그래프 막대 하나가 차지하는 너비 비율
     *
     * @remarks
     * `1`을 초과할 수 없다
     *
     * @defaultValue `0.8`
     */
    barWidth: number;
    /**
     * Loss 일 경우에 막대의 전체 높이 대비 비율
     *
     * @defaultValue `0.4`
     */
    belowHeight: number;
}

/**
 * 행들의 상태를 표시하는 상태바와 관련된 설정 모델
 *
 * {@link GridBase.setStateBar} 사용시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setStateBar({errorVisible: true});
 * ```
 */
export declare interface StateBar {
    /**
     * 너비
     *
     * @defaultValue `20`
     */
    width?: number;
    /**
     * 상태바에 표시되는 상태의 형태
     *
     * @defaultValue {@link StateMark.IMAGE}
     */
    mark?: StateMark;
    /**
     * 상태 바에 표시될 상태 텍스트들
     *
     * @remarks
     * [기본값들 ({@link RowState} 참고)]
     *
     * `'C'`: stateTexts[RowState.CREATED]
     * `'U'`: stateTexts[RowState.UPDATED]
     * `'D'`: stateTexts[RowState.DELETED]
     * `'X'`: stateTexts[RowState.CREATE_AND_DELETED]
     *
     * @example
     * ```js
     * gridView.setStateBar({
     *      stateTexts :{
     *          "created": "신규",
     *          "updated": "수정",
     *          "deleted": "삭제",
     *          "createAndDeleted": "삭제"
     *      }
     * })
     * ```
     */
    stateTexts?: StateTexts;
    /**
     * 오류가 발생 했을 때 상태바에 오류에 해당하는 스타일을 적용할 것인지의 여부
     *
     * @defaultValue `false`
     */
    errorVisible?: boolean;
    /**
     * 체크바, 상태바, 인디케이터 중에서 보여지는 순서 (인덱스)
     *
     * @remarks
     * 숫자가 작을 수록 왼쪽에 배치된다.
     */
    displayOrder?: number;
    /**
     * head 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    headText?: string;
    /**
     * foot 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    footText?: string;
    /**
     * summary 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    sumText?: string;
    /**
     * 팝업 메뉴
     */
    popupMenu?: PopupMenuItem[] | string;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * 셀의 스타일을 지정하기 위한 콜백
     */
    cellStyleCallback?: RowBarCellStyleCallback;
}

/**
 * 상태바의 상태 표시 방법
 */
export declare enum StateMark {
    /**
     * 이미지
     */
    IMAGE = "image",
    /**
     * 텍스트
     */
    TEXT = "text",
    /**
     * 없음
     */
    NONE = "none"
}

/**
 * 상태바에 표시될 상태 텍스트들 종류
 *
 */
export declare interface StateTexts {
    /**
     * 행이 생성됨
     *
     * @defaultValue `'C'`
     */
    "created"?: string;
    /**
     * 행이 업데이트 됨
     *
     * @defaultValue `'U'`
     */
    "updated"?: string;
    /**
     * 행이 삭제됨
     *
     * @defaultValue `'D'`
     */
    "deleted"?: string;
    /**
     * 행이 생성 후 삭제됨
     *
     * @defaultValue `'X'`
     */
    "createAndDeleted"?: string;
    /**
     * 아무것도 아님
     *
     * @defaultValue `''`
     */
    "none"?: string;
}

/**
 *
 * 그리드의 구성요소중 공간을 채우기위해 사용되는 셀의 모델
 *
 */
export declare interface StyledCell {
    model?: 'GridObject';
}

/**
 * @public
 * 사용자 지정의 headerSummary와 footer spanning을 설정하기 위한 콜백
 *
 * @remarks
 * {@link CellLayoutColumnItem} 에서 사용된다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨트롤
 *
 * `layout` - 레이아웃 아이템
 *
 * `footerIndex` - footer의 인덱스
 *
 */
export declare type SummaryCellSpanCallback = (grid: GridBase, layout: CellLayoutColumnItem, summaryIndex: number) => number;

/**
 * @public
 *
 * 그리드의 각 컬럼의 합계를 계산하는 방식
 *
 * @remarks
 * {@link GridBase.summaryMode} 등에서 설정하여 사용할 수 있다.
 *
 * @example
 *
 * ```js
 * let sum = gridView.getSummary('unitPrice', 'sum');
 * ```
 */
export declare enum SummaryMode {
    /**
     * 계산하지 않음
     */
    NONE = "none",
    /**
     * 합, 평균, 최대값, 최소값 등 산술적인 합계를 자동으로 계산
     */
    AGGREGATE = "aggregate",
    /**
     * 분산, 표준 편차 등 통계적 합계를 자동으로 계산
     */
    STATISTICAL = "statistical"
}

/**
 * @public
 *
 * 필드의 합계값을 계산하기 위한 유형
 *
 * @remarks
 * {@link GridBase.getSummary} 에서 사용된다.
 *
 * @example
 *
 * ```js
 * let sum = gridView.getSummary('unitPrice', 'sum');
 * ```
 */
export declare enum SummaryType {
    /**
     * 개수
     */
    COUNT = "count",
    /**
     * 합
     */
    SUM = "sum",
    /**
     * 최대값
     */
    MAX = "max",
    /**
     * 최소값
     */
    MIN = "min",
    /**
     * 평균
     */
    AVG = "avg",
    /**
     * 표본집단 분산
     */
    VAR = "var",
    /**
     * 모집단 분산
     */
    VARP = "varp",
    /**
     * 표본집단 표준편차
     */
    STDEV = "stdev",
    /**
     * 모집단 표준편차
     */
    STDEVP = "stdevp",
    /**
     * 값이 지정되어 잇는 데이터 개수 (null 이 아닌)
     */
    DATACOUNT = "datacount",
    /**
     * `DATACOUNT` 로 나눈 평균
     */
    DATAAVG = "dataavg"
}

/**
 * @public
 *
 * 조회된 data가 모두 보일수 있도록 그리드의 높이를 변경한다.
 *
 * @remarks
 * data가 없는 경우 초기 높이로 표시된다.
 * 많은 data가 출력되는 경우 느려지기 때문에 일부 data만 가져온후 `더보기` 버튼등을 이용해서 data를 추가해야 한다.
 *
 * @defaultValue `none`
 * {@link DisplayOptions.syncGridHeight}에서 설정한다.
 * {@link DisplayOptions.rowHeight}가 `-1`인 경우 사용할수 없다.
 */
export declare enum SyncGridHeight {
    /**
     * 지정된 높이를 유지한다.
     */
    "NONE" = "none",
    /**
     * 그리드의 영역보다 커지는 경우 그리드의 높이를 변경한다.
     */
    "OVER" = "over",
    /**
     * 항상 data 영역에 그리드 높이를 맞춘다.
     */
    "ALWAYS" = "always"
}

/**
 * @public
 *
 * HTML 형식의 템플릿을 표시하는 렌더러
 *
 * @remarks
 * {@link CellRenderer} 를 상속한다.
 *
 * 템플릿 설정 시 중괄호 안에 있는 형식에 따라 다르게 해석된다.
 *
 * `{value}`: 데이터 값
 *
 * `{value: fieldName}`: 필드명에 해당하는 데이터 값
 *
 * 나머지: 필드명으로 간주 될 변수명
 *
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 * ```js
 * let column.renderer = {
 *     type:"html",
 *     template: "<img src='images/realgrid-logo.png' height='20'/><span>${value}-${value:unitprice}-</span><span style='color: red;font-weight: bold;'>${xxx}</span>",
 *     valueCallback: function (grid, model, field) {
 *     if (field == "xxx") {
 *         return "1234";
 *     }
 * }
 * ```
 */
export declare interface TemplateCellRenderer extends CellRenderer {

    /**
     * 입력되는 html 템플릿 형태의 문자열
     *
     * @remarks
     * `callback`이 지정되지 않으면 사용한다.
     */
    template?: string;
    /**
     * template에 `${xxx}` 형태로 감싸진 값을 실제 값으로 치환하기 위한 콜백
     *
     * @remarks
     * 셀의 값에 따라 template를 변경하는 경우 `${xxx}`형태로 template에 지정하면 rendering시 valueCallback을 호출하고 return된 문자열로 `${xxx}`을 대체한다.
     *
     * @eventProperty
     * @example
     * ```js
     * column.renderer = {
     *     type:"html",
     *     template: "<img src='images/realgrid-logo.png' height='20'/><span>${value}-${value:unitprice}-</span><span style='color: red;font-weight: bold;'>${xxx}</span>",
     *     valueCallback: function (grid, model, field) {
     *         if (field == "xxx") {
     *             return "1234";
     *         }
     *     }
     * }
     * ```
     */
    valueCallback?: RealizeValueCallback;

    /**
     * 렌더링 시 표시할 html을 만들기 위한 콜백
     *
     * @remarks
     * 화면에 표시되어야 할 내용이 값에 따라 변경되는 경우 표시되는 html을 만들기 위해 사용한다.
     *
     *
     * @eventProperty
     * @example
     * ```js
     * column.renderer = {
     *     type:"html",
     *     callback: function (grid, model, width, height) {
     *         const value = model.value;
     *         if (value === 'xxx') {
     *             return "<img src='images/realgrid-logo.png' height='" + height / 2 + "'></img>" + "<div>" + model.value + "</div>";
     *         } else {
     *             return "<div>" + model.value + "</div>"
     *         }
     *
     *     }
     * }
     * ```
     */
    callback?: GetTemplateCallback;
    /**
     * renderer에 input element가 있을때 focus를 가질수 있는지 여부
     *
     * @remarks
     * `true`로 지정하면 input element가 focus를 가질수 있다.
     * `false`이면 input element를 클릭해도 그리드가 focus를 가져간다.
     * 그리드의 editor가 아닌 사용자의 input이 focus를 가지는 경우 키보드를 이용한 이동/Tab/편집은 사용자가 관리해야 한다.
     */
    inputFocusable?: boolean;
}

/**
 * @public
 * 텍스트 입력을 받을 수 있는 편집기들의 기반 모델
 *
 * @remarks
 * {@link CellEditor} 를 상속한다.
 *
 * {@link LineCellEditor}, {@link PasswordCellEditor}, {@link DropDownCellEditor}, {@link DateCellEditor}, {@link BTDateCellEditor} 들이 상속받는다.
 *
 * TextCellEditor 의 모든 속성은 이를 상속한 하위 클래스들에서만 호출할 수 있다.
 *
 * [상위 클래스]
 *
 * {@link CellEditor}
 *
 * [하위 클래스]
 *
 * {@link LineCellEditor}
 *
 * {@link PasswordCellEditor}
 *
 * {@link DropDownCellEditor}
 *
 * - {@link SearchCellEditor}
 *
 * - {@link MultiCheckCellEditor}
 *
 * {@link DateCellEditor}
 *
 * {@link BTDateCellEditor}
 *
 * @warning TextCellEditor 로 직접 설정하거나 호출할 수 없다.
 */
export declare interface TextCellEditor extends CellEditor {
    /**
     * 입력할 수 있는 문자의 최대 길이
     *
     * @remarks
     * 0을 입력시에 제한이 없다.
     */
    maxLength?: number;
    /**
     * 텍스트나 날짜 필드에 적용될 수 있는 편집 형식
     */
    mask?: EditMask;
    /**
     * 편집기에 입력되어 있는 값
     */
    text?: string;
}

/**
 * @public
 *
 * 기본 텍스트 렌더러
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link CellRenderer}
 *
 * @example
 * ```js
 * // string type
 * column.renderer = "text"
 *
 * // object type
 * column.renderer = { type: "text", showTooltip: true}
 * ```
 */
export declare interface TextCellRenderer extends CellRenderer {
}

/**
 * @public
 *
 * 대소문자 형태
 *
 * @remarks
 * {@link ValueColumn.textInputCase}, {@link CellEditor.textCase} 등에서 사용된다.
 *
 * @example
 * ```js
 * column.editor = { type: "line", maxLength: 1, textCase: 'lower'}
 * ```
 */
export declare enum TextInputCase {
    /**
     * 입력되는 대로 표시
     */
    NORMAL = "normal",
    /**
     * 대문자로 표시
     */
    UPPER = "upper",
    /**
     * 소문자로 표시
     */
    LOWER = "lower",
    /**
     * 편집기에서 이 값으로 설정되면 컬럼에 설정된 값을 따름
     */
    DEFAULT = "default"
}

/**
 * Toast View 표시 여부와 메시지를 지정할 수 있는 설정 모델
 *
 * @remarks
 * 대량 데이터셋의 정렬/필터링/그룹핑시 화면이 멈춰있는 상태일 때 진행 중임을 알려줄 수 있다.
 *
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFilteringOptions({
 *      toast: {
 *          message: "필터링 중"
 *      }
 * });
 * ```
 */
export declare interface ToastOptions {
    /**
     * 토스트에 표시할 메시지
     *
     * @defaultValue sorting/filtering/grouping 에 따라 다름
     */
    message?: string;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * 토스트 창의 zIndex
     *
     * @defaultValue `3000`
     */
    zIndex?: number;
    /**
     * 토스트 창의 스타일 클래스명
     *
     * @defaultValue `'rg-toast'`
     */
    styleName?: string;
}

/**
 * @public
 *
 * Tree Expander에 표시되는 기본 아이콘의 스타일을 지정한다.
 *
 * @defaultValue `triangle`
 */
export declare enum TreeExpanderIconStyle {
    /**
     * 삼각형 형태의 Tree Expander 아이콘을 표시한다.
     */
    "TRIANGLE" = "triangle",
    /**
     * 사각형 형태의 Tree Expander 아이콘을 표시한다.
     */
    "SQUARE" = "square"
}

/**
 * @public
 * 트리 expander옆에 표시되는 아이콘을 지정하는 콜백
 *
 * [매개변수 목록]
 *
 * `TreeView` - 트리뷰 객체
 *
 * `itemIndex` - 행의 인텍스
 *
 * `dataRow` - 행의 dataRow
 *
 * `iconIndex` - 원 iconIndex의 값
 *
 * [반환값] - icon의 `url` 또는 {@link TreeOptions.iconImages}의 순번
 */
export declare type TreeIconCallback = (tree: TreeView, itemIndex: number, dataRow: number, iconIndex: number) => number | string;

/**
 * {@link TreeView} 표시에 대한 설정 모델
 *
 * @remarks
 * {@link TreeView} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * tree.setTreeOptions({lineVisible: false});
 * ```
 */
export declare interface TreeOptions {
    /**
     * 트리 라인 표시 여부
     *
     * @defaultValue `true`
     */
    lineVisible?: boolean;
    /**
     * 트리 내부 체크 박스 여부
     *
     * @defaultValue `false`
     */
    showCheckBox?: boolean;
    /**
     * 아이콘으로 사용할 이미지 경로
     */
    iconImagesRoot?: string;
    /**
     * 아이콘으로 사용할 이미지 파일 목록
     *
     */
    iconImages?: string[];
    /**
     * 아이템의 아이콘 인덱스가 존재하지 않거나, 총 개수를 넘어가면 지정되는 아이콘 인덱스
     *
     * @defaultValue `-1`
     */
    defaultIcon?: number;
    /**
     * 왼쪽 방향키만 눌렀을 때 접힘 여부
     * @remarks
     * 맨 왼쪽에 위치해 있어야한다.
     *
     * @defaultValue `true`
     */
    collapseWhenLeftKey?: boolean;
    /**
     * ctrl 키와 왼쪽 방향키를 함께 눌렀을 때 접힘 여부
     * @remarks
     * {@link TreeOptions.collapseWhenLeftKey | collapseWhenLeftKey} 가 `false` 여도 동작한다.
     *
     * @defaultValue `true`
     */
    collapseWhenCtrlKey?: boolean;
    /**
     * 오른쪽 방향키를 눌렀을 때 펼침 여부
     *
     * @remarks
     * 맨 오른쪽에 위치해 있어야한다.
     *
     * @defaultValue `true`
     */
    expandWhenRightKey?: boolean;
    /**
     * ctrl 키와 오른쪽 방향키를 함께 눌렀을 때 펼침 여부
     * @remarks
     * {@link TreeOptions.expandWhenRightKey | expandWhenRightKey} 가 `false` 여도 동작한다.
     *
     * @defaultValue `true`
     */
    expandWhenCtrlKey?: boolean;
    /**
     * tree icon visible
     *
     * @defaultValue `true`
     */
    iconVisible?: boolean;
    /**
     * 트리 아이템이 펼쳐졌을때 표시되는 아이콘
     *
     * @defaultValue `-1`
     */
    expandedIcon?: number;
    /**
     * 트리 아이템이 접혀있을때 표시되는 아이콘
     *
     * @defaultValue `-1`
     */
    collapsedIcon?: number;
    /**
     * Tree Expander 아이콘의 형태를 지정
     *
     * @defaultValue {@link TreeExpanderIconStyle.TRIANGLE}
     */
    expanderIconStyle?: TreeExpanderIconStyle;
}

/**
 * @public
 * TreeView 클래스, {@link GridBase} 의 자식 클래스이다.
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link GridBase}
 */
export declare class TreeView extends GridBase {

    /**
     * TreeView 만이 고유로 가지는 설정 모델
     *
     * @remarks
     * {@link TreeOptions} 객체를 반환한다.
     * TreeOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * treeView.treeOptions.iconWidth = 20;
     * ```
     */
    get treeOptions(): TreeOptions;
    /**
     * TreeView의 아이템 노드 펼치기를 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `tree` - TreeView 컨트롤
     *
     * `itemIndex` - 펼쳐지려는 행의 인덱스
     *
     * `rowId` - 펼쳐지려는 행의 고유번호
     *
     *
     * [반환값] - `false`를 반환하면 펼쳐지지 않는다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * treeView.onTreeItemExpanding = function (tree, itemIndex, rowId) {
     *     return false;
     * };
     * ```
     */
    onTreeItemExpanding: (tree: TreeView, itemIndex: number, rowId: number) => boolean;
    /**
     * TreeView의 아이템 노드가 펼쳐졌음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `tree` - TreeView 컨트롤
     *
     * `itemIndex` - 펼쳐진 행의 인덱스
     *
     * `rowId` - 펼쳐진 행의 고유번호
     * @eventProperty
     *
     * @example
     * ```js
     * treeView.onTreeItemExpanded = function (tree, itemIndex, rowId) {
     *     console.log('Expanded at: ' + itemIndex);
     * };
     * ```
     */
    onTreeItemExpanded: (tree: TreeView, itemIndex: number, rowId: number) => void;
    /**
     * TreeView의 아이템 노드 접힘을 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `tree` - TreeView 컨트롤
     *
     * `itemIndex` - 접으려는 행의 인덱스
     *
     * `rowId` - 접으려는 행의 고유번호
     *
     * @eventProperty
     *
     * [반환값] - `false`를 반환하면 펼쳐지지 않는다.
     * @defaultValue `null`
     *
     * @example
     * ```js
     * treeView.onTreeItemCollapsing = function (tree, itemIndex, rowId) {
     *     return false;
     * };
     * ```
     */
    onTreeItemCollapsing: (tree: TreeView, itemIndex: number, rowId: number) => void;
    /**
     * TreeView의 아이템 노드가 졉혔음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `tree` - TreeView 컨트롤
     *
     * `itemIndex` - 접힌 아이템 행의 인덱스
     *
     * `rowId` - 접힌 행의 고유번호
     *
     * @eventProperty
     *
     * @example
     * ```js
     * treeView.onTreeItemCollapsed = function (tree, itemIndex, rowId) {
     *     console.log('Collapsed at: ' + itemIndex);
     * };
     * ```
     */
    onTreeItemCollapsed: (tree: TreeView, itemIndex: number, rowId: number) => void;
    /**
     * TreeView의 값이 변경되었음을 알리는 콜백
     *
     * @remarks
     * 값이 변경된 후 {@link GridBase.commit | commit()} 시 발생한다.
     *
     * [매개변수 목록]
     *
     * `tree` - TreeView 컨트롤
     *
     * `itemIndex` - 값이 변경된 행의 인덱스
     *
     * `rowId` - 값이 변경된 행의 고유번호
     *
     *
     * @eventProperty
     * @example
     * ```js
     * treeView.onTreeItemChanged = function (tree, itemIndex, rowId) {
     *     console.log("TreeItem item changed:: " + itemIndex);
     * };
     * ```
     */
    onTreeItemChanged: (tree: TreeView, itemIndex: number, rowId: number) => void;
    /**
     * 트리 그리드 선택 표시 등, 관련된 설정 정보들을 가져온다.
     *
     * @returns - {@link TreeOptions} 설정 모델과 동일한 내용의 객체.
     *
     * @example
     * ```js
     * let treeOpts = tree.getTreeOptions();
     * treeOpts.lineVisible = false;
     * tree.setTreeOptions(treeOpts);
     * ```
     */
    getTreeOptions(): TreeOptions;
    /**
     * 트리뷰 표시 및 동작과 관련된 설정을 한다.
     *
     * @remarks
     * {@link TreeOptions} 에서 원하는 속성만 지정하여 사용한다.
     *
     * @param options - {@link TreeOptions} 설정 모델과 동일한 내용의 객체. 변경하고자 하는 속성만 변경하면 된다.
     *
     * @example
     *
     * ```js
     * tree.setTreeOptions({lineVisible: false});
     * ```
     */
    setTreeOptions(options: TreeOptions): void;
    /**
     * 부모 행의 인덱스를 반환한다.
     *
     * @param itemIndex - 자식 행의 인덱스
     *
     * @example
     *
     * ```js
     * let pIndex = tree.getParent(3);
     * ```
     */
    getParent(itemIndex: number): number;
    /**
     * 자식 행들의 인덱스들을 반환한다.
     *
     * @param itemIndex - 부모 행의 인덱스
     *
     * @example
     *
     * ```js
     * let cIndexes = tree.getChildren(3);
     * ```
     *
     */
    getChildren(itemIndex: number): number[];
    /**
     * 자손 행들의 인덱스들을 반환한다.
     *
     * @param itemIndex - 조상 행의 인덱스
     *
     * @example
     *
     * ```js
     * let dIndexes = gridView.getDescendants(3);
     * ```
     *
     */
    getDescendants(itemIndex: number): number[];
    /**
     * 조상 행들의 인덱스들을 반환한다.
     *
     * @param itemIndex - 해당 행의 인덱스
     * @param includeRoot - 기본값: `true`, `true`: 숨겨진 최상위 루트행의 인덱스를 포함하여 결과 값으로 반환한다.
     *
     * @example
     *
     * ```js
     * let aIndexes = tree.getAncestors(3);
     * ```
     */
    getAncestors(itemIndex: number, includeRoot?: boolean): number[];
    /**
     * 행을 펼친다.
     *
     * @remarks
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param itemIndex - 펼치려는 행의 인덱스
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 펼침여부
     * @param force - 기본값: `false`, 이미 expanded 상태라도 recursive가 `true`일 때 자손들의 펼침여부
     * @param level - 기본값: `0`, `0`일 때 recursive가 `true`면 모든 자손 펼침
     *
     * @example
     *
     * ```js
     * tree.expand(3);
     * ```
     */
    expand(itemIndex: number, recursive?: boolean, force?: boolean, level?: number): void;
    /**
     * 아이템(행)을 펼친다.
     *
     * @remarks
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param model - 펼치려는 아이템의 모델
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 펼침여부
     * @param force - 기본값: `false`, 이미 expanded 상태라도 recursive가 `true`일 때 자손들의 펼침여부
     * @param level - 기본값: `0`, `0`일 때 recursive가 `true`면 모든 자손 펼침
     *
     * @example
     *
     * ```js
     * let model = tree.getModel(4);
     * tree.expandModel(model);
     * ```
     */
    expandModel(model: GridItem, recursive?: boolean, force?: boolean, level?: number): void;
    /**
     * 행을 접는다.
     *
     * @param itemIndex - 접으려는 행의 인덱스
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 접힘여부
     *
     * @example
     *
     * ```js
     * tree.collapse(3);
     * ```
     */
    collapse(itemIndex: number, recursive?: boolean): void;
    /**
     * 아이템(행)을 접는다.
     *
     * @param model - 접으려는 아이템 모델
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 접힘여부
     *
     * @example
     *
     * ```js
     * let model = tree.getModel(4);
     * tree.collapseModel(model);
     * ```
     */
    collapseModel(model: GridItem, recursive: boolean): void;
    /**
     * 모든 행을 펼친다.
     *
     * @remarks
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param level - 기본값: `0`, `0`일 때 recursive가 `true`면 모든 자손 펼침
     * @example
     *
     * ```js
     * tree.expandAll();
     * ```
     */
    expandAll(level?: number): void;
    /**
     * 모든 행을 접는다.
     *
     * @example
     *
     * ```js
     * tree.collapseAll();
     * ```
     */
    collapseAll(): void;
    /**
     * Check된 아이템들의 index 목록을 배열로 반환한다.
     *
     * @example
     * ```js
     * let checkedItems = treeView.getCheckedItems();
     * ```
     */
    getCheckedItems(): number[];
    /**
     * Check된 데이터 행들의 index 목록을 반환한다.
     *
     * @param visibleOnly - 기본값: `false`, `true`로 입력하면 collapse되거나 페이징시 보이지 않는 행들은 제외한다.
     * @returns 체크 된 트리 데이텅 행들의 고유번호의 배열
     *
     * @example
     * ```js
     * let checkedRows = treeView.getCheckedRows(true);
     * ```
     */
    getCheckedRows(visibleOnly: boolean): number[];
    /**
     * 입력된 행의 자식 행들을 체크하거나 해제한다.
     *
     * @param itemIndex - 부모행의 ItemModel index
     * @param checked - `true`: 체크, `false`: 해제
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 펼침여부
     * @param visibleOnly - `true`면 collapse되거나 페이징시 보이지 않는 행들은 제외한다.
     * @param checkableOnly - `true`면 체크 가능한 상태인 것들만 체크 한다.
     * @param checkEvent - 기본값: `true`, {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * treeView.checkChildren(4, true, true, true, true);
     * ```
     */
    checkChildren(itemIndex: number, checked: boolean, recursive: boolean, visibleOnly: boolean, checkableOnly: boolean, checkEvent?: boolean): void;


}

/**
 * @public
 *
 * 변경된 셀 정보
 *
 * @remarks
 * {@link UpdatedRow} 에서 사용된다.
 */
export declare interface UpdatedCell {
    /**
     * 필드명
     */
    fieldName: string;
    /**
     * 변경 전 값
     */
    oldValue: any;
    /**
     * 변경 후 값
     */
    newValue: any;
}

/**
 * @public
 *
 * 변경된 행 정보
 *
 * @remarks
 * {@link DataProviderBase.getUpdatedCells | getUpdatedCells()} 에서 사용된다.
 */
export declare interface UpdatedRow {
    /**
     * 행의 고유번호
     */
    __rowId: number;
    /**
     * 변경된 셀 정보들
     */
    updatedCells: UpdatedCell[];
}

/**
 * @public
 * 사용자가 출력 셀을 추가할때 사용되는 콜백 {@link GridExportOptions.userCells}이 있는 경우 수행되지 않는다.
 *
 * @remarks
 * [매개변수 목록]
 * `grid` - 현재 export를 진행중인 grid
 *
 * `rowCount` - sheet의 행수
 *
 * `colCount` - sheet의 컬럼수
 *
 * `name` - sheet의 name
 *
 * [반환값] - {@link UserExportCell}의 배열
 *
 * @example
 * ```js
 * var callback = function(grid, rowCount, colCount, sheetName) {
 *  return [{row:3, col: colCount -3, mergeCol: 3, text:"열의 마지막에 표시", styles:{textAlign:"right"}}]
 * }
 * gridView.exportGrid({"type":"excel", "target":"local", "yOffset":4, userCellsCallback: callback});
 * ```
 */
export declare type UserCellsCallback = (grid: GridBase, rowCount: number, columnCount: number, sheetName: string) => UserExportCell[];

/**
 * @public
 * 엑셀로 export할때 그리드가 출력하는 내용외에 추가적으로 출력할 내용을 지정한다.
 *
 * @remarks
 * 그리드가 출력하는 영역을 덮어쓰는 경우 엑셀파일에 오류가 발생할수 있기 때문에 주의해야 한다.
 * row, col, value는 반드시 지정해야 한다.
 * @example
 * ```js
 * var userCells = [
 *  {row: 0, col: 0, value: "사용자 입력문자열"},
 *  {row: 1, col: 0, styleName: "userCellRed", value: "스타일을 적용"},
 *  {row: 2, col: 0, mergeRow: 1, mergeCol: 3, styleName: "userCellRed", value: "merge를 하고 스타일을 적용."},
 *  {row: 3, col: 0, value: "inline-style", styles: {background:"red", fontSize:"20px"}},
 *  {row: 4, col: 0, value: 12345, format: "#,##0.0_ ", styles: {textAlign:"right"}},
 *  {row: 4, col: 2, value: new Date(2022, 4, 16), format: "[$-F800]dddd, mmmm dd, yyyy", styles: {textAlign:"center"}},
 * ]
 * gridView.exportGrid({"type": "excel", "target": "local", "yOffset": 5, "userCells": userCells});
 * ```
 */
export declare interface UserExportCell {
    /**
     * 출력될 행번호 `0`부터 계산된다.
     */
    row: number;
    /**
     * 출력될 컬럼번호 `0`부터 계산된다.
     */
    col: number;
    /**
     * 출력될 내용
     *
     * @remarks
     * string, numbar, Date, boolean 형태의 값을 입력한다.
     */
    value: any;
    /**
     * 셀에 적용될 className
     */
    styleName?: string;
    /**
     * 셀에 적용될 format을 입력한다.
     */
    format?: string;
    /**
     * 셀에 적용될 스타일
     *
     * @example
     * ```js
     * var styles = {
     *     textAlign: "center",
     *     background: "green",
     *     color: "red"
     * }
     *
     * var styles2 = "text-align:center;background:green;color:red"
     * ```
     *
     */
    styles?: ConfigObject | string;
    /**
     * merge할 경우 row갯수
     */
    mergeRow?: number;
    /**
     * merge할 경우 컬럼갯수
     */
    mergeCol?: number;
    /**
     * 행의 높이를 지정한다.
     *
     * @remarks
     * 이미 출력된 행에 추가되는 경우 출력행의 높이를 유지한다.
     *
     * @defaultValue `-1` 엑셀이 높이를 결정.
     */
    height?: number;
    /**
     * mergeRow가 있는 경우 각행의 높이를 지정한다.
     *
     * @remarks
     * 지정하지 않으면 height가 적용된다.
     */
    heights?: number[];


}

/**
 * @public
 * footer의 사용자 지정 span
 *
 * @remarks
 * footer, headerSummary, groupFooter의 셀을 사용자가 span시키기 위한 rowspan, colspan을 지정한다.
 * footerCount가 지정되면 rowspan은 무시된다.
 */
declare interface UserSpan {
    /**
     * rowspan
     */
    rowspan?: number;
    /**
     * colspan
     */
    colspan?: number;
    /**
     * footerCount
     */
    footerCount?: number;
}

/**
 * @public
 *
 * 검증 결과 관련 설정 정보 모델
 *
 * @remarks
 * {@link GridBase.onValidateColumn}, {@link GridBase.onValidateRow}, {@link GridBase.onValidationFail} 에서 사용된다.
 */
export declare interface ValidationError {
    /**
     * 데이터 검증 결과 수준
     */
    level: ValidationLevel;
    /**
     * 표시할 메세지 내용
     */
    message: string;
}

/**
 * @public
 *
 * 데이터 검증 결과 수준
 *
 * @remarks
 * {@link GridBase.setValidations} 등에서 쓰인다.
 *
 * @example
 * ```js
 * gridView.setValidations({
 *      message: 'Too expensive!',
 *      criteria: "values['UnitPrice'] > 100",
 *      level: 'error'
 * })
 * ```
 */
export declare enum ValidationLevel {
    /**
     * 오류
     */
    ERROR = "error",
    /**
     * 경고
     */
    WARNING = "warning",
    /**
     * 정보
     */
    INFO = "info",
    /**
     * 없음
     */
    IGNORE = "ignore"
}

/**
 * @public
 *
 * 검증 방법
 *
 * @remarks
 * {@link GridBase.setValidations} 등에서 쓰인다.
 *
 * @example
 * ```js
 * gridView.setValidations({
 *      message: 'Too expensive!',
 *      criteria: "values['UnitPrice'] > 100",
 *      mode: 'always'
 * })
 * ```
 */
export declare enum ValidationMode {
    /**
     * 항상(삽입, 수정) 커밋될 때마다
     */
    ALWAYS = "always",
    /**
     * 수정한 행이 커밋될 때
     */
    UPDATE = "update",
    /**
     * 추가한 행이 커밋될 때
     */
    INSERT = "insert"
}

/**
 * DataCell의 상위 클래스이다.
 */
export declare interface ValueCell {
    /**
     * Validation 정보
     */
    error?: any;
    /**
     * Validation Level
     */
    errorLevel?: ValidationLevel;
}

/**
 * @public
 * {@link GridColumn} 을 상속한 컬럼 정보 모델
 *
 * @remarks
 * 추가로 서식 정보 등이 들어가 있다.
 *
 * [하위 클래스]
 *
 * {@link DataColumn}
 *
 * {@link SeriesColumn}
 */
export declare interface ValueColumn extends GridColumn {
    /**
     * 컬럼에 지정되어 있는 숫자 형식의 값일 때 표시되는 서식
     *
     * 천단위기호,소수점을 변경하는 경우 `;`로 구분해서 지정.
     *
     * @remarks
     * 예) `'#,##0.###'`
     * `undefined`이면 {@link GridBase.formatOptions}에 지정된 numberFormat이 적용.
     *
     * 형식 - 포맷;소수점기호;천단위기호;반올림구분
     *
     * 반올림구분 - 지정된 소수점 이하 자리를 처리하는 방법
     *  `c` - 올림
     *  `f` - 버림
     *  `a` - 절대값으로 표시
     * @example
     * ```js
     * // 천단위마다 `,`를 표시 하고 소수점이하 자리는 반올림
     * gridView.columnByName("number").numberFormat = "#,##0";
     *
     * // 천단위 기호와 소수점을 변경하는 경우
     * gridView.columnByName("number").numberFormat = "#,##0.00;,;."
     *
     * // 소수점 2자리까지만 표시하고 3번째는 버림
     * gridView.columnByName("number").numberFormat = "#,##0.00;;;f"
     * ```
     *
     * @defaultValue `undefined`
     */
    numberFormat?: string;
    /**
     * -0.00 처럼 표시되는것을 0.00 으로 표시 여부
     *
     * @defaultValue `true`
     */
    displayMinusZero?: boolean;
    /**
     * 컬럼에 지정되어 있는 날짜 형식의 값일 때 표시되는 서식
     * `undefined`이면 {@link GridBase.formatOptions}에 지정된 numberFormat이 적용된다.
     *
     * @remarks
     * 예) `'yy-M-dd'`
     *
     * @defaultValue `undefined`
     */
    datetimeFormat?: string;
    /**
     * 컬럼에 지정되어 있는 Boolean 형식의 값일 때 표시되는 서식
     *
     * @remarks
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
    /**
     * 텍스트 형식의 값일 때 표시되는 서식
     *
     * @remarks
     * 세미콜론(;)으로 구분하여 왼쪽에는 String.prototype.replace의 첫 번째 매개변수, 오른쪽에는 두 번째 매개변수와 같은 타입으로 지정
     * 예) `'([A-Za-z]*); Mr\. \$1'`
     *
     */
    textFormat?: string;
    /**
     * 앞에 추가 될 텍스트
     *
     * @remarks
     * 데이터를 표시할 때 지정한 앞에 추가 될 텍스트를 값의 앞에 붙여 표시한다.
     */
    prefix?: string;
    /**
     * 뒤에 추가 될 텍스트
     *
     * @remarks
     * 데이터를 표시할 때 지정한 뒤에 추가 될 텍스트를 값의 뒤에 붙여 표시한다.
     */
    suffix?: string;
    /**
     * 클립 보드에 복사 시 빈 값을 넘겨줄지의 여부
     *
     * @defaultValue `false`
     */
    blankWhenCopy?: boolean;
    /**
     * Export 시 빈 값을 넘겨줄지의 여부
     *
     * @defaultValue `false`
     */
    blankWhenExport?: boolean;
    /**
     * 편집기에 입력되는 값의 대소문자 변환 형태
     *
     * @defaultValue {@link TextInputCase.NORMAL}
     */
    textInputCase?: TextInputCase;
    /**
     * 스타일 클래스 명
     */
    styleName?: string;
    /**
     * excel로 export될때 사용될 스타일 명
     */
    exportStyleName?: string;
    /**
     * 스타일을 지정하기 위한 콜백
     *
     * @eventProperty
     *  @example
     * ```js
     * const f = function (grid, cell) {
     *      return {
     *          styleName: 'custom-cell'
     *          editor: 'text'
     *      }
     * }
     * column.styleCallback = f;
     * ```
     */
    styleCallback?: CellStyleCallback;
    /**
     * 렌더러
     *
     * @remarks
     * {@link CellRenderer} 참조
     */
    renderer?: CellRenderer;
    /**
     * 편집기
     *
     * @remarks
     * {@link CellEditor} 참조
     */
    editor?: ConfigObject;
    /**
     * 데이터 셀 우측에 표시할 버튼
     *
     * @defaultValue {@link CellButton.NONE}
     *
     * ```js
     * column.button = 'popup';
     * ```
     */
    button?: string;
    /**
     * 컬럼 버튼의 표시 방법
     *
     * @defaultValue {@link ButtonVisibility.DEFAULT}
     */
    buttonVisibility?: ButtonVisibility;
    /**
     * 컬럼 버튼 표시 콜백
     *
     * @eventProperty
     *  @example
     * ```js
     * column.buttonVisibleCallback = function(grid, index, focused, mouseEntered) {
     *   return (grid.getValue(index.itemIndex, index.fieldName) === "AAA" && (focused || mouseEntered))
     * }
     * ```
     * @remarks
     * column.button이 설정되어있을때 특정조건에 해당하는 경우에만 button이 표시되도록 할때 사용한다.
     */
    buttonVisibleCallback?: ButtonVisibleCallback;
    /**
     * 셀 편집기 버튼의 표시 방법
     *
     * @remarks
     * 현재 버튼이 표시되는 셀 편집기는 DropDownCellEditor, DateCellEditor, SearchCellEditor가 있다.
     *
     * @defaultValue {@link ButtonVisibility.DEFAULT }
     */
    editButtonVisibility?: ButtonVisibility;
    /**
     * 팝업메뉴
     *
     * @remarks
     * 메뉴가 지정되면 데이터 셀 위로 마우스가 진입하거나 focus를 가질 때 메뉴 버튼이 활성화된다.
     * {@link MenuItem} 모델의 배열 형태다.
     */
    popupMenu?: ConfigObject[];
    /**
     * 팝업메뉴 이름
     *
     * @remarks
     * {@link GridBase.addPopupMenu}로 등록한 메뉴를 컬럼의 팝업메뉴로 사용한다.
     */
    popupMenuName?: string;
    /**
     *
     * edgeMark 표시여부
     *
     * @remarks
     * 셀에 강조 표시를 할때 사용한다.
     */
    edgeMark?: EdgeMark;
}

/**
 * @public
 *
 * 동일한 값이 아니지만 하나의 그룹으로 묶을때 기준이 되는 값을 개발자가 지정할때 사용한다.
 * field의 dataType과 동일한 dataType으로 return 해야한다.
 *
 * @remarks
 * {@link RowGroup.valueForGroupCallback}에서 사용되는 형식이다.
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `dataRow` - dataRow
 *
 * `fieldName` - fieldName
 *
 * `value` - value
 *
 * @example
 * ```js
 * valueForGroupCallback = function(grid, dataRow, fieldName, value) {
 *		if (value && fieldName === 'date1') {// 특정 field에만 적용.
 *			// Date형식의 data를 년도와 월을 이용해서 그룹으로 묶는다.
 *			return new Date(value.getFullYear(), value.getMonth());
 *		};
 *      // 변경되지 않았다면 원래의 값을 reutrn해야 한다.
 *		return value;
 * }
 * ```
 */
export declare type ValueForGroupCallback = (grid: GridView, dataRow: number, fieldName: string, value: any) => any;

/**
 * @public
 *
 * 데이터 필드의 데이터 자료형
 *
 * @remarks
 * {@link DataField.dataType} 에서 사용될 때는 `TEXT`, `NUMBER`, `DATETIME`, `BOOLEAN`, `OBJECT` 으로 사용되며, 적용한 자료형을 제한하고 싶을 때에는 {@link DataField.subType} 에 다음과 같이 부여 가능하다.
 *
 * {@link DataField.dataType | dataType} 이 `TEXT`: `CHAR`
 *
 * {@link DataField.dataType | dataType} 이 `NUMBER`: `INT`, `UNUM`, `UINT`
 *
 * {@link DataField.dataType | dataType} 이 `DATETIME`: `DATE`
 *
 * @example
 * ```js
 * let fields = [{
 * ...
 *      dataType: "text",
 *      subType: "char",
 * ...
 * }]
 *
 * ds.setFields(fields);
 * ```
 */
export declare enum ValueType {
    /**
     * 텍스트
     */
    TEXT = "text",
    /**
     * 숫자
     */
    NUMBER = "number",
    /**
     * Boolean
     */
    BOOLEAN = "boolean",
    /**
     * 날짜
     */
    DATETIME = "datetime",
    /**
     * 오브젝트
     */
    OBJECT = "object",
    /**
     * 문자
     *
     * @remarks
     * 0보다 큰 `length` 속성과 더불어 길이가 제한된 문자열로 저장된다. `length`를 0 이하로 지정하면 `text` 기본 자료형과 동일하다.
     */
    CHAR = "char",
    /**
     * 0 이상의 숫자
     */
    UNUM = "unum",
    /**
     * 정수형
     *
     * @remarks
     * `i = v >= 0 ? Math.floor(v) : Math.ceil(v);` 와 같은 방식으로 저장 즉, 1.1이면 1로, -1.1이면 -1로 저장된다.
     */
    INT = "int",
    /**
     * 0 이상의 정수형 값
     * @remarks
     * i = `Math.floor(v);` 와 같은 방식으로 저장된다.
     */
    UINT = "uint",
    /**
     * 시간 부분이 제거된 날짜
     */
    DATE = "date"
}

/**
 * direction이 `vertical`인 ColumnGruop의 하위 컬럼에서 위화살표 또는 아래화살표를 입력했을때 focus이동 방식.
 */
export declare enum VerticalMoveStep {
    /**
     * row단위로 이동한다.
     */
    ROW = "row",
    /**
     * 셀단위로 이동한다.
     */
    CELL = "cell"
}

/**
 * {@link GridView} 의 전체 설정 정보들
 *
 * @remarks
 * {@link GridOptions} 를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link GridOptions}
 *
 * @example
 * ```js
 * let options =  {
 *     summaryMode: 'aggregate',
 *     display: {
 *         columnResizable : false
 *     },
 *     grouping: {
 *         enabled: false
 *     }
 * };
 * gridView.setOptions(options);
 * ```
 */
export declare interface ViewOptions extends GridOptions {
    filterOr?: boolean;
    groupSummaryMode?: SummaryMode;
    filterMode?: FilterMode;
    grouping?: GroupingOptions;
    groupPanel?: GroupPanel;
}

/**
 * Shadow Dom 에 관한 설정 모델
 *
 * @remarks
 * 웹 접근성 지원을 위해 그리드 구성 요소의 각 명칭을 지정한다.
 */
export declare interface WaiOptions {
    /**
     * 그리드 제목
     *
     * @remarks
     * table tag의 caption으로 표시된다.
     */
    title?: string;
    /**
     * table의 설명
     *
     * @remarks
     * table tag의 caption으로 표시된다.
     * title이 있으면 title다음에 표시되고 문자열에 `${columns}`가 있으면 해당위치에 column 제목을 표시한다.
     */
    description?: string;
}

/**
 * DataSource (DataProvider)
 */
export declare type DataSource = any;

// /**
//  * GridCell
//  */
// export declare type GridCell = any;

/**
 * BodyTabelCell
 */
export declare type BodyTableCell = any;

/**
 * FormValueItem
 */
export declare type FormValueItem = any;
